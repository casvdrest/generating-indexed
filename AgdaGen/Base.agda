open import AgdaGen.Data
open import Level renaming (suc to sucL ; zero to zeroL)

open import Data.Nat hiding (_⊔_)
open import Data.Bool
open import Data.List using (List; map; [_]; concatMap; []; _∷_; _++_)
open import Data.Product using (Σ; Σ-syntax; _,_; _×_)
open import Data.Unit
open import Data.Fin hiding (lift)
open import Data.Maybe using (Maybe; just; nothing)

open import Function

open import Relation.Binary.PropositionalEquality using (_≡_; refl)

module AgdaGen.Base where

  mutual
    -- The generator type. The `a` type parameter marks the output type of the
    -- generator. The resulting family is indexed by a type marking the type
    -- of values produced by recursive positions. 
    data Gen {ℓ k} : (a : Set ℓ) → (t : Set ℓ) → Set (sucL k ⊔ sucL ℓ) where
  
      -- Marks choice between generators
      Or   : ∀ {a t : Set ℓ} → Gen {ℓ} {k} a t → Gen {ℓ} {k} a t → Gen a t

      -- Applies the values generated by one generator to another
      Ap    : ∀ {a t b : Set ℓ} → Gen {ℓ} {k} (b → a) t → Gen {ℓ} {k} b t  → Gen a t

      -- Lift a single value into the generator type
      Pure  : ∀ {a t : Set ℓ} → a → Gen a t

      -- Monadic bind for generators
      Bind  : ∀ {a b t : Set ℓ} → Gen {ℓ} {k} b t → (b → Gen {ℓ} {k} a t) → Gen a t 

        -- Generator that produces no elements at all. 
      None  : ∀ {a t : Set ℓ} → Gen a t

      -- Marks a recursive positions
      μ     : ∀ {a : Set ℓ} → Gen a a

      -- Call to an external generator. Using this constructor is
      -- only different from including the generator itself if the
      -- called generator contains one or more recursive
      -- positions. 
      `_    : ∀ {a t : Set ℓ} → Gen {ℓ} {k} a a → Gen a t

      ⟨_`_⟩ : ∀ {i : Set k} {p : i → Set ℓ} {t : Set ℓ} → (x : i) → ((x : i) → Genᵢ p p x) → Gen (p x) t


    data Genᵢ {ℓ k} {i : Set k} :
      (i → Set ℓ) → (i → Set ℓ) → i → Set (sucL k ⊔ sucL ℓ) where

      -- Lifts values into the Genᵢ type
      Pureᵢ : ∀ {a t : i → Set ℓ} {x : i} → a x → Genᵢ a t x

      -- Aplies the results of one generator to the results of another
      Apᵢ   : ∀ {a b t : i → Set ℓ} {x : i} {y : i}
            → Genᵢ (λ _ → b y → a x) t x → Genᵢ b t y → Genᵢ a t x

      -- Monadic bind for generators
      Bindᵢ : ∀ {a b t : i → Set ℓ} {x : i} {y : i}
            → Genᵢ a t y → (a y → Genᵢ b t x) → Genᵢ b t x

      -- Choice between generators
      Orᵢ  : ∀ {a t : i → Set ℓ} {x : i}
           → Genᵢ a t x → Genᵢ a t x → Genᵢ a t x

      -- Recursive positions
      μᵢ    : ∀ {a : i → Set ℓ} (x : i) → Genᵢ a a x

      -- Empty generator
      Noneᵢ : ∀ {a t : i → Set ℓ} {x : i} → Genᵢ a t x

      -- Call to external non-indexed generator
      Call  : ∀ {t : i → Set ℓ} {x : i} {b : Set ℓ} → Gen {ℓ} {k} b b → Genᵢ (λ _ → b) t x

      -- Call to external indexed generator
      Callᵢ : ∀ {t : i → Set ℓ} {x : i} {j : Set ℓ} {s : j → Set ℓ}
            → ((y : j) → Genᵢ s s y) → (y : j) → Genᵢ (λ _ → s y) t x

  -- Type synonym for 'closed' generators, e.g. generators whose recursive
  -- positions refer to the same type as the generator as a whole. 
  𝔾 : ∀ {ℓ k} → Set ℓ → Set (Level.suc ℓ ⊔ sucL k)
  𝔾 {ℓ} {k} a = Gen {ℓ} {k} a a

  -- The type of closed indexed generators
  𝔾ᵢ : ∀ {ℓ k} {i : Set k} → (i → Set ℓ) → i → Set (sucL k ⊔ (sucL ℓ))
  𝔾ᵢ f x = Genᵢ f f x

  co𝔾ᵢ : ∀ {ℓ k} {i : Set k} → (i → Set ℓ) → i →  Set (sucL k ⊔ (sucL ℓ))
  co𝔾ᵢ {ℓ} {k} f x = ∀ {b : Set ℓ} → 𝔾 {ℓ} {k} b → 𝔾ᵢ (λ x → f x → b) x
  
  -- Type synonym for 'closed' generators for function types
  co𝔾 : ∀ {ℓ k} → Set ℓ → Set (sucL ℓ ⊔ sucL k)
  co𝔾 {ℓ} {k} a = ∀ {b : Set ℓ} → 𝔾 {ℓ} {k} b → 𝔾 {ℓ} {k} (a → b)

  mutual
    -- Interpretation function for generators. Interprets a a value of the Gen type as a
    -- function from `ℕ` to `List a`.
    --
    -- The first parameter is the generator to be interpreted, the second parameter is a
    -- closed generator that is referred to by recursive positions.
    interpret : ∀ {ℓ k} {a t : Set ℓ} → Gen {ℓ} {k} a t → 𝔾 t → ℕ → List a
    interpret (g         ) tg zero = []
    interpret (Or g₁ g₂  ) tg (suc n) =
      merge (interpret g₁ tg (suc n)) (interpret g₂ tg (suc n))
    interpret (Ap g₁ g₂  ) tg (suc n) =
      concatMap (λ f → map f (interpret g₂ tg (suc n)))
        (interpret g₁ tg (suc n))
    interpret (Pure x    ) tg (suc n) = [ x ]
    interpret (Bind g₁ g₂) tg (suc n) =
      (flip concatMap) (interpret g₁ tg (suc n))
        (λ x → interpret (g₂ x) tg (suc n))
    interpret (None      ) tg (suc n) = []
    interpret (μ         ) tg (suc n) =
      interpret tg tg n
    interpret (` g       ) tg (suc n) =
      interpret g g (suc n)
    interpret ⟨ x ` g ⟩ tg (suc n) =
      interpretᵢ g x (g x) (suc n)

    -- Interpret a generator as a function from recursive depth to List of elements
    interpretᵢ :
      ∀ {ℓ k} {i : Set k} {a t : i → Set ℓ}
      → ((y : i) → Genᵢ t t y) → (x : i) → Genᵢ a t x → ℕ → List (a x)
    interpretᵢ tg x g                    zero = []
    interpretᵢ tg x (Noneᵢ )            (suc n) = []
    interpretᵢ tg x (Pureᵢ v)           (suc n) = [ v ]
    interpretᵢ tg x (Apᵢ {y = y} g₁ g₂) (suc n) =
      concatMap (λ f → map f (interpretᵢ tg y g₂ (suc n) ))
        (interpretᵢ tg x g₁ (suc n))
    interpretᵢ tg x (Bindᵢ {y = y} g f) (suc n) =
      concatMap (λ v → interpretᵢ tg x (f v) (suc n))
        (interpretᵢ tg y g (suc n))
    interpretᵢ tg x (Orᵢ g₁ g₂)         (suc n) =
      merge (interpretᵢ tg x g₁ (suc n))
        (interpretᵢ tg x g₂ (suc n))
    interpretᵢ tg x (μᵢ .x)             (suc n) =
      interpretᵢ tg x (tg x) n
    interpretᵢ tg x (Call g)            (suc n) =
      interpret g g (suc n)
    interpretᵢ tg x (Callᵢ g y)         (suc n) =
      interpretᵢ g y (g y) (suc n)

  -- Interpret a closed generator as a function from `ℕ` to `List a`
  ⟨_⟩ : ∀ {ℓ k} {a : Set ℓ} → Gen {ℓ} {k} a a → ℕ → List a
  ⟨ g ⟩ = interpret g g

  -- Interpretation of closed indexed generators
  ⟨_⟩ᵢ : ∀ {ℓ k} {i : Set k} {f : i → Set ℓ} → ((x : i) → 𝔾ᵢ f x) → (x : i) → ℕ → List (f x)
  ⟨ g ⟩ᵢ x = interpretᵢ g x (g x)


