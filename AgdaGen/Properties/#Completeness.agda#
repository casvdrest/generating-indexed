open import AgdaGen.Base
open import AgdaGen.Combinators
open import AgdaGen.Enumerate
open import AgdaGen.Generic.Isomorphism
open import AgdaGen.Data using (_âˆˆ_; here; _âŠ•_; inl; inr; there; merge)

open import AgdaGen.Properties.General
open import AgdaGen.Properties.Monotonicity

open import Data.Product using (Î£; Î£-syntax; âˆƒ; âˆƒ-syntax; _Ã—_; _,_; projâ‚; projâ‚‚)
open import Data.Sum hiding (map)
open import Data.List
open import Data.Nat
open import Data.Nat.Properties
open import Data.Unit hiding (_â‰¤_)

open import Relation.Binary.PropositionalEquality using (_â‰¡_; refl; cong; sym)
open Relation.Binary.PropositionalEquality.â‰¡-Reasoning

open import Category.Functor
open import Category.Applicative
open import Category.Monad

open import Level renaming (zero to zeroL ; suc to sucL)

module AgdaGen.Properties.Completeness where

  open GApplicative â¦ƒ...â¦„
  open GAlternative â¦ƒ...â¦„

  ------ General Properties ------

  -- Generator productivity: we say that a generator produces
  -- Some value 'x' if there is some n âˆˆ â„• such that 'x' is in
  -- the list we get by applying 'n' to the generator. 
  _âˆ£_â†_ : âˆ€ {a t : Set} â†’ Gen {k = 0â„“} a t â†’ ğ”¾ t â†’ a â†’ Set
  f âˆ£ tg â† x =
    -- 'g' produces 'x' under 'tg' if 'x' is an element of the enumeration
    -- of 'g' under 'tg' at some depth 'n'
    âˆƒ[ n ] (x âˆˆ interpret f tg n)

  -- Productivity property for indexed generators. 
  _âˆ£áµ¢_â†_ :
    âˆ€ {I : Set} {a : Set} {t : I â†’ Set} {i : I}
    â†’ Genáµ¢ a t i â†’ ((i : I) â†’ ğ”¾áµ¢ t i) â†’ a â†’ Set
  _âˆ£áµ¢_â†_ {i = i} g tg x =
    -- Generator 'g' with top level generator 'tg' will produce 'x'
    -- if there is an 'n âˆˆ â„•' such that x is an element of the enumeration
    -- of 'g' under top level generator 'tg' with depth n
    âˆƒ[ n ] (x âˆˆ interpretáµ¢ tg i g n)

  -- Generator Completeness: A generator is complete if we can produce
  -- a productivity proof for all values of its type
  Complete : âˆ€ {a t : Set} â†’ Gen a t â†’ ğ”¾ t â†’ Set
  Complete {a} f tg =
    -- 'f' is complete iff âˆ€ x:a . f produces x
    âˆ€ {x : a} â†’ f âˆ£ tg â† x

  -- Completeness for indexed generators. 
  Completeáµ¢ :
    âˆ€ {I : Set} {a : Set} {t : I â†’ Set} {i : I}
    â†’ Genáµ¢ a t i  â†’ ((i : I) â†’ ğ”¾áµ¢ t i) â†’ Set
  Completeáµ¢ {a = a} {i = i} g tg =
    -- 'g' is complete iff âˆ€ x:a . g produces x
    âˆ€ {x : a} â†’ _âˆ£áµ¢_â†_ {a = a} g tg x 

  -- Call to external generator completeness
  --
  -- Requires a completeness proof of the generator that is called
  `-complete :
    âˆ€ {a t : Set} {tg : ğ”¾ t} {g : ğ”¾ a} {x : a}
    â†’ g âˆ£ g â† x â†’ (` g) âˆ£ tg â† x
  `-complete (suc n , elem) =
    suc n , elem

  -- Completeness for calls to externall generators, from indexed generators
  --
  -- Requires a completeness proof of the generator that is called
  Call-complete :
    âˆ€ {I : Set} {a : âŠ¤ â†’ Set} {t : I â†’ Set} {i : I}
      {x : a tt} {tg : (i : I) â†’ ğ”¾áµ¢ t i} {g : ğ”¾ (a tt)}
    â†’ g âˆ£ g â† x
    â†’ _âˆ£áµ¢_â†_ {i = i} (Call g) tg x
  Call-complete (suc n , elem) =
    -- We simply copy the proof, but the pattern match on 'suc n' is required in
    -- order to guarantee that both enumerations do not default to the empty list.
    suc n , elem

  -- Completeness of recursive positions. A recursive position is complete, given
  -- that the generator it refers to is complete. 
  Î¼-complete :
    âˆ€ {a : Set} {tg : ğ”¾ a} {x : a}
    â†’ tg âˆ£ tg â† x â†’ Î¼ âˆ£ tg â† x
  Î¼-complete (n , elem)
    -- Elements that occur at depth 'n' in a generator
    -- occur at 'suc n' if Î¼ refers to that generator
    = suc n , elem

  -- Completeness for indexed recursive positions. Complete if the generator the refer
  -- is complete. 
  Î¼áµ¢-complete :
    âˆ€ {I : Set} {a : I â†’ Set}
      {tg : (i : I) â†’ ğ”¾áµ¢ a i} {i : I} {x : a i}
    â†’ _âˆ£áµ¢_â†_ {a = a i} (tg i) tg x â†’ _âˆ£áµ¢_â†_ {a = a i} (Î¼áµ¢ i) tg x
  Î¼áµ¢-complete (n , elem)
    -- Elements that occur at depth 'n' in an indexed generator indexed with 'i'
    -- will occur at depth 'suc n' when if 'Î¼áµ¢ i' refers to that generator
    = (suc n) , elem  

  -- Proof that values lifted into the generator type will produce that value
  pure-complete :
    âˆ€ {a t : Set} {tg : ğ”¾ t} {x : a} â†’ â¦‡ x â¦ˆ âˆ£ tg â† x
  pure-complete =
    -- Trivial as 'pure x' will only produce the list '[ x ]'
    1 , here

  -- Proof that values lifted into indexed generators will produce 
  pureáµ¢-complete :
    âˆ€ {I : Set} {a t : I â†’ Set}
      {i : I} {tg : (i : I) â†’ ğ”¾áµ¢ a i}  {x : a i}
    â†’ _âˆ£áµ¢_â†_ {a = a i} {i = i} â¦‡ x â¦ˆ tg x
  pureáµ¢-complete = 1 , here


  ------ Generator Choice ------

  -- Choice between two generators produces an element, given that it is
  -- produced by its left option
  âˆ¥-complete-left :
    âˆ€ {a t : Set} {x : a} {f g : Gen a t} {tg : ğ”¾ t}
    â†’ f âˆ£ tg â† x
    â†’ (f âˆ¥ g) âˆ£ tg â† x
  âˆ¥-complete-left (suc n , p) =
    -- depth remains the same, but transform p from x âˆˆ xs to x âˆˆ merge xs ys
    suc n , merge-complete-left p

  -- Choice between two indexed generators will produce an element if it is produced
  -- by the left generator
  âˆ¥áµ¢-complete-left :
    âˆ€ {I : Set} {a t : I â†’ Set} {i : I} {x : a i}
      {f g : Genáµ¢ (a i) t i} {tg : (i : I) â†’ ğ”¾áµ¢ t i}
    â†’ _âˆ£áµ¢_â†_ {a = a i} f tg x
    â†’ _âˆ£áµ¢_â†_ {a = a i} (f âˆ¥ g) tg x
  âˆ¥áµ¢-complete-left (suc n , p) =
    -- Again, we transform p from x âˆˆ xs to x âˆˆ merge xs ys
    (suc n) , merge-complete-left p

  -- Choice between two generators produces an element, given that it is produced
  -- by its right option
  âˆ¥-complete-right :
    âˆ€ {a t : Set} {x : a} {f g : Gen a t} {tg : ğ”¾ t}
    â†’ g âˆ£ tg â† x
    â†’ (f âˆ¥ g) âˆ£ tg â† x
  âˆ¥-complete-right (zero , ())
  âˆ¥-complete-right (suc n , p) =
    -- p transformed from y âˆˆ ys â†’ y âˆˆ merge xs ys
    suc n , merge-complete-right p

  âˆ¥áµ¢-complete-right :
    âˆ€ {I : Set} {a t : I â†’ Set} {i : I} {x : a i}
      {f g : Genáµ¢ (a i) t i} {tg : (i : I) â†’ ğ”¾áµ¢ t i}
    â†’ _âˆ£áµ¢_â†_ {a = a i} g tg x
    â†’ _âˆ£áµ¢_â†_ {a = a i} (f âˆ¥ g) tg x
  âˆ¥áµ¢-complete-right (suc n , p) =
    -- p transformed from y âˆˆ ys â†’ y âˆˆ merge xs ys
    (suc n) , merge-complete-right p

  -- If an element is produced by choice between two generators, it is either
  -- produced by the left option or by the right option
  âˆ¥-sound :
    âˆ€ {a t : Set} {x : a} {n : â„•} {f g : Gen a t} {tg : ğ”¾ t}
    â†’ (f âˆ¥ g) âˆ£ tg â† x
    â†’ (f âˆ£ tg â† x) âŠ (g âˆ£ tg â† x)
  âˆ¥-sound (zero , ())
  âˆ¥-sound (suc n , p) =
    âŠ•-bimap (Î» x â†’ suc n , x) (Î» y â†’ suc n , y) (merge-sound p)

  -- Indexed generators, too, are sound
  âˆ¥áµ¢-sound :
    âˆ€ {I : Set} {a t : I â†’ Set} {i : I} {x : a i}
      {f g : Genáµ¢ (a i) t i} {tg : (i : I) â†’ ğ”¾áµ¢ t i}
    â†’ _âˆ£áµ¢_â†_ {a = a i} (f âˆ¥ g) tg x
    â†’ (_âˆ£áµ¢_â†_ {a = a i} f tg x) âŠ (_âˆ£áµ¢_â†_ {a = a i} g tg x)
  âˆ¥áµ¢-sound (suc n , p) =
    âŠ•-bimap (Î» x â†’ suc n , x) (Î» y â†’ suc n , y) (merge-sound p)
  
  ------ Generator Product ------
  
  -- If a 'g' produces 'x'
  constr-preserves-elem :
    âˆ€ {a b t : Set} {f : a â†’ b}
      {g : Gen a t} {tg : ğ”¾ t} {x : a}
    â†’ g âˆ£ tg â† x
    â†’ â¦‡ f g â¦ˆ âˆ£ tg â† f x
  constr-preserves-elem (zero , ())
  constr-preserves-elem {f = f} (suc n , elem) =
    suc n , list-ap-complete {fs = [ f ]} here elem

  -- 
  constráµ¢-preserves-elem :
    âˆ€ {I : Set} {a b t : I â†’ Set} {iâ‚ iâ‚‚ : I} {f : a iâ‚ â†’ b iâ‚‚}
      {g : Genáµ¢ (a iâ‚) t iâ‚} {tg : (i : I) â†’ ğ”¾áµ¢ t i} {x : a iâ‚}
    â†’  _âˆ£áµ¢_â†_ {a = a iâ‚} g tg x
    â†’  _âˆ£áµ¢_â†_ {a = b iâ‚‚} {i = iâ‚‚} â¦‡ f g â¦ˆ tg (f x)
  constráµ¢-preserves-elem {f = f} (suc n , elem) = 
    suc n , list-ap-complete {fs = [ f ]} here elem
  
  max : â„• â†’ â„• â†’ â„•
  max zero m = m
  max (suc n) zero = suc n
  max (suc n) (suc m) = suc (max n m)

  max-zero : âˆ€ {n : â„•} â†’ max n 0 â‰¡ n
  max-zero {zero} = refl
  max-zero {suc n} = refl

  max-zero' : âˆ€ {n : â„•} â†’ max 0 n â‰¡ n
  max-zero' = refl

  max-sym : âˆ€ {n m} â†’ max n m â‰¡ max m n
  max-sym {zero} {m} rewrite max-zero {m} = refl
  max-sym {suc n} {zero} = refl
  max-sym {suc n} {suc m} = cong suc (max-sym {n} {m})

  lemma-maxâ‚ : âˆ€ {n m : â„•} â†’ n â‰¤ max n m
  lemma-maxâ‚ {zero} {m} = zâ‰¤n
  lemma-maxâ‚ {suc n} {zero} rewrite max-zero {n = n}
    = sâ‰¤s â‰¤-refl
  lemma-maxâ‚ {suc n} {suc m} = sâ‰¤s lemma-maxâ‚
  
  lemma-maxâ‚‚ : âˆ€ {n m : â„•} â†’ m â‰¤ max n m
  lemma-maxâ‚‚ {n} {m} rewrite max-sym {n} {m} = lemma-maxâ‚ 
  
  -- If f produces x and g produces y, then â¦‡ C f g â¦ˆ, where C is any
  -- 2-arity constructor, produces C x y
  âŠ›-complete :
    âˆ€ {a b c t : Set} {x : a} {y : b} {tg : ğ”¾ t}
      {f : Gen a t} {g : Gen b t} {C : a â†’ b â†’ c}
    â†’ (pâ‚ : f âˆ£ tg â† x) â†’ (pâ‚‚ : g âˆ£ tg â† y)
    â†’ Depth-Monotone f x tg â†’ Depth-Monotone g y tg
    â†’ â¦‡ C f g â¦ˆ âˆ£ tg â† C x y
  âŠ›-complete {a} {b} {c} {f = f} {g = g} {C = C}
    ((suc n) , sndâ‚) ((suc m) , sndâ‚‚) mtâ‚ mtâ‚‚  =  
    max (suc n) (suc m) , list-ap-constr {C = C}
      (mtâ‚ (lemma-maxâ‚ {n = suc n} {m = suc m}) sndâ‚)
      (mtâ‚‚ (lemma-maxâ‚‚ {n = suc n} {m = suc m}) sndâ‚‚)

  âŠ›-completeáµ¢ :
    âˆ€ {I : Set} {a b c t : I â†’ Set} {iâ‚ iâ‚‚ iâ‚ƒ : I}
      {x : a iâ‚} {y : b iâ‚‚} {tg : (i : I) â†’ ğ”¾áµ¢ t i}
      {f : Genáµ¢ (a iâ‚) t iâ‚} {g : Genáµ¢ (b iâ‚‚) t iâ‚‚} {C : a iâ‚ â†’ b iâ‚‚ â†’ c iâ‚ƒ}
    â†’ (pâ‚ : _âˆ£áµ¢_â†_ {a = a iâ‚} f tg x) â†’ (pâ‚‚ : _âˆ£áµ¢_â†_ {a = b iâ‚‚} g tg y)
    â†’ Depth-Monotoneáµ¢ f tg x â†’ Depth-Monotoneáµ¢ g tg y 
    â†’ _âˆ£áµ¢_â†_ {a = c iâ‚ƒ} {i = iâ‚ƒ} â¦‡ C f g â¦ˆ tg (C x y)
  âŠ›-completeáµ¢ {a} {b} {c} {f = f} {g = g} {C = C}
    ((suc n) , sndâ‚) ((suc m) , sndâ‚‚) mtâ‚ mtâ‚‚  =  
    max (suc n) (suc m) , list-ap-constr {C = C}
      (mtâ‚ (lemma-maxâ‚ {n = suc n} {m = suc m}) sndâ‚)
      (mtâ‚‚ (lemma-maxâ‚‚ {n = suc n} {m = suc m}) sndâ‚‚)
  
  ------ Combinator Completeness ------

  -- Completeness of the âˆ¥ combinator, using coproducts to unify
  -- option types
  âˆ¥-Complete :
    âˆ€ {a b t : Set} {f : Gen a t} {g : Gen b t} {tg : ğ”¾ t}
    â†’ Complete f tg â†’ Complete g tg
    â†’ Complete (â¦‡ injâ‚ f â¦ˆ âˆ¥ â¦‡ injâ‚‚ g â¦ˆ) tg
  âˆ¥-Complete {f = f} {g = g} pâ‚ pâ‚‚ {injâ‚ x} =
    âˆ¥-complete-left {f = â¦‡ injâ‚ f â¦ˆ} {g = â¦‡ injâ‚‚ g â¦ˆ}
    (constr-preserves-elem {g = f} pâ‚)
  âˆ¥-Complete {f = f} {g = g} pâ‚ pâ‚‚ {injâ‚‚ y} =
    âˆ¥-complete-right {f = â¦‡ injâ‚ f â¦ˆ} {g = â¦‡ injâ‚‚ g â¦ˆ}
    (constr-preserves-elem {g = g} pâ‚‚)

  âˆ¥-Completeáµ¢ :
    âˆ€ {I : Set} {a b t : I â†’ Set} {i : I} {f : Genáµ¢ (a i) t i}
      {g : Genáµ¢ (b i) t i} {tg : (i : I) â†’ ğ”¾áµ¢ t i}
    â†’ Completeáµ¢ {a = a i} f tg â†’ Completeáµ¢ {a = b i} g tg
    â†’ Completeáµ¢ {a = a i âŠ b i} (â¦‡ injâ‚ f â¦ˆ âˆ¥ â¦‡ injâ‚‚ g â¦ˆ) tg
  âˆ¥-Completeáµ¢ {a = a} {b = b} {f = f} {g = g} pâ‚ pâ‚‚ {injâ‚ x} =
    âˆ¥áµ¢-complete-left {a = Î» i â†’ a i âŠ b i} {f = â¦‡ injâ‚ f â¦ˆ} {g = â¦‡ injâ‚‚ g â¦ˆ}
    (constráµ¢-preserves-elem {a = a} {b = Î» i â†’ a i âŠ b i} {g = f} pâ‚)
  âˆ¥-Completeáµ¢ {a = a} {b = b} {f = f} {g = g} pâ‚ pâ‚‚ {injâ‚‚ y} =
    âˆ¥áµ¢-complete-right {a = Î» i â†’ a i âŠ b i} {f = â¦‡ injâ‚ f â¦ˆ} {g = â¦‡ injâ‚‚ g â¦ˆ}
    (constráµ¢-preserves-elem {a = b} {b = Î» i â†’ a i âŠ b i} {g = g} pâ‚‚)

  
