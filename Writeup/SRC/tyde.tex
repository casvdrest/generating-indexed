\documentclass[acmsmall]{acmart}

\settopmatter{printacmref=false} % Removes citation information below abstract
\renewcommand\footnotetextcopyrightpermission[1]{} % removes footnote with conference information in first column
\pagestyle{plain} % removes running headers

%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
%
\ReadOnlyOnce{agda.fmt}%


\RequirePackage[T1]{fontenc}
\RequirePackage[utf8x]{inputenc}
\RequirePackage{ucs}
\RequirePackage{amsfonts}

\providecommand\mathbbm{\mathbb}

% TODO: Define more of these ...
\DeclareUnicodeCharacter{737}{\textsuperscript{l}}
\DeclareUnicodeCharacter{8718}{\ensuremath{\blacksquare}}
\DeclareUnicodeCharacter{8759}{::}
\DeclareUnicodeCharacter{9669}{\ensuremath{\triangleleft}}
\DeclareUnicodeCharacter{8799}{\ensuremath{\stackrel{\scriptscriptstyle ?}{=}}}
\DeclareUnicodeCharacter{10214}{\ensuremath{\llbracket}}
\DeclareUnicodeCharacter{10215}{\ensuremath{\rrbracket}}

% TODO: This is in general not a good idea.
\providecommand\textepsilon{$\epsilon$}
\providecommand\textmu{$\mu$}


%Actually, varsyms should not occur in Agda output.

% TODO: Make this configurable. IMHO, italics doesn't work well
% for Agda code.

\renewcommand\Varid[1]{\mathord{\textsf{#1}}}
\let\Conid\Varid
\newcommand\Keyword[1]{\textsf{\textbf{#1}}}
\EndFmtInput

%
%
\ReadOnlyOnce{colorcode.fmt}%

\RequirePackage{colortbl}
\RequirePackage{calc}

\makeatletter
\newenvironment{colorhscode}%
  {\hsnewpar\abovedisplayskip
   \hscodestyle
   \tabular{@{}>{\columncolor{codecolor}}p{\linewidth}@{}}%
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \endtabular
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{tightcolorhscode}%
  {\hsnewpar\abovedisplayskip
   \hscodestyle
   \tabular{@{}>{\columncolor{codecolor}\(}l<{\)}@{}}%
   \pmboxed}%
  {\endpmboxed%
   \endtabular
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{barhscode}%
  {\hsnewpar\abovedisplayskip
   \hscodestyle
   \arrayrulecolor{codecolor}%
   \arrayrulewidth=\coderulewidth
   \tabular{|p{\linewidth-\arrayrulewidth-\tabcolsep}@{}}%
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \endtabular
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}
\makeatother

\def\colorcode{\columncolor{codecolor}}
\definecolor{codecolor}{rgb}{1,1,.667}
\newlength{\coderulewidth}
\setlength{\coderulewidth}{3pt}

\newcommand{\colorhs}{\sethscode{colorhscode}}
\newcommand{\tightcolorhs}{\sethscode{tightcolorhscode}}
\newcommand{\barhs}{\sethscode{barhscode}}

\EndFmtInput

\usepackage{xcolor}
\newcommand\todo[1]{\textcolor{red}{\textbf{TODO:} #1}}


\usepackage{textcomp}

\DeclareUnicodeCharacter{10218}{$\langle\langle$}
\DeclareUnicodeCharacter{10219}{$\rangle\rangle$}
\DeclareUnicodeCharacter{7522}{\textsubscript{i}}
\DeclareUnicodeCharacter{7524}{\textsubscript{u}}
\DeclareUnicodeCharacter{8336}{\textsubscript{a}}
\DeclareUnicodeCharacter{8346}{\textsubscript{p}}
\DeclareUnicodeCharacter{10631}{$\llparenthesis$}
\DeclareUnicodeCharacter{10632}{$\rrparenthesis$}
\DeclareUnicodeCharacter{10627}{\{\!\{}
\DeclareUnicodeCharacter{10628}{\}\!\}}
\DeclareUnicodeCharacter{9656}{$\blacktriangleright$}
\DeclareUnicodeCharacter{9667}{$\triangleleft$}
\DeclareUnicodeCharacter{8347}{\textsubscript{s}}
\DeclareUnicodeCharacter{120036}{$\mathcal{U}$}
\DeclareUnicodeCharacter{120024}{$\mathcal{I}$}

\usepackage[font=small,labelfont=bf]{caption}

\usepackage{textgreek}

% Math
\usepackage{amssymb}
% Tables
\usepackage{amsmath}

% Colors
\usepackage{xcolor, color, colortbl}
\colorlet{gray}{gray!70}
\colorlet{green}{green!50}
\definecolor{darkblue}{HTML}{1D577A}
\definecolor{rred}{HTML}{C03425}
\definecolor{darkgreen}{HTML}{8BB523}
\definecolor{ppurple}{HTML}{6B1B7F}
\definecolor{pblack}{HTML}{000000}
\definecolor{darkyellow}{HTML}{C0B225}

% Links
\usepackage{hyperref}
\definecolor{linkcolour}{rgb}{0,0.2,0.6}
\hypersetup{colorlinks,breaklinks,urlcolor=linkcolour,linkcolor=linkcolour,citecolor=blue}

\setlength\mathindent{0.3cm}

\title{Generic Enumerators (Extended Abstract)}

\author{Cas van der Rest}
\email{c.r.vanderrest@students.uu.nl}
\affiliation{
\institution{Universiteit Utrecht}
}
\author{Wouter Swierstra}
\email{w.s.swierstra@uu.nl}
\affiliation{
\institution{Universiteit Utrecht}
}
\author{Manuel Chakravarty}
\email{manuel.chakravarty@iohk.io}
\affiliation{
\institution{Input Output HK}
}


% Remove auto-generated ACM copyright notice
% \setcopyright{none}

\begin{document}

\maketitle

  \section*{Introduction} 

  Since the introduction of QuickCheck \cite{claessen2011quickcheck},
  \textit{property based testing} has proven to be effective for
  the discovery of bugs. However, defining the
  properties to test is only part of the story: it is equally
  important to \emph{generate} suitable test data. In particular,
  requiring random test data to satisfy arbitrary preconditions can
  lead to skewed distributions: for example, naively generating
  random sorted lists will rarely yield long lists. As a
  result, developers need to design custom generators carefully---but
  these generators can become arbitrarily complex. When testing a
  compiler, for example, it can be quite challenging to define a good
  generator that is guaranteed to produce well-formed programs. 
  \cite{palka2011testing, claessen2015generating}
  
  In this brief abstract we propose to address this problem using the
  observation that well-formed inputs can often be described by
  (indexed) inductive datatypes. By defining a \emph{generic}
  procedure for \emph{enumerating} indexed datatypes, we can obtain a
  way of safely generating precise test data. 

  % \paragraph*{Defining generators}

  % Wouter: ik heb dit even in commentaar gezet -- hoewel
  % dit interessant is, zou ik me hier beperken tot
  % Ã©Ã©n interpretatie (lijsten) -- dat maakt het wat concreter.
  % Deze diepe(re) embedding is handig, maar voor nu een implementatie
  % detail.

  % We represent generators as a deep embedding of the combinators
  % exposed by the |Monad| and |Alternative| typeclasses, with
  % additional constructors for recursive positions, calls to other
  % generators and empty generators.

% \begin{code}
% data Gen : (a : Set) â†’ Set where
%   Or    : âˆ€ {a}     â†’ Gen a â†’ Gen a â†’ Gen a
%   Pure  : âˆ€ {a}    â†’ a â†’ Gen a
%   Bind  : âˆ€ {a b}  â†’ Gen b â†’ (b â†’ Gen a) â†’ Gen a In
%   None  : âˆ€ {a}    â†’ Gen a
%   Î¼     : âˆ€ {a}    â†’ Gen a
% \end{code}

% This results in a tree-like structure that can consequently be mapped
% to any desired interpretation.

  We will sketch how to define a generic enumerator for a collection
  of datatypes in several steps:
  \begin{itemize}
  \item We define some universe of types \ensuremath{\Conid{ğ“¤}} together with
    its semantics of the form \ensuremath{\Varid{âŸ¦\char95 âŸ§}\;\mathbin{:}\;\Conid{ğ“¤}\;\Varid{â†’}\;\Conid{S}}, where \ensuremath{\Conid{S}\;\mathbin{:}\;\Conid{Setâ‚}} 
    may vary across the different instantiations of \ensuremath{\Conid{ğ“¤}}. 
  \item Next, we define a datatype generic function producing a 
    list of elements, bounded by some size parameter \ensuremath{\Varid{n}};
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\Varid{enumerate}\;\mathbin{:}\;(\Varid{u}\;\mathbin{:}\;\Conid{ğ“¤})\;\to \;\Conid{â„•}\;\to \;\Conid{List}\;\Varid{âŸ¦}\;\Varid{u}\;\Varid{âŸ§}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
  \item Finally, we formulate the key \emph{completeness} property
    that we expect of our enumerators:
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[7]{}\Varid{âˆ€}\;\{\mskip1.5mu \Varid{u}\;\mathbin{:}\;\Conid{ğ“¤}\mskip1.5mu\}\;{}\<[18]%
\>[18]{}\to \;(\Varid{x}\;\mathbin{:}\;\Varid{âŸ¦}\;\Varid{u}\;\Varid{âŸ§})\;\Varid{â†’}\;{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\Conid{Î£[}\;\Varid{n}\;\Varid{âˆˆ}\;\Conid{â„•}\;\mskip1.5mu]\;(\Varid{x}\;\Varid{âˆˆ}\;\Varid{enumerate}\;\Varid{u}\;\Varid{n}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
    This property states that for each possible \ensuremath{\Varid{x}},
    there is some size \ensuremath{\Varid{n}} such that \ensuremath{\Varid{x}} occurs in our enumeration.
  \end{itemize}

  We will now sketch three increasingly complex universes, together
  with their corresponding generic enumerations.
  
  \section*{Enumeration of regular types}

  One of the simplest universes that describes a wide class of
  algebraic datatypes is the \emph{universe of regular types}. This
  universe contains the unit type, empty type, constant types, and is
  closed under products and coproducts.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Keyword{data}\;\Conid{Reg}\;\mathbin{:}\;\Conid{Set}\;\Keyword{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Z}\;\Conid{U}\;\Conid{I}\;\mathbin{:}\;\Conid{Reg}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{\char95 âŠ•\char95 }\;\Varid{\char95 âŠ—\char95 }\;{}\<[14]%
\>[14]{}\mathbin{:}\;\Conid{Reg}\;\Varid{â†’}\;\Conid{Reg}\;\Varid{â†’}\;\Conid{Reg}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{K}\;{}\<[9]%
\>[9]{}\mathbin{:}\;\Conid{Set}\;\Varid{â†’}\;\Conid{Reg}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  The associated semantics, \ensuremath{\Varid{âŸ¦\char95 âŸ§}\;\mathbin{:}\;\Conid{Reg}\;\to \;\Conid{Set}\;\to \;\Conid{Set}}, maps values of
  type \ensuremath{\Conid{Reg}} to their corresponding pattern functor. By taking the
  fixpoint of such a pattern functor, we have a uniform representation
  of a wide class of (recursive) algebraic datatypes:
  \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\Keyword{data}\;\Conid{Fix}\;(\Varid{c}\;\mathbin{:}\;\Conid{Reg})\;\mathbin{:}\;\Conid{Set}\;\Keyword{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{In}\;\mathbin{:}\;\Varid{âŸ¦}\;\Varid{c}\;\Varid{âŸ§}\;(\Conid{Fix}\;\Varid{c})\;\Varid{â†’}\;\Conid{Fix}\;\Varid{c}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
  Examples of regular types and their respective codes include natural
  numbers (\ensuremath{\Conid{U}\;\Varid{âŠ•}\;\Conid{I}}) or lists  (\ensuremath{\Conid{U}\;\Varid{âŠ•}\;(\Conid{K}\;\Varid{a}\;\Varid{âŠ—}\;\Conid{I})}).
 
  It is reasonably straightforward to define a generic enumeration function:
  \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[7]{}\Varid{enumerate}\;\mathbin{:}\;(\Varid{c}\;\mathbin{:}\;\Conid{Reg})\;\to \;\Conid{â„•}\;\to \;\Conid{List}\;(\Varid{âŸ¦}\;\Varid{c}\;\Varid{âŸ§}\;(\Conid{Fix}\;\Varid{c})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
   For example, the enumeration of a coproduct is a fair merge of the left and right codes, and for products we take the cartesian product. 

  \section*{Enumeration of Indexed Containers}

  What happens when we consider \emph{indexed} datatypes? Initially,
  we will consider \textit{indexed containers}
  \cite{altenkirch2015indexed, dagand2017essence}: indexed types that 
  are defined by induction over the index type \ensuremath{\Conid{ğ“˜}}. Following the 
  presentation by Dagand \cite{dagand2017essence}, we define indexed containers 
  as a triple of \textit{operations}, \textit{arities} and \textit{typing}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{Op}\;\mathbin{:}\;\Conid{ğ“˜}\;\Varid{â†’}\;\Conid{Reg}{}\<[E]%
\\
\>[B]{}\Conid{Ar}\;\mathbin{:}\;\Varid{âˆ€}\;\{\mskip1.5mu \Varid{x}\mskip1.5mu\}\;\Varid{â†’}\;\Conid{Fix}\;(\Conid{Op}\;\Varid{x})\;\Varid{â†’}\;\Conid{Reg}{}\<[E]%
\\
\>[B]{}\Conid{Ty}\;\mathbin{:}\;\Varid{âˆ€}\;\{\mskip1.5mu \Varid{x}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{op}\;\mathbin{:}\;\Conid{Fix}\;(\Conid{Op}\;\Varid{x})\mskip1.5mu\}\;\Varid{â†’}\;\Conid{Fix}\;(\Conid{Ar}\;\Varid{op})\;\Varid{â†’}\;\Conid{ğ“˜}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  \noindent The set \ensuremath{\Conid{Op}\;\Varid{i}} describes the set of available operations at index \ensuremath{\Varid{i}};
  \ensuremath{\Conid{Ar}\;\Varid{op}} the arities of each constructor; and finally, \ensuremath{\Conid{Ty}\;\Varid{ar}} gives the
  index corresponding to the recursive subtree at arity \ensuremath{\Varid{ar}}. Together, 
  they form a type's \emph{Signature}, and are interpreted as a function 
  from index to dependent pair. The first element of the pair denotes 
  a choice of constructor, and the second element is a function that 
  maps each recursive subtree to a value of the type that results from 
  applying the recursive argument with the index given by the typing 
  discipline for that arity. 
  
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{âŸ¦}\;\Conid{Op}\;\Varid{â—ƒ}\;\Conid{Ar}\;\Varid{âˆ£}\;\Conid{Ty}\;\Varid{âŸ§}\;\Varid{x}\;\mathrel{=}\;\Varid{Î»}\;\Varid{i}\;\Varid{â†’}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Î£[}\;\Varid{op}\;\Varid{âˆˆ}\;\Conid{Fix}\;(\Conid{Op}\;\Varid{i})\;\mskip1.5mu]\;(\Varid{ar}\;\mathbin{:}\;\Conid{Fix}\;(\Conid{Ar}\;\Varid{op}))\;\Varid{â†’}\;\Varid{x}\;(\Conid{Ty}\;\Varid{ar}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  Interpretations of signatures live in \ensuremath{\Conid{ğ“˜}\;\Varid{â†’}\;\Conid{Set}}, hence we
  also need adapt our fixpoint, \ensuremath{\Conid{Fix}}, accordingly. 
  
\paragraph{Examples}    
  Many familiar indexed datatypes can be described using the universe
  of indexed containers, such as finite types (\ensuremath{\Conid{Fin}}), well-scoped lambda 
  terms, or the type of vectors given below:

  \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{Î£-vec}\;\Varid{a}\;\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Keyword{let}\;{}\<[10]%
\>[10]{}\Varid{op-vec}\;\mathrel{=}\;(\Varid{Î»}\;\{\mskip1.5mu \Varid{zero}\;\Varid{â†’}\;\Conid{U};(\Varid{suc}\;\Varid{n})\;\Varid{â†’}\;\Conid{K}\;\Varid{a}\mskip1.5mu\}){}\<[E]%
\\
\>[10]{}\Varid{ar-vec}\;\mathrel{=}\;(\Varid{Î»}\;\{\mskip1.5mu \{\mskip1.5mu \Varid{zero}\mskip1.5mu\}\;\Varid{tt}\;\Varid{â†’}\;\Conid{Z};\{\mskip1.5mu \Varid{suc}\;\Varid{n}\mskip1.5mu\}\;\Varid{x}\;\Varid{â†’}\;\Conid{U}\mskip1.5mu\}){}\<[E]%
\\
\>[10]{}\Varid{ty-vec}\;\mathrel{=}\;(\Varid{Î»}\;\{\mskip1.5mu \{\mskip1.5mu \Varid{suc}\;\Varid{n}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;(\Conid{In}\;\Varid{tt})\;\Varid{â†’}\;\Varid{n}\mskip1.5mu\}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Keyword{in}\;{}\<[9]%
\>[9]{}\Varid{op-vec}\;\Varid{â—ƒ}\;\Varid{ar-vec}\;\Varid{âˆ£}\;\Varid{ty-vec}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  \noindent Each index is associated with a unique operation. We map \ensuremath{\Varid{suc}\;\Varid{n}} to a 
  \emph{constant type} in \ensuremath{\Varid{op-vec}}, since the \ensuremath{\Varid{âˆ·}} constructor stores a 
  value along  its recursive subtree. The empty vector, \ensuremath{\Varid{[]}}, has no recursive 
  subtrees; hence, its arity is the \emph{empty type}. Any non-empty vector 
  has one subtree, so we assign its arity to be the \emph{unit type}. 
  This single subtree has an index that is one less than the original index, 
  as described by \ensuremath{\Varid{ty-vec}}.  

  %\todo{Leg uit of haal weg -- anders voegt het weinig toe}

\paragraph*{Generic enumerators.}
  In the definition of indexed containers, we restricted the
  type of operations and arities to the universe of regular types. As a result,
  we can reuse the enumeration of regular types to write a generic enumerator 
  for indexed containers. The second component of a signature's interpretation is 
  a function type, so we require an enumerator for function types. Inspired by 
  \emph{SmallCheck} \cite{runciman2008smallcheck} we can define such an enumerator: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{co-enumerate}\;\mathbin{:}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}(\Conid{â„•}\;\Varid{â†’}\;\Conid{List}\;\Varid{a})\;\Varid{â†’}\;(\Varid{c}\;\mathbin{:}\;\Conid{Reg})\;\Varid{â†’}\;\Conid{â„•}\;\Varid{â†’}\;\Conid{List}\;(\Conid{Fix}\;\Varid{c}\;\Varid{â†’}\;\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  This enables us to define enumerators for both components of the dependent pair:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{enumOp}\;{}\<[9]%
\>[9]{}\mathbin{:}\;\Varid{âˆ€}\;\{\mskip1.5mu \Varid{i}\;\mathbin{:}\;\Conid{ğ“˜}\mskip1.5mu\}\;\Varid{â†’}\;{}\<[24]%
\>[24]{}\Conid{â„•}\;\Varid{â†’}\;\Conid{List}\;(\Conid{Fix}\;(\Conid{Op}\;\Varid{i})){}\<[E]%
\\
\>[B]{}\Varid{enumAr}\;{}\<[9]%
\>[9]{}\mathbin{:}\;\Varid{âˆ€}\;\{\mskip1.5mu \Varid{i}\;\mathbin{:}\;\Conid{ğ“˜}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{r}\;\mathbin{:}\;\Conid{ğ“˜}\;\Varid{â†’}\;\Conid{Set}\mskip1.5mu\}\;\Varid{â†’}\;(\Varid{x}\;\mathbin{:}\;\Conid{Fix}\;(\Conid{Op}\;\Varid{i}))\;{}\<[E]%
\\
\>[9]{}\Varid{â†’}\;\Conid{â„•}\;\Varid{â†’}\;\Conid{List}\;((\Varid{y}\;\mathbin{:}\;\Conid{Fix}\;(\Conid{Ar}\;\Varid{x}))\;\Varid{â†’}\;\Varid{r}\;(\Conid{Ty}\;\Varid{y})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  We then sequence these operations using the monadic structure of
  lists:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{Î»}\;\Varid{n}\;\Varid{â†’}\;\Varid{enumOp}\;\Varid{n}\;\bind \;(\Varid{Î»}\;\Varid{op}\;\Varid{â†’}\;\Varid{op}\;\Varid{,}\;\Varid{enumAr}\;\Varid{n}\;\Varid{op}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  Intuitively, this defines the enumeration of a signature as the union
  of the enumerations of its constructors.
    
\section*{Indexed Descriptions}
  Not all indexed families may be readily described as indexed
  containers. Consider, for example, the type of binary trees indexed by
  their number of nodes:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Keyword{data}\;\Conid{Tree}\;(\Varid{a}\;\mathbin{:}\;\Conid{Set})\;\mathbin{:}\;\Conid{â„•}\;\Varid{â†’}\;\Conid{Set}\;\Keyword{where}{}\<[E]%
\\
\>[3]{}\hsindent{4}{}\<[7]%
\>[7]{}\Conid{Leaf}\;\mathbin{:}\;{}\<[15]%
\>[15]{}\Conid{Tree}\;\Varid{a}\;\Varid{0}{}\<[E]%
\\
\>[3]{}\hsindent{4}{}\<[7]%
\>[7]{}\Conid{Node}\;\mathbin{:}\;{}\<[15]%
\>[15]{}\Varid{âˆ€}\;\{\mskip1.5mu \Varid{n}\;\Varid{m}\mskip1.5mu\}\;\Varid{â†’}\;\Conid{Tree}\;\Varid{a}\;\Varid{n}\;\Varid{â†’}\;\Varid{a}\;\Varid{â†’}\;\Conid{Tree}\;\Varid{a}\;\Varid{m}\;{}\<[E]%
\\
\>[15]{}\Varid{â†’}\;\Conid{Tree}\;\Varid{a}\;(\Varid{suc}\;(\Varid{n}\;\Varid{+}\;\Varid{m})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Without introducing further equalities, it is hard to capture the
decomposition of the index \ensuremath{\Varid{suc}\;(\Varid{n}\;\Varid{+}\;\Varid{m})} into two subtrees of size \ensuremath{\Varid{n}}
and \ensuremath{\Varid{m}}.

The universe of \emph{indexed descriptions}, \ensuremath{\Conid{IDesc}\;\Conid{ğ“˜}}, as described by Dagand \cite{dagand2013cosmology}, is capable of representing arbitrary
indexed families. This universe makes two key modifications to 
the universe of regular types: recursive positions must store an additional 
field corresponding to their index and a new combinator, \ensuremath{\Varid{`Î£}}, is 
added. 
  
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{I}\;{}\<[6]%
\>[6]{}\mathbin{:}\;(\Varid{i}\;\mathbin{:}\;\Conid{ğ“˜})\;\Varid{â†’}\;\Conid{IDesc}\;\Conid{ğ“˜}{}\<[E]%
\\
\>[B]{}\Varid{`Î£}\;{}\<[6]%
\>[6]{}\mathbin{:}\;(\Conid{S}\;\mathbin{:}\;\Conid{Set})\;\Varid{â†’}\;(\Conid{T}\;\mathbin{:}\;\Conid{S}\;\Varid{â†’}\;\Conid{IDesc}\;\Conid{ğ“˜})\;\Varid{â†’}\;\Conid{IDesc}\;\Conid{ğ“˜}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\noindent
Their interpretation is rather straightforward. 
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{âŸ¦}\;\Conid{I}\;\Varid{i}\;{}\<[11]%
\>[11]{}\Varid{âŸ§}\;\Varid{r}\;\mathrel{=}\;\Varid{r}\;\Varid{i}{}\<[E]%
\\
\>[B]{}\Varid{âŸ¦}\;\Varid{`Î£}\;\Conid{S}\;\Conid{T}\;{}\<[11]%
\>[11]{}\Varid{âŸ§}\;\Varid{r}\;\mathrel{=}\;\Conid{Î£[}\;\Varid{s}\;\Varid{âˆˆ}\;\Conid{S}\;\mskip1.5mu]\;\Varid{âŸ¦}\;\Conid{T}\;\Varid{s}\;\Varid{âŸ§}\;\Varid{r}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
With the added \ensuremath{\Varid{`Î£}} and \ensuremath{\Varid{`var}}, we can now describe the \ensuremath{\Conid{Tree}} datatype: 
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{tree}\;\mathbin{:}\;\Conid{Set}\;\Varid{â†’}\;\Conid{â„•}\;\Varid{â†’}\;\Conid{IDesc}\;\Conid{â„•}{}\<[E]%
\\
\>[B]{}\Varid{tree}\;\Varid{a}\;\Varid{zero}\;{}\<[18]%
\>[18]{}\mathrel{=}\;\Varid{`1}{}\<[E]%
\\
\>[B]{}\Varid{tree}\;\Varid{a}\;(\Varid{suc}\;\Varid{n'})\;{}\<[18]%
\>[18]{}\mathrel{=}\;\Varid{`Î£}\;(\Conid{Î£[}\;(\Varid{n}\;\Varid{,}\;\Varid{m})\;\Varid{âˆˆ}\;\Conid{â„•}\;\Varid{Ã—}\;\Conid{â„•}\;\mskip1.5mu]\;\Varid{n}\;\Varid{+}\;\Varid{m}\;\Varid{â‰¡}\;\Varid{n'})\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{Î»}\;\{\mskip1.5mu (\Varid{n}\;\Varid{,}\;\Varid{m}\;\Varid{,}\;\Varid{refl})\;\Varid{â†’}\;\Conid{I}\;\Varid{n}\;\Varid{âŠ—}\;\Conid{K}\;\Varid{a}\;\Varid{âŠ—}\;\Conid{I}\;\Varid{m}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The dependency between the indices of the left and right subtrees of
nodes is captured by having their description depend on a pair of
natural numbers together with a proof that these numbers add up to the required
index.

\paragraph*{Enumerators for indexed descriptions.}
Since the \ensuremath{\Conid{IDesc}} universe largely exposes the same combinators as the
universe of regular types, we only really need to define \ensuremath{\Varid{enumerate}}
for the \ensuremath{\Varid{`Î£}} combinator. This is straightforward once we can enumerate 
its first component. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{enumerate}\;\mathbin{:}\;(\Varid{Î´}\;\mathbin{:}\;\Conid{IDesc}\;\Conid{I})\;\Varid{â†’}\;\Conid{â„•}\;\Varid{â†’}\;\Conid{List}\;(\Conid{Fix}\;\Varid{Î´}){}\<[E]%
\\
\>[B]{}\Varid{enumerate}\;(\Varid{`Î£}\;\Varid{s}\;\Varid{g})\;\mathrel{=}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{Î»}\;\Varid{n}\;\Varid{â†’}\;\Varid{gen}\;\Varid{n}\;\bind \;(\Varid{Î»}\;\Varid{x}\;\Varid{â†’}\;\Varid{x}\;\Varid{,}\;\Varid{enumerate}\;(\Varid{g}\;\Varid{s})\;\Varid{n}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

However, since \ensuremath{\Varid{`Î£}} may range over any type in \ensuremath{\Conid{Set}}, 
we have no generic procedure to obtain a suitable enumerator. 
This creates a separation between the parts of a datatype for which an 
enumerator can be assembled mechanically, and those parts for which this 
would be too difficult. 

In the case of the \ensuremath{\Conid{Tree}} datatype, we see that those elements that make 
it hard to generically enumerate inhabitants of this datatype emerge 
quite naturally; we merely need to supply an enumerator that inverts addition:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{+â»Â¹}\;{}\<[6]%
\>[6]{}\mathbin{:}\;(\Varid{n}\;\mathbin{:}\;\Conid{â„•})\;\Varid{â†’}\;\Conid{â„•}\;{}\<[E]%
\\
\>[6]{}\Varid{â†’}\;\Conid{List}\;(\Conid{Î£[}\;(\Varid{n}\;\Varid{,}\;\Varid{m})\;\Varid{âˆˆ}\;\Conid{â„•}\;\Varid{Ã—}\;\Conid{â„•}\;\mskip1.5mu]\;\Varid{n}\;\Varid{+}\;\Varid{m}\;\Varid{â‰¡}\;\Varid{n'}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Using this inversion, and the combinators we have seen previously, we can define a function \ensuremath{\Varid{enumerate}} that lists all inhabitants of \ensuremath{\Conid{Tree}}. 

  %  \todo{Dit
  %  is in zekere zin het meest interessante aan de hele abstract -- leg
  %  dit beter uit: omdat je moet Sigmas toestaat over een arbitrary set
  %  (of is het niet beter om een expliciete constraint constructor toe
  %  te voegen?), kun je geen generieke generator geven. Dus verwacht je
  %  die van de gebruiker.}

\paragraph{Applying our approach in Haskell.}

We developed a prototype library in Haskell that implements 
the generic enumerator for indexed descriptions. So far, we have 
been able to show that the techniques described in this abstract 
can be applied to enumerate well-typed lambda terms, and are working
towards generation of well-formed terms in more complex programming 
languages; specifically, \textit{Plutus Core} \cite{plutusspec2019}, 
which is used as the transaction validation language on the 
Cardano blockchain.  

% \todo{Noem heel kort quickchick als alternatief}
  
\bibliographystyle{acm} % ACM-Reference-Format
\bibliography{references}
\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-command-default: "lagda2pdf"
%%% End: 


