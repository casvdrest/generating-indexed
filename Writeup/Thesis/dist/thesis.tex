\documentclass[a4paper,msc,twosized=semi]{uustthesis}

\usepackage{framed}
\usepackage{mdframed}
\usepackage{setspace}
\usepackage{fontspec}
\usepackage{mathtools}


\newfontfamily{\agdafont}{DejaVu Sans Mono}[Scale=MatchLowercase]
\newfontfamily{\agdafontinline}{DejaVu Sans Mono}[Scale=MatchLowercase]
\renewcommand{\figurename}{Listing}
\renewcommand{\listfigurename}{Code listings}

\let\oldemph\emph
\renewcommand\emph[1]{{\large\oldemph{#1}}}

\definecolor{agdacolor}{rgb}{ 0.15 , 0 , 0.6 }

\newcommand{\agda}[1]{{\agdafontinline\color{agdacolor}#1}}

%% Listings 
\newenvironment{listing}[2] %% #1 = caption #2 = label
{
    \begin{figure}[h]
      \begin{mdframed}[linecolor=black!50]
        \caption{#1}\label{#2}
}
{
      \end{mdframed}
    \end{figure}
}
%% Agda snippets 
\newcommand{\includeagda}[2]{\vspace*{-0.25cm}\begin{center}{\fontsize{12}{14}\agdafont\ExecuteMetaData[../src/chap0#1/latex/code.tex]{#2}}\end{center}\vspace*{-0.25cm}}

%% Agda snippets, without removed spacing
\newcommand{\includeagdanv}[2]{\begin{center}{\fontsize{12}{14}\agdafont\ExecuteMetaData[../src/chap0#1/latex/code.tex]{#2}}\end{center}}

%% Agda snippets, not centered
\newcommand{\includeagdanc}[2]{{\fontsize{12}{14}\agdafont\ExecuteMetaData[../src/chap0#1/latex/code.tex]{#2}}\vspace*{-0.25cm}}

%% Agda listings
\newcommand{\includeagdalisting}[4]{
  \begin{listing}{#3}{#4} 
    \includeagdanc{#1}{#2}
  \end{listing} 
}

%% Agda snippets (appendices)
\newcommand{\appincludeagda}[2]{\ExecuteMetaData[../src/app#1/latex/code.tex]{#2}}

%% Agda listings (appendices)
\newcommand{\appincludeagdalisting}[4]{
  \begin{listing}{#3}{#4} 
    \appincludeagda{#1}{#2}
  \end{listing}
}

\newmdenv[
  topline=false,
  bottomline=false,
  rightline=false,
  skipabove=\topsep,
  skipbelow=\topsep, 
  linecolor=black!50
]{siderules}

\newenvironment{example}[0] 
{
  \begin{siderules}
    \vspace{-0.5cm}
    \paragraph{\textbf{Example}}
}
{
  \end{siderules}
}

%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
%
%
\ReadOnlyOnce{colorcode.fmt}%

\RequirePackage{colortbl}
\RequirePackage{calc}

\makeatletter
\newenvironment{colorhscode}%
  {\hsnewpar\abovedisplayskip
   \hscodestyle
   \tabular{@{}>{\columncolor{codecolor}}p{\linewidth}@{}}%
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \endtabular
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{tightcolorhscode}%
  {\hsnewpar\abovedisplayskip
   \hscodestyle
   \tabular{@{}>{\columncolor{codecolor}\(}l<{\)}@{}}%
   \pmboxed}%
  {\endpmboxed%
   \endtabular
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{barhscode}%
  {\hsnewpar\abovedisplayskip
   \hscodestyle
   \arrayrulecolor{codecolor}%
   \arrayrulewidth=\coderulewidth
   \tabular{|p{\linewidth-\arrayrulewidth-\tabcolsep}@{}}%
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \endtabular
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}
\makeatother

\def\colorcode{\columncolor{codecolor}}
\definecolor{codecolor}{rgb}{1,1,.667}
\newlength{\coderulewidth}
\setlength{\coderulewidth}{3pt}

\newcommand{\colorhs}{\sethscode{colorhscode}}
\newcommand{\tightcolorhs}{\sethscode{tightcolorhscode}}
\newcommand{\barhs}{\sethscode{barhscode}}

\EndFmtInput

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 
%% Haskell Styling
%%
%% TODO: Figure out spacing!

%% Colors (from duo-tone light syntax)
\definecolor{hsblack}{RGB}{45,32,3}
\definecolor{hsgold1}{RGB}{179,169,149}
\definecolor{hsgold2}{RGB}{177,149,90}
\definecolor{hsgold3}{RGB}{190,106,13}%{192,96,4}%{132,97,19}
\definecolor{hsblue1}{RGB}{173,176,182}
\definecolor{hsblue2}{RGB}{113,142,205}
\definecolor{hsblue3}{RGB}{0,33,132}
\definecolor{hsblue4}{RGB}{97,108,132}
\definecolor{hsblue5}{RGB}{34,50,68}
\definecolor{hsred2}{RGB}{191,121,103}
\definecolor{hsred3}{RGB}{171,72,46}

%% LaTeX Kerning nastiness. By using curly braces to delimit color group,
%% it breaks spacing. The following seems to work:
%%
%% https://tex.stackexchange.com/questions/85033/colored-symbols/85035#85035
%%
\newcommand*{\mathcolor}{}
\def\mathcolor#1#{\mathcoloraux{#1}}
\newcommand*{\mathcoloraux}[3]{%
  \protect\leavevmode
  \begingroup
    \color#1{#2}#3%
  \endgroup
}
\newcommand{\HSKeyword}[1]{\mathcolor{hsgold3}{\textbf{#1}}}
\newcommand{\HSNumeral}[1]{\mathcolor{hsred3}{#1}}
\newcommand{\HSChar}[1]{\mathcolor{hsred2}{#1}}
\newcommand{\HSString}[1]{\mathcolor{hsred2}{#1}}
\newcommand{\HSSpecial}[1]{\mathcolor{hsblue4}{#1}}
\newcommand{\HSSym}[1]{\mathcolor{hsblue4}{#1}}
\newcommand{\HSCon}[1]{\mathcolor{hsblue3}{\mathit{#1}}}
\newcommand{\HSVar}[1]{\mathcolor{hsblue5}{\mathit{#1}}}
\newcommand{\HSComment}[1]{\mathcolor{hsgold2}{\textit{#1}}}


%%% lhs2TeX parser does not recognize '*' 
%%% in kind annotations, it thinks it is a multiplication.



\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{textcomp}

%% Haskell snippet 
\newenvironment{myhaskell}
{
  \vspace{-0.35cm}
  \begin{center}
}
{
  \end{center}
  \vspace{-0.35cm}
}

%% Haskell snippet 
\newenvironment{myhaskellnv}
{
  \begin{center}
}
{
  \end{center}
}


\title{Generating Constrained Test Data using Datatype Generic Programming}

\author{C.R. van der Rest}

\supervisor{Dr. W.S. Swierstra \\ Dr. M.M.T. Chakravarty \\ Dr. A. Serrano Mena }

\setstretch{1.125}

\begin{document}
\maketitle


%% Set up the front matter of our book
\frontmatter
\tableofcontents

\chapter{Declaration}
I am very grateful to my advisors Wouter Swierstra and Manuel Chakravarty, without whom this work would not have been what it is today. Their encouragement, guidance and constructive criticism has been invaluable to me, and I am glad to have had the opportunity to conduct my Master's thesis under their supervision. Furthermore, I am thankful to the members of IOHK's Plutus team for finding time in their schedule to discuss the project with me, and for the financial support provided by IOHK. \\ \\
I declare that this thesis has been composed solely by myself and that it has not been
submitted, in whole or in part, in any previous application for a degree. Except where
stated otherwise by reference or acknowledgment, the work presented is entirely my
own.

\chapter{Abstract}
The generation of suitable test data is an essential part of \emph{property based testing}. Obtaining test data is simple enough when there are no additional constraints, however things become more complicated once we require data with a richer structure, for example well-formed programs when testing a compiler. We observe that we can often describe constrained data as an \emph{indexed family}. By generating values of an indexed family that describes a set of constrained test data, we simultaneously obtain a way to generate the constrained data itself. To achieve this goal, we consider three increasingly expressive type universes: \emph{regular types}, \emph{indexed containers} and \emph{indexed descriptions}. We show how generators can be derived from codes in these universes, and for \emph{regular types} and \emph{indexed descriptions} we show that these derived generators are \emph{complete}. We implement the generic generator for indexed descriptions in Haskell, and use this implementation to generate constrained test data, such as well-typed lambda terms. 

%% Starts the mainmatter
\mainmatter

\chapter{Introduction}\label{sec:introduction}
A proven method for assuring ourselves that the programs we write behave according to our intentions is by simply running them, and observing their behavior. This approach, where we do not try to reason about a program by looking at its code, but rather treat it as a black box which we expect to have a certain behavior is commonly known as \emph{property based testing}. Of course, this requires us to come up with suitable \emph{input values} to run our program on. This thesis concerns itself with the question of \emph{how} we can find these input values, specifically if our input data is subject to \emph{constraints}. For example, if we want to test that the code generation stage of a compiler produces correct results, we need well-formed programs to run it on. We approach this problem by developing a general framework with which we can both describe and generate many kinds of constrained data, using indexed families as a uniform representation of these constraints. 

The topic of this thesis was originally proposed by Wouter Swierstra, who suggested this work as a means to work towards term generation for \emph{Plutus Core} \cite{plutusspec2019}, which is the compilation target of the smart contract language used by the \emph{Cardano} \cite{cardano} blockchain.   

\section{Problem statement}

  At first glance, defining properties that capture the desired behavior of a program may seem like the challenging aspect of property based testing. While properly defining a program's behavior in terms of a few universal properties is certainly hard, so is generating suitable test data. To illustrate this, we consider a simple example in the context of QuickCheck \cite{claessen2011quickcheck}. Suppose we are writing an implementation of \emph{insertion sort}, and we want to make sure that we can insert an element into a sorted list while preserving its sortedness. We write the following predicate that checks whether a list of integers is sorted: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{sorted}\HSSym{::}\HSSpecial{\HSSym{[\mskip1.5mu} }\HSCon{Int}\HSSpecial{\HSSym{\mskip1.5mu]}}\HSSym{\to} \HSCon{Bool}{}\<[E]%
\\
\>[B]{}\HSVar{sorted}\;\HSSpecial{\HSSym{[\mskip1.5mu} }\HSSpecial{\HSSym{\mskip1.5mu]}}{}\<[18]%
\>[18]{}\HSSym{\mathrel{=}}\HSCon{True}{}\<[E]%
\\
\>[B]{}\HSVar{sorted}\;\HSSpecial{\HSSym{[\mskip1.5mu} }\HSVar{x}\HSSpecial{\HSSym{\mskip1.5mu]}}{}\<[18]%
\>[18]{}\HSSym{\mathrel{=}}\HSCon{True}{}\<[E]%
\\
\>[B]{}\HSVar{sorted}\;\HSSpecial{(}\HSVar{x}\HSCon{\mathbin{:}}\HSVar{y}\HSCon{\mathbin{:}}\HSVar{xs}\HSSpecial{)}{}\<[18]%
\>[18]{}\HSSym{\mathrel{=}}\HSVar{x}\HSSym{\leq} \HSVar{y}\HSSym{\mathrel{\wedge}}\HSVar{sorted}\;\HSSpecial{(}\HSVar{y}\HSCon{\mathbin{:}}\HSVar{xs}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  With this predicate at hand, we set out to define a property that we believe 
  should hold for the \ensuremath{\HSVar{insert}} function. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\HSVar{prop}\HSSym{::}\HSCon{Int}\HSSym{\to} \HSSpecial{\HSSym{[\mskip1.5mu} }\HSCon{Int}\HSSpecial{\HSSym{\mskip1.5mu]}}\HSSym{\to} \HSCon{Property}{}\<[E]%
\\
\>[3]{}\HSVar{prop}\;\HSVar{x}\;\HSVar{xs}\HSSym{\mathrel{=}}\HSVar{sorted}\;\HSVar{xs}\HSSym{==>}\HSVar{sorted}\;\HSSpecial{(}\HSVar{insert}\;\HSVar{x}\;\HSVar{xs}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  However, once we try to test this property by simply calling \ensuremath{\HSVar{quickCheck}\;\HSVar{prop}} we are presented with the following output:

\begin{tabbing}\ttfamily
~\char62{}~quickCheck~prop\\
\ttfamily ~\char42{}\char42{}\char42{}~Gave~up\char33{}~Passed~only~70~tests\char59{}~1000~discarded~tests\char46{}
\end{tabbing}

  QuickCheck was not able to find enough suitable test cases! To 
  obtain test values, QuickCheck uses its \ensuremath{\HSCon{Arbitrary}} typeclass, meaning in this case 
  that \ensuremath{\HSVar{xs}} will just be a list of random integers. This has two important 
  implications: 

\begin{enumerate}
  \item 
    A random list of integers has a \emph{very small} probability of being sorted. 
    Hence, the antecedent of the implication will return \ensuremath{\HSCon{True}} in a very small number 
    of cases. QuickCheck will reject these test cases, since they are trivially true 
    and thus do not really assert anything about the \ensuremath{\HSVar{merge}} function. Consequently it 
    exhausts the maximum number of 1000 tests before it finds 100 test cases that pass 
    the precondition. 

  \item 
    The test cases that QuickCheck finds that satisfy the precondition are \emph{very 
    likely} to be extremely short lists, often with only 0, 1 or 2 elements. This is 
    simply a result of the fact that the probability that a random list is sorted 
    exponentially decreases with the length of the randomly generated list. 
    Consequently there is a heavy bias towards short lists, making it unlikely that we 
    test the \ensuremath{\HSVar{insert}} function on any larger inputs. 
\end{enumerate}

  The common approach to deal with this problem is to take matters in our own hands 
  and to define a generator that only generates elements that satisfy the constraints 
  we put on our test data. For sorted lists we might write the following QuickCheck 
  generator:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{gen\char95 sorted}\HSSym{::}\HSCon{Gen}\;\HSSpecial{\HSSym{[\mskip1.5mu} }\HSCon{Int}\HSSpecial{\HSSym{\mskip1.5mu]}}{}\<[E]%
\\
\>[B]{}\HSVar{gen\char95 sorted}\HSSym{\mathrel{=}}\HSVar{arbitrary}\HSSym{\bind} \HSVar{return}\ .\ \HSVar{diff}\ .\ \HSVar{map}\;\HSVar{abs}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSKeyword{where}\;{}\<[10]%
\>[10]{}\HSVar{diff}\HSSym{::}\HSSpecial{\HSSym{[\mskip1.5mu} }\HSCon{Int}\HSSpecial{\HSSym{\mskip1.5mu]}}\HSSym{\to} \HSSpecial{\HSSym{[\mskip1.5mu} }\HSCon{Int}\HSSpecial{\HSSym{\mskip1.5mu]}}{}\<[E]%
\\
\>[10]{}\HSVar{diff}\;\HSSpecial{\HSSym{[\mskip1.5mu} }\HSSpecial{\HSSym{\mskip1.5mu]}}{}\<[23]%
\>[23]{}\HSSym{\mathrel{=}}\HSSpecial{\HSSym{[\mskip1.5mu} }\HSSpecial{\HSSym{\mskip1.5mu]}}{}\<[E]%
\\
\>[10]{}\HSVar{diff}\;\HSSpecial{(}\HSVar{x}\HSCon{\mathbin{:}}\HSVar{xs}\HSSpecial{)}{}\<[23]%
\>[23]{}\HSSym{\mathrel{=}}\HSVar{x}\HSCon{\mathbin{:}}\HSVar{map}\;\HSSpecial{(}\HSSym{+}\HSVar{x}\HSSpecial{)}\;\HSSpecial{(}\HSVar{diff}\;\HSVar{xs}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  For sorted lists, defining a custom generator is a manageable task. However if we 
  require our test data to satisfy complicated constraints, defining these 
  generators can become very difficult; even synthesizing well-typed lambda 
  terms is a surprisingly tricky problem \cite{palka2011testing, grygiel2013counting, 
  claessen2015generating}.

  We present a possible solution to this problem by observing that the desired 
  constraints on test data can often be expressed as an \emph{indexed family} that 
  ranges over the type of our test values. For example, we can define an indexed 
  family that is indexed with a list of numbers, which is only inhabited if its index 
  list is a sorted list.  

\includeagda{2}{sorted}

  Given a value of type \agda{Sorted xs}, it is easy to convert it to a value of type \agda{List 
  ℕ}. This means that if we are able to generate values of type \agda{Sorted xs}, we are 
  able to generate values of type \agda{List ℕ} for which we know that they are sorted, 
  even though this is no longer guaranteed by the type system of the host language. By 
  generalizing this approach and finding a way to generate values of arbitrary 
  indexed families, we are able to generate constrained test data. There is some 
  existing work in this context \cite{denes2014quickchick, magalhaes2011generic}, but
  we take a novel approach by considering various type universes that provide a 
  generic description of a set of (indexed) datatypes, and deriving generators from 
  the codes in these universes

\section{Research question and goals}

  The main research question that this thesis attempts to answer is the following: 
  \begin{center}
  \emph{
    How can we derive generators for arbitrary indexed families?
  } \end{center}
  By obtaining a way to generically generate values of indexed families, we hope to be 
  able to generate constrained test data without having to define custom generation 
  procedures. The goal is to find a generic solution which covers many different 
  indexed families, to provide a formalization of this solution in Agda, and to 
  implement our solution in Haskell to demonstrate the feasibility of our approach. We 
  aim to devise a framework that is highly flexible and allows us to describe many 
  different kinds of constrained data. 

\section{Contributions}

  This thesis makes the following contributions: 

  \begin{itemize}
    \item 
      A formalization in Agda of enumerative generators for \emph{regular datatypes}, 
      together with a proof that these generators satisfy a completeness property. 

    \item 
      A formalization in Agda of enumerative generators for inductive families that 
      can be described as an \emph{indexed container}. 

    \item 
      A formalization in Agda of enumerative generators for inductive families that 
      can be described as an \emph{indexed description}, together with a proof that 
      they satisfy a completeness property. 

    \item 
      A small Haskell library that implements the enumerative generator for indexed 
      description, and is able to generate constrained test data. 
  \end{itemize}

  This thesis consists of two main parts: one describing the theoretical model we have 
  developed, and one describing our implementation. The first two chapters introduce 
  the topic and provide background and prerequisites necessary for understanding our 
  work. Chapter 3, 4 and 5 describe our Agda model, each considering a different (and
  increasingly expressive) type universe. In chapter 6 we describe how the ideas 
  developed in our theoretical model can be adapted to Haskell 
  by developing a small library for the generation of constrained test data. Finally, 
  we conclude in chapter 7 with a discussion of our work and the academic context 
  surrounding it, together with some suggestions for future work. 

\section{Deliverables}

  This thesis is accompanied by the following deliverables: 

  \begin{itemize}
    \item 
      A Github repository containing the Agda model

    \item 
      A Github repository containing the Haskell library.

    \item 
      An extended abstract based on the contents of chapters 3 through 5, submitted 
      and accepted to \emph{TyDe 2019}.

    \item 
      An extended abstract based on the contents of chapter 6, submitted and accepted 
      to \emph{ICFP SRC 2019}.
  \end{itemize}

\section{Methodology}

  We use Agda \cite{norell2008dependently}, a programming language/proof assistant 
  based on Martin-L{\"o}f type theory, for the formalization of the type universes and 
  accompanying proofs that the generators we derive from them are correct. We use the 
  functional programming language Haskell \cite{jones2003haskell} to implement a 
  library based on this formalization. To enforce as much static guarantees as 
  possible we use various extensions of \emph{The Glasgow Haskell Compiler} \cite{ghc},
   most notably \emph{TypeFamilies} \cite{schrijvers2008type}, \emph{DataKinds} \cite
   {yorgey2012giving} and \emph{GADTs} \cite{hinze2003fun}. 

  \paragraph{Notational conventions} This thesis contains many snippets with both Agda 
  and Haskell code. While it will generally be clear from the context which language 
  is shown, they can be easily be distinguished by by the fonts and color schemes used 
  as well. Below is a small example in respectively \ensuremath{\HSCon{Haskell}} and \agda{Agda}:

\vspace{-0.25cm}

\begin{center}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{data}\;\HSCon{Bin}\;\HSVar{a}\HSSym{\mathrel{=}}\HSCon{Leaf}\HSSym{\mid} \HSCon{Node}\;\HSSpecial{(}\HSCon{Bin}\;\HSVar{a}\HSSpecial{)}\;\HSVar{a}\;\HSSpecial{(}\HSCon{Bin}\;\HSVar{a}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{center}
\vspace{-0.75cm}
\includeagda{1}{bin}

\vspace{-0.25cm}

  \paragraph{Universe polymorphism} All Agda snippets throughout this thesis have been 
  compiled with the \agda{\{-\# OPTIONS --type-in-type \#-\}} pragma, since this makes them 
  much more readable than their universe polymorphic counterparts. In the Agda model 
  accompanying this thesis we have avoided this option wherever possible in order to 
  keep our development consistent. 

\chapter{Background \& Prerequisites}
In this section, we will briefly discuss some of the theoretical background that is relevant for the work presented in this thesis, and explain some aspects of our Agda development that are necessary prerequisites to understanding the remainder of this thesis. To summarize, we touch upon the following subjects:

\begin{itemize}
  \item
    \emph{Type theory} and its relationship with \emph{logic} through the 
    \emph{Curry-Howard correspondence}

  \item 
    \emph{Datatype generic programming} using \emph{type universes} and the design 
    patterns associated with datatype generic programming.  

  \item 
    The type of generators used across the development, together with the completeness property we use to 
    assert their correctness. 

\end{itemize}

\section{Type theory}

  \emph{Type theory} is the mathematical foundation that underlies the \emph{type 
  systems} of many modern programming languages. In type theory, we reason about \emph\
  {terms} and their \emph{types}. The \emph{Curry-Howard equivalence} establishes an isomorphism between \emph
  {propositions and types} and \emph{proofs and terms} \cite{wadler2015propositions}. 
  This means that for any type there is a corresponding proposition, and any term 
  inhabiting this type corresponds to a proof of the associated proposition. Types and 
  propositions are generally connected using the mapping shown in table \ref{tbl:chiso}.

\begin{table}[h]
\begin{center}\begin{framed}
\begin{tabular}{ll}
\multicolumn{1}{c}{\textbf{Logic}} & \textbf{Type Theory} \\ \hline \hline
False                                        & $\bot$               \\
True                                         & $\top$               \\
$P \vee Q$                                   & $P + Q$              \\
$P \wedge Q$                                 & $P * Q$              \\
$p \Rightarrow Q$                            & $P \rightarrow Q$    \\
$\exists\ x\ .\ P\ x$                        & $\Sigma_{(x : A)} P(x)$ \\
$\forall\ x\ .\ P\ x$                        & $\Pi_{(x : A)} P(x)$                   
\end{tabular}
\caption{Correspondence between constructive logic and type theory}
\label{tbl:chiso}
\end{framed}\end{center}
\end{table}

  In general, we may prove any proposition by writing a program that inhabits its 
  corresponding type. Allmost all constructs are readily translatable 
  from proposition logic, except boolean negation, for which there is no corresponding 
  construction in type theory. Instead, we model negation using functions to the empty 
  type $\bot$. That is, we can prove a property $P$ to be false by writing a function \
  $P \rightarrow \bot$. This essentially says that if $P$ is true, then we can derive a \
  contradiction, thus it must be false. Some properties are 
  provable in predicate logic, but not in type theory. The most notable example of this 
  is the \emph{law of excluded middle}, stating that every property must be either true 
  or false. 

\section{Agda}

  Agda is a programming language and proof assistant based on Intuitionistic type theory \cite
  {norell2008dependently}. Its syntax is broadly similar to Haskell's, though Agda's 
  type system is arguably more expressive, since types may depend on term level 
  values. Agda uses the Curry-Howard correspondence to model propositions as types 
  and proofs as programs. 

\section{Generic programming and type universes}

  In \emph{Datatype generic programming}, we define functionality for an entire class of types 
  at once by induction over their structure. This means that generic 
  functions will not take \emph{values} of a particular type as input, but rather a \emph{code} that 
  describes the structure of a type. 

\subsection{Design pattern}\label{sec:tudesignpattern}

  Datatype generic programming often follows a common design pattern that is 
  independent of the structural representation of types involved. In general 
  we follow the following steps: 

  \begin{enumerate}
    \item
      First, we define a datatype \agda{𝓤} representing the structure of types, 
      often referred to as the \emph{Universe}. 
    \item 
      Next, we define a semantics of the form \agda{⟦\_⟧ : 𝓤 → K} that associates codes in \agda{𝓤} 
      with an appropriate type of kind \agda{K}. 
    \item 
      Finally, we define a fixed point operation of type \agda{(u : 𝓤) → Set}
      that calculates the fixpoint of \agda{⟦ u ⟧}. 
  \end{enumerate}

  The semantics and fixpoint operation should be designed such that if a code \agda{u : 𝓤}
  represents a type \agda{T}, then the fixpoint of \agda{u} is isomorphic to \agda{T}. 

  Given these ingredients we have everything we need at hand to write generic 
  functions. Section $3$ of Ulf Norell's \emph{Dependently Typed Programming 
  in Agda} \cite{norell2008dependently} contains an in depth explanation of 
  how this can be done in Agda. In general, a datatype generic function is supplied
  with a code \agda{u : 𝓤}, and returns a function whose type is dependent on the 
  code it was supplied with. For example, we might write the following function 
  that implements decidable equality for all types in the universe \agda{𝓤}. 

\includeagdanv{2}{eqdef}

  Allowing us to obtain a decision procedure for a type by instantiating \agda{$\overset{_?}{=}$} 
  with the associated code in \agda{𝓤}. 

\subsection{Isomorphisms}

  Throughout this thesis, we will often talk about isomorphisms between types. An isomorphism between two types \agda{A} and \agda{B} asserts a one to one correspondence (or a \emph{bijection}) between their values. We use the following formal definition: 

\includeagda{2}{isomorphism}

  Isomorphisms form an equivalence relation between types, meaning that they are \emph{reflexive}, \emph{symmetric} and \emph{transitive}: 

\includeagda{2}{isoequivalence}

  We will refrain from explicitly including any isomorphism between types in this thesis, but wherever we mention that an isomorphism exists between two types we have formalized said isomorphism in our theoretical model. 
  
\section{Generators}\label{sec:generators}

  In this thesis, we use the datatype shown in listing \ref{lst:abstractgen} as an abstract representation of the concept of generators. 

\includeagdalisting{2}{abstractgen}{The abstract generator type}{lst:abstractgen}

  The abstract generator type is essentially a deep embedding of the functions exposed by the \ensuremath{\HSCon{Applicative}}, \ensuremath{\HSCon{Monad}} and \ensuremath{\HSCon{Alternative}} typeclasses, with added constructors to mark recursive positions and invoke other generators. We can map values of this abstract generator type to any desired concrete generator type. The reason for this separation between abstract and concrete generators is twofold: 

  \begin{enumerate}
    \item 
      It becomes much easier to convince Agda's termination checker that our generators are terminating, since we do not require any recursive calls or a fixpoint operation to write recursive generators, shifting this burden to the interpretation of the abstract generator type. 
    \item 
      We potentially add a bit of flexibility by delaying the point at which we have to commit to a particular generator type, which might make interfacing with existing libraries easier. 
  \end{enumerate}

  In practice, we will rarely use the constructors of the \agda{Gen} type. Rather, we use the functions exposed by the associated typeclasses. For example, we can define an abstract generator for the \agda{Fin} type as follows: 

\includeagda{2}{fingen}

\subsection{Generator interpretations}

  A consequence of this design is that we need to transform abstract generators to a concrete instantiation before we can prove properties about their behavior. We will for our proofs use an enumerative interpretation, not unlike SmallCheck's \cite{runciman2008smallcheck} \ensuremath{\HSCon{Series}} typeclass, where generators are functions from recursive depth to a list of values. The definition of this interpretation is shown in listing \ref{lst:enumerate}. 

\includeagdalisting{2}{enumerate}{Enumerative interpretation of abstract generators}{lst:enumerate}

\subsection{Generator completeness}

  We formulate the desired completeness property, which assert that that generators do not "skip" any values. We formalize this property as follows in Agda:

\includeagda{2}{completeness}

  Basically this property asserts that all possible values of the type produced by a generator will occur in the enumeration at some point. 

\subsection{Generators for non-indexed types}

  Although our generator infrastructure is primarily designed for usage with indexed types, we can adapt it to work for non-indexed types. We do this by choosing a trivial index, and generating values of type \agda{⊤ → A} instead of generating values of the non-indexed type \agda{A} directly. This allows us to write a generator for natural numbers: 

\includeagda{2}{natgen}

  We occasionally take a more liberal approach to the notation of non-indexed generators, writing \agda{Gen A A} instead of \agda{Gen A (λ \{ tt → A\}) tt} and \agda{μ} instead of \agda{μ tt}. 


\part{Theoretical Model}

\chapter{Regular Types}

  We can describe a large class of recursive algebraic data types as a \emph{regular types}. 
  In this section we describe this universe together with its 
  semantics, and demonstrate how we may define generators for regular types by 
  induction over their codes. We will then prove that these derived generators 
  satisfy our completeness property. 

\section{Universe definition}

  Though the exact definition may vary across sources, the universe of regular types 
  is generally regarded to consist of the \emph{empty type} (containing \emph{no} 
  inhabitants), the unit type (containing exactly \emph{one} inhabitant) and constants 
  types (which simply refer to another type). Regular types are closed under both \emph
  {products} (representing pairing of types) and \emph{coproducts} (representing a 
  choice between types). Listing \ref{lst:regular} shows the Agda datatype that we use 
  to represent codes in this universe, with the associated semantics of type \agda{Reg → 
  Set → Set} being shown in listing \ref{lst:regsem}.

\includeagdalisting{5}{regular}{The universe of regular types}{lst:regular}

  The semantics map a code to a functorial representation of the datatype described by 
  that code, commonly known as its \emph{pattern functor}. The datatype that is 
  represented by a code is isomorphic to the least fixpoint of its pattern functor. We 
  find this fixpoint with the following fixpoint operation:

\includeagda{5}{regularfix}

\includeagdalisting{5}{regularsemantics}{Semantics of the universe of regular types}
{lst:regsem}

  \begin{example}

    Let us consider the type of natural numbers: 

\includeagda{3}{defnat}

    \agda{Nat} exposes two constructors: the nullary constructor \agda{zero}, and the unary 
    constructor \agda{suc} that takes one recursive argument. We can view this type then 
    as a coproduct (or choice) between a unit type, representing \agda{zero}, and a 
    recursive position, representing the recursive argument of the \agda{suc} constructor. 

\includeagdanv{5}{natregular}

    We convince ourselves that \agda{ℕ'} is indeed equivalent to \agda{ℕ} by defining an 
    isomorphism of type \agda{ℕ ≃ ℕ'}. 
  \end{example}

  In general, we say that a type is regular if and only if we can provide a proof that 
  it is isomorphic to the fixpoint of some code \agda{c} of type \agda{Reg}. We use a record to 
  capture this notion, which holds a code and an value that witnesses the 
  isomorphism between the fixpoint of this code and the regular type \agda{A}.

\includeagda{5}{regularrecord}

  By instantiating \agda{Regular} for a type \agda{A}, we may use any generic functionality by leveraging 
  the isomorphism stored with the record \agda{Regular A}.

\section{Deriving generators}\label{sec:genericgenreg}

  We can derive generators for all regular types at once by induction over their associated 
  codes. In \cref{sec:regularproof} we will prove that the generators we 
  derive from codes satisfy our completeness property under the enumerative interpretation we defined in 
  \cref{sec:generators}. 

\subsection{Performing induction over codes}

  In our initial approach, we might be to try to define a generator that produces values 
  of type \agda{Fix c}. Unfortunately, this will not work. By choosing \agda{Fix c} as the type of elements 
  generated, we implicitly imposes the restriction that any \agda{I} in \agda{c} refers to \agda{Fix 
  c}. This restriction is problematic in some cases, specifically when encountering a 
  product or coproduct. In that case, we destruct a code \agda{c} into two smaller codes \agda{c₁} and \agda{c₂}. Calling 
  our deriving function on these codes will yield two generators, one producing values 
  of type \agda{Fix c₁} and the other producing values of type \agda{Fix c₂}. It is then not 
  possible to combine these generators into a single generator producing values of 
  type \agda{Fix c}: the recursive positions in the subgenerators refer to different types!

  To remedy this, we make a distinction between the code we are doing induction over, \agda{
  c}, and the code which describes the type that recursive positions in \agda{c} refer to, \agda{
  c'}. Furthermore, we do not produce elements of type \agda{Fix c}, but rather of type \agda{⟦ 
  c ⟧ (Fix c')} (i.e. values of the type given by the semantics of \agda{c}, but recursive 
  positions refer to the type described by \agda{c'}). When calling our derivation function 
  with two equal codes, the values produced will be isomorphic to \agda{Fix c}! This results 
  in the following type signature of our generator deriving function: 

\includeagda{5}{genericgen2}

  This step allows us to perform induction over the first input code, 
  while still being able to have recursive positions refer to the correct \emph
  {top-level code}. The first and second type parameter (respectively describing the 
  type we are generating, and the type of recursive positions) of \agda{Gen} are
  consequently distinct, with the second type parameter being isomorphic to \agda{Fix c'}.  

\subsection{Composing generic generators}

  Now that we have the correct type for \agda{deriveGen} in place, we can begin to define it 
  We do this on a case by case basis, describing how to derive generators for each 
  of the constructors of the \agda{Reg} datatype. 

\subsubsection{The empty (Z) and unit (U) type}

  We start with the generic generators for the \agda{Z} and \agda{U} constructors. Recall
  that the generators we derive from these constructors should produce \emph{all}
  inhabitants of the type given by their semantics. 

\includeagda{5}{genericgenZU}

  In case of both \agda{Z} and \agda{U} this requirement is trivially fulfilled. For the \agda{Z} combinator, we yield a 
  generator that produces no elements, since its semantics is the empty type (\agda{⊥}). As 
  for the \agda{U} combinator, \agda{⟦ U ⟧ (Fix c')} equals the unit type (\agda{⊤}), so we need to 
  return a generator that produces all inhabitants of \agda{⊤}, which is only the value \agda{tt}. 
  We get a generator that does this by lifting \agda{tt} into the generator type. 

\subsubsection{Recursive positions (I)}

  We mark a recursive position in a generator with the $\mu$ constructor. However, 
  given the previously defined type signature for \agda{deriveGen}, $\mu$ is a generator 
  that produces elements of type \agda{⟦ c' ⟧ (Fix c')}. We require that the generator 
  derived from the \agda{I} constructor produces elements of type \agda{⟦ I ⟧ (Fix c')}, which 
  by definition of \agda{⟦\_⟧} equals \agda{Fix c'}. This means that we need to apply the 
  fixpoint wrapper \agda{In} over the elements produced by $\mu$:

\includeagda{5}{genericgenI}

\subsubsection{Products (\agda{⊗}) and coproducts (\agda{⊕})}

  For products and coproducts, we can quite easily define their generators by 
  recursing on the left and right subcodes now that we have the correct type for \agda{
  deriveGen} in place. We then only need to combine these generators in an appropriate 
  way. We do this respectively building a product type out of the elements produced by 
  the subgenerators and by marking a choice between the generators derived from the 
  subcodes. 

\includeagda{5}{genericgenPCOP}

  Of course, the exact way in which the elements of subgenerators are combined still 
  depends on how we interpret the abstract generator type; here we only describe these 
  operations in terms of the functions exposed by \ensuremath{\HSCon{Applicative}} and \ensuremath{\HSCon{Alternative}}.

\subsubsection{Wrapping up}

  We have defined a function that derives generators from codes in the 
  universe of regular types (barring constant types, with with we will deal in \cref
  {sec:constanttypes}). We need to take one final step before we can use \agda{deriveGen} for 
  all regular types. Any vallue \agda{Regular A} holds an isomorphism \agda{A ≃ Fix c}, so we need 
  to wrap the resulting generator in the \agda{In} constructor, which we can only do if \agda{
  deriveGen} is called \emph{with two equal codes}. We use the following function to 
  perform this initial call to \agda{deriveGen}, and to wrap the values produced by the 
  resulting generator in the fixpoint operation: 

\includeagda{5}{genericgenFinal}

  The elements produced by \agda{genericGen} can now readily be transformed into the 
  required datatype through an appropriate isomorphism. 

  \begin{example}

    We derive a generator for natural numbers by invoking \agda{genericGen} on the 
    appropriate code \agda{U ⊕ I}, and applying an isomorphism of type \agda{ℕ ≃ ℕ'} to 
    the resulting generator:

\includeagdanv{5}{genericgenNat}

  \end{example}

  We use the following function to define a generator for any type \agda{A} for which there 
  is an instance argument \agda{Regular A} in scope:

\includeagda{5}{isogen}

\section{Constant types}\label{sec:constanttypes}

  Constant types present a bit of a challenge, since the code \agda{K s} can carry any type in \agda{Set}. 
  This means that we know nothing about the type \agda{s} whatsoever. Since we have no general 
  procedure for deriving generators for arbitrary types in \agda{Set}, we need to either 
  restrict \agda{s} to a set of types for which we \emph{can} derive generators (e.g. regular types), or have the user 
  supply generators for all constant types in a code. We choose the latter approach in order to retain the flexibility 
  that comes with the ability to refer to arbitrary types.

\subsection{Metadata structure}

  We have the programmer supply the necessary generators by defining a \emph{metadata} 
  structure, indexed by a code, that carries additional information for every \agda{K} 
  constructor used. We parameterize \agda{deriveGen} with a metadata structure that is
  indexed by the code we are inducting over, carrying generators for every 
  constant type used in said code. The definition of this metadata structure is shown 
  in listing \ref{lst:mdstructure}. 

\includeagdalisting{5}{mdstructure}{Metadata structure carrying additional information 
for constant types}{lst:mdstructure}

  We purposefully keep the type of information stored for constant types abstract, as 
  we will need to record information beyond generators when proving completeness for 
  the generators produced by \agda{deriveGen}. 

\subsection{Deriving a generator for constant types}

  Given the definition of the metadata structure, we augment \agda{deriveGen} with an extra 
  parameter that stores generators for every constant type in a code: 

\includeagda{5}{derivegenKTy} 

  We then define \agda{deriveGen} as follows for constant types:

\includeagda{5}{derivegenKCase}

  All cases for existing constructors remain the same, except for the fact that the metadata parameter 
  distributes over recursive calls in the case of products and coproducts. 
  
  With this, we have completed the definition of \agda{deriveGen}. 

\section{Proving completeness}\label{sec:regularproof}

  We set out to prove that the derived generators satisfy our completeness property.
  Obviously, this relies on the generators supplied by the programmer being complete 
  as well. 

  We start the proof by instantiating the completeness property formulated in listing \ref
  {lst:abstractgen} with \agda{deriveGen} to obtain the definition of the theorem that 
  we will prove:

\includeagda{5}{derivegencomplete}

  We explicitly distinguish the codes \agda{c} and \agda{c'} to (again) be able to construct the 
  proof by performing induction over the input code \agda{c}. The reasoning behind this is very 
  much the same as the reasoning behind the definition of \agda{deriveGen} itself. If we 
  invoke this lemma with two equal codes, we may utilize the fact that \agda{In} is 
  bijective to obtain a proof that \agda{genericGen} is complete too. The key observation 
  here is that mapping a bijective function over a complete generator results in 
  another complete generator. We do not show this proof here explicitly, but we have constructed
  a proof of the following statement in the Agda development:

\includeagda{5}{genericgencomplete}

  Which we need to generalize the proof to all types which are isomorphic to some code \agda{c : Reg}. 

\subsection{Proof structure}

  The completeness proof roughly follows the following steps: 

  \begin{itemize}

    \item 
      First, we prove completeness for the individual constructors of the \agda{Reg} type. 

    \item 
      Next, we assemble a suitable metadata structure to carry the required proofs 
      for constant types in this code. 

    \item 
      Finally, we generalize the proof over our generic generator to a proof that 
      ranges over all types \agda{A} that are isomorphic to the fixpoint of some code
      \agda{c : Reg}. 

  \end{itemize}

\subsection{Combinator correctness}

  We start our proof by asserting that the generators derived from the individual constructors 
  of the \agda{Reg} datatype are complete. That is, we show that for every constructor of \agda{Reg} the derived generator 
  produces all values of the type given by the semantics of that constructor. 
  
\subsubsection{Empty (Z) and unit (U) types}

  In the case of \agda{Z} and \agda{U}, completing the completeness proof is relatively easy:

\includeagda{5}{derivegencompleteZU}

  The semantics of \agda{Z} is the empty type, so any generator producing values of type \agda{⊥}
   is trivially complete: we simply close this branch with an absurd pattern. In the 
   case of \agda{U} we simply need to show that interpreting \agda{pure tt} returns a list 
   containing \agda{tt}, which we can do by returning a trivial proof that \agda{tt} is an 
   element of the singleton list \agda{[ tt ]}. 

\subsubsection{Recursive positions (I)}

  The proof that a recursive position $\mu$ is interpreted to a complete enumeration 
  is simply the induction hypothesis, which states that \agda{deriveGen c' c'} is complete. A subtlety 
  here is that we \emph{must} pattern match on \agda{In x}, otherwise Agda's termination 
  checker will flag the recursive call. 

\includeagda{5}{derivegencompleteI}

  We can complete this definition by proving a lemma that asserts that mapping \agda{In} 
  over a generator preserves completeness: 

\includeagda{5}{derivegencompleteIlemma}

\subsubsection{Products and coproducts}

  Things become a bit more interesting once we move to products and coproducts, since 
  this requires us to prove that the way in which we combine subgenerators satisfies completeness 
  under our enumerative interpretation. In both cases, this proof follows a similar 
  structure: 

  \begin{enumerate}
    \item 
      Obtain completeness proofs for the subgenerators with recursive calls to \agda{
      deriveGen-Complete}
    \item 
      Construct a lemma that asserts that the enumerative interpretation of generators 
      preserves completeness
    \item 
      Invoke this lemma to complete the definition
  \end{enumerate}
  
  \paragraph{Coproducts} To find out what lemma we need to prove completeness for the 
  generators derived from coproducts, we observe the following equality by unfolding 
  the defintions of \agda{enumerate} and \agda{deriveGen}: 

\includeagda{5}{tolistcopeq}

  The generators on the right hand side of the equation are virtually the same as the 
  recursive calls we make, modulo the \agda{inj₁} and \agda{inj₂} constructors we map over them to unify 
  their result types. We can obtain a proof of completeness for the right hand side of this equality 
  by proving the following two lemmas about the \agda{merge} function we use to combine the 
  results of the subgenerators of a coproduct. 

\includeagda{5}{mergecomplete}

  Proofs for these lemmas can readily be extended to a proof that if the left and 
  right subgenerator are complete under the enumerative interpretation, then the 
  interpretation of their coproduct (which is a call to \agda{merge}), is also complete, 
  simply by pairing them with the depth value returned by the recursive call. 
  
  \paragraph{Products} Similarly, by unfolding \agda{enumerate} one step in the 
  case of products, we get the following equality:

\includeagda{5}{enumeratepeq}

  We can prove completeness for the right hand side of this equality by proving the following lemma 
  about the applicative instance of lists:

\includeagda{5}{apcomplete}

  We can again extend this lemma to a proof that the enumerative interpretation of 
  product types is completeness preserving. In \cref{sec:monotonicity} we describe in 
  more detail how an appropriate depth value can be obtained. 

\subsection{Completeness for constant types}

  Since our completeness proof relies on completeness of the supplied generators for constant 
  types, we need the programmer to supply a completness proof for the generators 
  stored in the provided metadata structure. To this end, we 
  parameterize the completeness proof over a metadata structure that carries 
  both generators for all constant types in a code, and a proof that these generators are 
  complete. We express the relation between generator and proof with a dependent 
  pair, using the following type synonym to describe the type of this metadata parameter:

\includeagda{5}{proofinfotype}

  In order to be able to use the completeness proof from the metadata structure in the 
  \agda{K} branch of \agda{deriveGen-Complete}, we need to be able to express the relationship 
  between the metadata structure used in the proof, and the metadata structure used by 
  \agda{deriveGen}. To do this, we need a way to transform the \emph{type} of information that is 
  carried by a metadata structure. This will allow us to map a metadata structure 
  containing generators and proofs to a metadata structure containing only generators. 

\includeagda{5}{kinfomap}

  We only present the case for constant types; in all other cases we simply distribute the mapping 
  operation over all recursive positions. Given a definition of \agda{KInfo-map}, we can take the first projection of the 
  metadata input to \agda{deriveGen-Complete}, and use the resulting metadata structure as input 
  to \agda{deriveGen}. We define a type synonym to describe this mapping operation:

\includeagda{5}{mdtransform}

  Which results in the following final type of \agda{deriveGen-Complete}. 

\includeagda{5}{derivegenwithmd}

  By expressing the relation between the metadata structure supplied to the proof 
  and the metadata structure supplied to \agda{deriveGen} explicitly in the proof's type 
  signature, Agda is able to infer that the completeness proofs range over the 
  generators that were supplied to \agda{deriveGen}. This allows us to complete the 
  proof for constant types simply by returning the proof that is stored in the 
  metadata structure. 
  
\subsection{Generator monotonicity}\label{sec:monotonicity}

  There is one crucial detail we ignored when describing how to prove completeness for 
  generators derived from product types. Since existential quantification is modelled 
  in type theory as a dependent pair, we have to explicitly supply the depth at which 
  an element occurs in an enumeration when proving completeness. A problem, however arises 
  when choosing a depth value for generators derived from 
  product types. We combine values of both subgenerators in a pair, so at what depth 
  does this pair occur in the enumeration of the combined generator? Generally, we say 
  that the recursive depth of a pair is the maximum of the depth of its components. 
  Suppose the first component occurs at depth $n$, and the second at depth $m$. The 
  depth of the pair is then \agda{max n m}. However, the second components  of the returned 
  completeness proofs respectively have the type \agda{x ∈ enumerate ... n} and \agda{x ∈ 
  enumerate ... m}. In order to unify their types, we need a lemma that transforms a 
  proof that some value \agda{x} occurs in the enumeration at depth \agda{k} into a proof that \agda{
  x} occurs in the enumeration at 
  depth \agda{k'}, given that $k \leq k'$. In other words, the set of values that occurs in 
  an enumeration monotonously increases with the enumeration depth. We thus require a 
  proof of the following lemma in order to finish the completeness proof: 

\includeagda{5}{derivegenmonotone}

  We do not show the definition of this proof here, but it can be completed using the 
  exact same proof structure we used for the completeness proof. 

\subsection{Extending completeness to all regular types}

  By bringing all these elements together, we can prove that \agda{deriveGen} is complete 
  for any code \agda{c}, given that the programmer is able to provide a suitable 
  metadatastructure. We can transform this proof into a proof that \agda{isoGen} returns a 
  complete generator by observing that any isomorphism \agda{A ≃ B} establishes a bijection 
  between the types \agda{A} and \agda{B}. Hence, if we apply such an isomorphism to the 
  elements produced by a generator, completeness is preserved. 

  We have the required isomorphism readily at our disposal in \agda{isoGen}, since it is 
  contained in the instance argument \agda{Regular a}. This allows us to have \agda{isoGen} 
  return a completeness proof for the generator it derives: 

\includeagda{5}{isogenproven}

  With which we have shown that if a type is regular, we can derive a complete 
  generator producing elements of that type. 

\section*{Conclusion}

  In this chapter, we have shown how generators can be derived from codes in the 
  universe of regular types. While this is not necessarily a new result (e.g. 
  SmallCheck does this as well), we have also proven that these generators are 
  complete under an enumerative interpretation, meaning that they are guaranteed to 
  produce every inhabitant of the type they range over at some point. 

  Futhermore, the work done to establish this generic generator and the accompanying 
  proof provides a solid basis for extending this result to generic generators for 
  more expressive type universes. As we will see in the upcoming chapters, the 
  approach described in this chapter is to a large extent applicable to other type 
  universes as well. 

  Although we can describe many familiar datatypes with a code in the universe of 
  regular types, there are some limitations. Most notably, we cannot describe any 
  family of mutually recursive types. The way the universe is set up includes the 
  implicit assumption that all occurrences of \agda{I} reference the same type. If we 
  attempt to describe a datatype that is a composite of more than one recursive 
  algebraic datatype, such as for example the type of \emph{rose trees}: 

\includeagda{5}{defrose}

  The other obvious shortcoming is that this universe only allows us to describe 
  non-indexed datatypes. In the following chapters we will consider two type 
  universes that \emph{can} do this. 

\chapter{Indexed Containers}
  This chapter discusses the universe of \emph{indexed containers} \cite
  {altenkirch2015indexed}, which provide a generic framework to describe indexed datatypes 
  that can be defined by induction on their index type. Examples of datatypes we can 
  describe using this universe include finite sets (\agda{Fin}) and vectors (\agda{Vec}). 
  In this chapter, we give the definition of this universe together with its semantics and a few examples,
   and show how a generic generator may be derived for indexed containers. 

  Unfortunately, we were not able to construct a completeness proof for the generators 
  derived from this universe, hence we will give a short outline of why we were unable 
  to do so using the approach we used for regular types. 

\section{Universe definition}

  We choose to follow the representation used by Dagand in \emph{The Essence Of 
  Ornaments} \cite{dagand2017essence}, which provides an good introduction to indexed 
  containers, alongside various examples. Just as in the previous chapter, we follow 
  the pattern of first defining a datatype describing codes in the universe before 
  giving the semantics and fixpoint operation. 

\subsection{Defintion and semantics}

  To give the reader some context, we will first introduce \emph{W-types}, which are 
  an alternative to regular types for describing non-indexed datatypes. Indexed 
  containers describe indexed types using an approach that is very similar to how 
  W-types describe non-indexed types. We show how these universes relate, and how we 
  may view indexed containers as an extension to W-types. 

\subsubsection{W-types} 
  
  Introduced by Per Martin-Löf \cite{martin1984intuitionistic}, \emph{W-types} 
  abstract over tree-shaped data structures, such as natural numbers or binary trees. 
  W-types are defined by their \emph{shape} and \emph{position}, describing 
  respectively the set of constructors and the number of recursive positions. 

  Perhaps the best known definition of W-types is using an inductive datatype, with 
  one constructor taking a shape value, and a function from position to W-type: 

\includeagda{3}{winductive}

  However, we can use an alternate definition where we separate the universe into 
  codes, semantics and a fixpoint operation (listing \ref{lst:wtypes})

\includeagdalisting{3}{wtypes}{W-types defined with separate codes and semantics}
{lst:wtypes}

  We take this extra step for two reasons: 

  \begin{enumerate}
    \item To unify the definition of W-types with the design pattern for type 
    universes we described in \cref{sec:tudesignpattern}. 

    \item To make the similarities between W-types and indexed containers more 
    apparent.  
  \end{enumerate}

  \begin{example} 

    Let us again consider natural numbers as an example. We 
    can define the following W-type that is isomorphic to \agda{ℕ}:

\includeagdanv{3}{wnat}

    The \agda{ℕ} type has two constructors, hence our shape is a finite type with two 
    inhabitants (\agda{Bool} in this case). We then map \agda{false} to the empty type, 
    signifying that \agda{zero} has no recursive subtrees, and \agda{true} to the unit type, 
    denoting that \agda{suc} has one recursive subtree. 

  \end{example}

\subsubsection{Indexed containers}

  \emph{Indexed containers} extend the notion of a W-type by parameterizing the shape 
  and position over the index type, and including a typing discipline that describes 
  the indices of recursive subtrees. Types are described using \emph{Signatures}, 
  which are a triple of \emph{operations}, \emph{arities} and a \emph{typing 
  discipline}. Their definition is shown in listing \ref{lst:signatures}. 

\includeagdalisting{6}{signature}{Signatures}{lst:signatures}

  The operations of a signature correspond to a W-type's \emph{shape}, and its arity 
  corresponds a W-type's \emph{position}. The semantics of a signature is, just as for 
  a W-type, a dependent pair, with the first element being a choice of operation, and 
  the second element a function mapping arities to an appropriate recursive type. 
  Contrary to the semantics of W-types, which map a code to a value in \agda{Set → Set}, 
  the semantics of a signature are parameterized over the index type, meaning they map 
  a signature to a value in \agda{(I → Set) → (I → Set)}. The semantics are shown in 
  listing \ref{lst:sigmtheory}. 

\includeagdalisting{6}{sigmtheory}{The semantics of indexed containers}{lst:sigmtheory}

  Consequently, the fixpoint operation needs to be lifted from \agda{Set} to \agda{I → Set} as 
  well. The required adaptation follows naturally from the definition of the 
  semantics: 

\includeagda{6}{sigfix}

  It is worth noting that, since \agda{Set ≅ ⊤ → Set}, we can describe non-indexed 
  datatypes as an indexed container by choosing \agda{⊤} as the index type. More precisely, 
  there exists a bijection between \agda{WType} and \agda{Sig ⊤}, such that for every \agda{W : WType}
   and \agda{S : Sig ⊤}, \agda{Fix W} and \agda{Fix S tt} are isomorphic. 

\subsubsection{Proving isomorphisms}

  One thing to keep in mind when defining signatures for types is that part of their 
  semantics is a dependent function type. This means that proving an isomorphism 
  between a signature and the type it represents requires some extra work. More 
  specifically, we need to postulate a variation on \emph{extensional equality} for 
  function types that establishes equality between two dependent functions:  

\includeagda{6}{funext} 

  We need this postulate to define isomorphisms both for W-types as well as indexed 
  containers. 
  
\subsection{Examples}

  We consider a few example datatypes represented as indexed containers, in order to 
  get a feel for how we can represent types in this universe. 

\subsubsection{Natural numbers}

    We start by defining a suitable set of operations. The \agda{ℕ} datatype has two 
    constructor, so we return a type with two inhabitants. We use \agda{⊤} as the index of 
    the signature, since \agda{ℕ} is a non-indexed datatype.

\includeagda{6}{natop}

    Next, we map each of those operations to the right arity. The \agda{zero} constructor 
    has no recursive branches, so its arity is the empty type (\agda{⊥}), while the \agda{suc} 
    constructor has a single recursive argument, so its arity is the unit type (\agda{⊤}). 

\includeagda{6}{natar}

    Since the index type has only one inhabitant, the associated typing discipline 
    just returns \agda{tt} in all cases. We bring all these elements together into a single 
    signature, for which we can show that its fixpoint is isomorphic to \agda{ℕ}.

\includeagda{6}{natsig}

  The signature for natural numbers is quite similar to how we would represent them as 
  a W-type. 

\subsubsection{Finite sets}

    We consider the type of finite sets, \agda{Fin}. Contrary to natural numbers, the set 
    of available operations varies with different indices. That is, \agda{Fin 0} is 
    uninhabited, so the set of operations associated with index \agda{0} is empty. A value 
    of type \agda{Fin (suc n)} can be constructed using both \agda{suc} and \agda{zero}, hence the 
    set of associated operations has two elements: 

\includeagda{6}{finop}

    The arity of the \agda{Fin} type is exactly the same as the arity of \agda{ℕ}, with the 
    exception of an absurd pattern in the case of index \agda{zero}. 

\includeagda{6}{finar}

    Recall the type of the \agda{suc} constructor: \agda{Fin n → Fin (suc n)}. The index of the 
    recursive argument is one less than the index of the constructed value. The typing 
    discipline describes this relation between index of the constructed value, and 
    indices of recursive arguments. In the case of \agda{Fin}, this means that we map \agda{suc 
    n} to \agda{n}, if the index is greater than \agda{0}, and the operation corresponding to 
    the \agda{suc} constructor is selected. 

\includeagda{6}{finty}

    Again, we combine operations, arity and typing into a signature: 

\includeagda{6}{finsig}

\subsubsection{Vectors}

  One aspect we have not yet addressed is how to represent types that refer to other types, such 
  as \agda{Vec a}. Indexed containers do not have an explicit 
  way to reference other types, such as regular types. Rather they
  include this kind of information as part of a type's operations. We consider the \agda{
  Vec} type as an example, defining the following operations: 

\includeagda{6}{vecop}

    Notice that we map \agda{suc n} to \agda{A}, indicating that the \agda{∷} constructor requires an 
    argument of type \agda{A}. The remainder of the signature is then quite 
    straightforward: 

\includeagda{6}{vecsig}

    In fact, the arity and typing of \agda{Vec} are almost the same as those of \agda{Fin}. 

\section{Deriving generators}

  In order to be able to derive generators from signatures, there are two additional 
  steps we need to take: restricting the set of possible operations and arities, and 
  defining \emph{co-generators} for regular types. 

\subsection{Restricting operations and arities}
  
  The set of operations of a signature, \agda{Op}, is a value in \agda{Set}. This means that we 
  again run into the problem that we have no way to generate values of type \agda{Op i} 
  without any further input of the programmer. The same problem occurs with arities. 
  We solve this problem by restricting operations and arities to regular types. By 
  doing this, we can reuse the generators we defined for regular types to generate 
  operations and arities. This leads to the slightly altered variation on indexed 
  containers shown in listing \ref{lst:sigreg}, where \agda{FixR} and \agda{InR} denote the 
  fixpoint operation for regular types. This implies that the definition of signatures 
  changes slightly as well. 

\includeagdalisting{6}{sigreg}{Indexed containers with restricted operations and 
arities}{lst:sigreg}

  \begin{example}

    We use the following operation, arity and typing to describe the \agda{Fin} type as a 
    restricted signature:

\includeagdanv{6}{sigfinreg}

    This definition does not differ too much from the previous one, except that we now 
    pattern match on the fixpoint of some code in \agda{Reg} instead of directly on an 
    operation or arity. 

  \end{example}

\subsection{Generating function types}

  To derive a generator from a signature, we need, in addition to generic generators 
  for regular types, a way to generate function types whose input argument is a 
  regular type. That is, we need to define the following function: 

\includeagda{6}{cogenerate}

  We draw inspiration from SmallCheck's \cite{runciman2008smallcheck} \ensuremath{\HSCon{CoSeries}}
  typeclass, for which instances can be automatically derived. Co-generators for 
  constant types are to be supplied by a programmer using a metadata structure; we 
  choose to not make this explicit in the type signature. An example definition of \agda{
  cogenerate} is included in listing \ref{lst:cogen}.

\includeagdalisting{6}{cogen}{Definition of \agda{cogenerate}}{lst:cogen}

  Since the semantics of an indexed container contain a \emph{dependent} function type 
  we need to extend \agda{cogenerate} to work for dependent function types as well. 

\includeagda{6}{picogen}

  The type signature of \agda{Π-cogenerate} may look a bit daunting, but it essentially 
  follows the exact same structure as \agda{cogenerate}. The only real difference is that 
  the the result type of the generated functions may depend on the code we are 
  inducting over, and that we do not take a generator as input, but rather a function 
  from index to generator. The definitions of \agda{Π-cogenerate} and \agda{cogenerate} are 
  virtually the same, but in order to prevent Agda from getting stuck while solving metavariables 
  describing the indices of return types, we need to make the dependency between argument and result 
  type explicit in the generator's type. 

\subsection{Constructing generators}

  We are now ready to construct a the generic generator for indexed containers. 
  Recall that \agda{genericGen c} returns a generator for the regular type represented by \agda{
  c}. We can write a function \agda{deriveGen} that derives generators from signatures:

\includeagda{6}{gensignature}

  The final generator is quite simple, really. We use the existing functionality for 
  regular types to generate operations and arities, and return them as a dependent 
  pair, wrapping and unwrapping fixpoint operations as we go along. The dependency 
  between the first and second element of said pair is captured using by using the 
  monadic structure of the generator type.

\section*{Conclusion}\label{sec:stree}

  We have showed how we can describe a large set of indexed datatypes as \emph{indexed 
  containers}, and how we can derive a generator from the types in this universe by 
  constructing a generator for function types, and restricting operations and arities 
  to regular types which enables us to reuse the generator for regular types we 
  derived in the previous chapter. 

  Unfortunately, we have not been able to assemble a completeness proof for the 
  enumeration of \agda{deriveGen}. As was the case with the completeness 
  proof for regular types, we need to explicitly pattern match on the value for which 
  we are proving that it occurs in the enumeration in order for the termination 
  checker to recognize that the proof can be constructed in finite time. However, 
  since part of the semantics of a signature is a function type, we would need 
  to destruct a function type such that it is clear to the termination checker
  that we perform the recursive calls with a value that smaller than the original
  argument. It was unclear to us how we should proceed with the proof at this point. 

  With the derived generator for indexed containers we have obtained recipe 
  for the generation of indexed families. To motivate the need to study yet 
  another type universe in the next chapter, we consider a datatype for 
  binary trees, that are indexed by their number of nodes: 

\includeagda{6}{stree}. 
  
  When we set out to define a signature for \agda{STree}, we run into a problem: 

\includeagda{6}{streesig}

  We cannot define a typing discipline! Indexed containers assume a deterministic 
  mapping from arity to recursive index, with no dependencies between the indices 
  of different recursive subtrees. The \agda{STree} type violates both these 
  assumptions, hence we need a more expressive type universe in order to generically 
  describe it. 

\chapter{Indexed Descriptions}
To be able to represent arbitrary indexed families, we use the universe of \emph
{Indexed Descriptions}, as described by Dagand \cite{dagand2013cosmology} in his PhD 
thesis. We structure this chapter in the same way as the previous two chapters, by 
first giving the definition and semantics of the universe, before showing how a 
generator can be derived from codes in this universe and proving that these generators 
are complete under our enumerative interpretation. 

\section{Universe definition}\label{sec:idescdesc}

  We give the definition of the universe, together with its semantics and 
  fixpoint operation, before considering well-typed lambda terms as an example to 
  demonstrate how we might model a more complex datatype in this universe and to show how
  we can capture datatypes that cannot be described as a regular type or indexed 
  container. 

\subsection{definition \& Semantics}\label{sec:idescdef}

  Where indexed containers can be viewed as an extension to W-types, indexed 
  description take the universe of regular types as a basis and extend it to be able 
  to deal with more complex datatypes, adding the following elements:

\begin{enumerate}
  \item 
  A type parameter \agda{I : Set}, describing the type of indices.

  \item 
  A generalized coproduct, \agda{`σ}, that denotes choice between $n$ constructors, 
  in favor of the \agda{\_⊕\_} constructor. 

  \item 
  A combinator, \agda{`Σ}, denoting dependent pairs. 

  \item 
  Recursive positions, \agda{`var}, storing the index of recursive values. 
\end{enumerate}

  This amounts to the Agda datatype describing indexed descriptions shown in listing 
  \ref{lst:idesc}. Types are not described by a value of type \agda{IDesc I}, but rather as 
  a function from index to description, \agda{I → IDesc I}. There is no explicit constructor 
  for constant types; they can be modelled as a dependent pair consisting of the type we want to refer 
  to, and a function returning the unit type. Similarly, the universe does not contain a constructor 
  representing the empty type. We simply encode it as a coproduct of zero 
  constructors: \agda{`σ 0 λ()}.

\includeagdalisting{7}{idesc}{The Universe of indexed descriptions}{lst:idesc}

  We retain the product of two descriptions as a first order construct of the universe 
  while including a generalized notion for coproducts, which does not present a choice 
  between 2, but rather any possible number \agda{n} of operations. The \agda{Sl} datatype is used 
  to select these operations, and is isomorphic to \agda{Fin}. We will require a lot of 
  pattern matches this datatype to build descriptions, and by using \agda{Sl} over \agda{Fin} we 
  end up with slightly more succinct descriptions. The definition of \agda{Sl} is included 
  below: 

\includeagda{7}{sl}

  The semantics associated with the \agda{IDesc} universe is mostly derived from the 
  semantics of the universe of regular types, the key difference being that we do 
  not map codes to a functor \agda{Set → Set}, but rather to a function of type \agda{(I → 
  Set) → Set}. The semantics are shown in listing \ref{lst:idescsem}.

\includeagdalisting{7}{idescsem}{Semantics of the IDesc universe}{lst:idescsem}

  We calculate the fixpoint of a description's semantics using the following fixpoint 
  operation: 

\includeagda{7}{idescfix}

  \begin{example}
    We can describe the \agda{Fin} datatype as follows using a code in the universe of 
    indexed descriptions: 

\includeagdanv{7}{idescfin}

    If the index is \agda{zero}, there are no inhabitants, so we return a coproduct of zero 
    choices. Otherwise, we may choose between two constructors: \agda{zero} or \agda{suc}. 
    Notice that we describe the datatype by induction on the index type. This is not 
    required, although convenient in most cases. A different, but equally valid 
    description, exists in which we use the \agda{`Σ} constructor to explicitly 
    enforce the constraint that the index is of the form \agda{suc n}.
    
\includeagdanv{7}{idescfin2}
    
    We then have that \agda{Fix finD n} is isomorphic to \agda{Fin n}. 

  \end{example}

  Of course, we could already describe the \agda{Fin} type as an indexed container. Let us 
  reconsider the \agda{STree} type (\cref{sec:stree}), and see how it can be described 
  as an indexed description.

  \begin{example}
    When describing sized trees as an indexed description, the tricky part is to describe the 
    relation between the index of a \agda{node}, and the indices of its subtrees. To do this, 
    we use the \agda{`Σ} constructor, using it to include a valid decomposition of the index 
    \agda{suc n}, given by a value of type \agda{Σ (ℕ × ℕ) λ { ( m , k ) → m + k ≡ n }}. The 
    second element is then a description depending on such a decomposition, including two 
    recursive positions: one of size \agda{m} and one of size \agda{k}. Below is the 
    description as a whole: 

\includeagda{7}{streedesc}

  \end{example}

  We capture the notion of datatypes that can be described in the universe of indexed 
  descriptions by again constructing a record that stores a description and a proof 
  that said description is isomorphic to the type we are describing: 

\includeagda{7}{describe}

  This allows us to use Agda's instance arguments to define functionality generically over any 
  type that we can describe as an indexed description. 

\subsection{Example: well-typed lambda terms}

  To demonstrate the expressiveness of the \agda{IDesc} universe, and to show how one might 
  model a more complex datatype in it, we consider the \emph{simply typed lambda calculus} as an example. 
  We model the simply typed lambda calculus in Agda according to the representation 
  used in Philip Wadler and Wen Kokke's PLFA \cite{wadler2019plfa}. 

\subsubsection{Modelling well-typed terms in Agda}

  Wadler and Kokke use a representation using De Bruijn indices \cite{de1972lambda}, 
  which represents variables as a natural number denoting the number of lambda abstractions 
  between the variable and the binder it refers to. Using De Bruijn indices has the 
  clear advantage that any two $\alpha$-equivalent terms have the same representation. Listing 
  \ref{lst:lambdadatatypes} contains the datatype definitions for raw terms, types and 
  contexts, used to represent untyped lambda terms. Types can be either a ground 
  type \agda{`τ}, or a function type \agda{σ `→ τ}. Since we are using De Bruijn 
  indices, we do not need to store variable names in the context, only types. Hence 
  the \agda{Ctx} type is essentially a list of types. 

\includeagdalisting{7}{lambdadatatypes}{Datatypes for raw terms, types and contexts}
{lst:lambdadatatypes}

  We write $\Gamma \ni \tau$ to signify that a variable with type $\tau$ is bound in 
  context $\Gamma$. Context membership is described by the following inference rules: 

\begin{equation*}
\texttt{[Top]}
  \frac{}{\Gamma , \tau \ni \alpha : \tau} \quad 
\texttt{[Pop]}
  \frac{\Gamma \ni \tau}{\Gamma , \sigma \ni \alpha : \tau}
\end{equation*}

  We describe these inference rules in Agda using an inductive datatype, shown in 
  listing \ref{lst:ctxmem}, which is indexed with a pair of type and context. Its inhabitants 
  correspond to all proofs that a context \agda{Γ} contains a variable of type 
  \agda{τ}. 

\includeagdalisting{7}{ctxmembership}{Context membership in Agda}{lst:ctxmem}

  We write $\Gamma \vdash t : \tau$ to express a typing judgement stating that term 
  $t$ has type $\tau$ when evaluated under context $\Gamma$. The following inference 
  rules determine when a term is type correct: 


\begin{equation*}
\texttt{[Var]}
  \frac{\Gamma \ni \alpha : \tau}{\Gamma \vdash \alpha : \tau} \quad 
\texttt{[Abs]}
  \frac{\Gamma , \alpha : \sigma \vdash t : \tau}{\Gamma \vdash \lambda\ \alpha\ .\ t 
  : \sigma \rightarrow \tau} \quad
\texttt{[App]}
  \frac{\Gamma \vdash t1 : \sigma \rightarrow \tau \quad \Gamma \vdash t2 : \sigma}
  {\Gamma \vdash t_1\ t_2 : \tau}
\end{equation*} 

  We model these inference rules in Agda using a binary relation between contexts and 
  types whose inhabitants correspond to all terms that have a given type under a given 
  context (listing \ref{lst:wflambda})

\includeagdalisting{7}{typejudgement}{Well-typed lambda terms as a binary relation}
{lst:wflambda}

  Given an inhabitant of type \agda{Γ ⊢ τ}, we can write a 
  function \agda{toTerm} that transforms the typing judgement to its corresponding untyped 
  term, simply by \emph{erasing} the indices of the proof term. 

\includeagda{7}{toterm}

  The untyped term returned by \agda{toTerm} will has type \agda{τ} under context \agda{Γ}, 
  even though Agda's type system does not guarantee this anymore.  

\subsubsection{An indexed description for well-typed terms}

  In \cref{sec:idescdef}, we saw that we can describe the \agda{Fin} both by induction on 
  the index, as well as by adding explicit constraints. Similarly, we can choose to 
  define a description for well-typed terms in two ways: either by induction on the 
  type of the terms we are describing, or by including an explicit constraint that the 
  index type is a function type for the description of the abstraction rule. In either 
  case, we start by defining descriptions for each of the three possible constructors 
  (listing \ref{lst:sltcconstructordesc}). 

\includeagdalisting{7}{sltcconstructordesc}{Descriptions for the constructors of the 
simply typed lambda calculus}{lst:sltcconstructordesc}

  Given the descriptions for the individual constructors, we can assemble a 
  description for the entire datatype by pattern matchin on the index type, and 
  returning for each branch a coproduct of the descriptions of all constructors that 
  could have been used to create a value with that particular index (listing \ref
  {lst:slcdescinductive}). 

\includeagdalisting{7}{slcdescinductive}{Inductive description of the simply typed 
lambda calculus}{lst:slcdescinductive}

  Alternatively, we can describe the simply typed lambda calculus as a coproduct of 
  the descriptions of all its constructors, and adding an explicit constraint in the 
  case of the abstraction rule that requires a proof that the index type is a function 
  type (listing \ref{lst:slcdescconstrained}). 
  
\includeagdalisting{7}{slcdescconstrained}{Description of the simply typed lambda 
calculus with explicit constraints}{lst:slcdescconstrained}
  
  To convince ourselves that these descriptions do indeed describe the same type, we 
  can show that their fixpoints are isomorphic: 

\includeagda{7}{desciso}

  Given an isomorphism between the fixpoints of two descriptions, we can prove that 
  they are both isomorphic to the target type by establishing an isomorphism between 
  the fixpoint of one of them and the type we are describing. For example, we might 
  prove the following isomorphism: 

\includeagda{7}{constrainediso}

  Using the transitivity of isomorphisms, we can show that the inductive description 
  also describes well typed terms. 

  Both variations are equally valid descriptions of the simply typed lambda calculus 
  (they are isomorphic), but depending on the situation one might prefer one over the 
  other. A downside to defining descriptions by induction over the index type is that 
  we often end up with at least some code duplication, making them unnecessarily 
  verbose in some cases. Descriptions with explicit constraints do not have this downside. We could 
  even substitute \agda{varDesc}, \agda{absDesc} and \agda{appDesc} for their respective definitions, 
  since they are only referred to once. This often results in descriptions that are 
  much more succinct, but arguably less straightforward. 

  When looking ahead to the derivation of generators from descriptions, we see that 
  using a description with explicit constraints has the effect of delaying the 
  point at which we find out that a certain constructor could not have been used to 
  construct a value with a particular index. In the case of inductive descriptions, we 
  find out this fact relatively early; since the set of available operations 
  explicitly depends on the index, it will never include descriptions that 
  could not have been used to begin with. Contrary, when using a description that 
  explicitly includes constraints, we only find that a particular constructor could 
  not have been used when we fail to synthesize the required equality proof. In the 
  end this means that the choice of descriptions style comes down to a tradeof between 
  conciseness and efficiency. Throughout the remainder of this thesis, we will stick with 
  the inductive style of defining descriptions. 

\section{Deriving generators}

  The process of deriving a generator for indexed descriptions is mostly the same as 
  for regular types. There are a few subtle differences, which we will outline in this 
  section. We define a function \agda{IDesc-gen} that derives a generator from an indexed 
  description. Let us first look at its type signature: 

\includeagda{7}{idescgen}

  We take a value of type \agda{IDesc I} (the description we are inducting over) and a 
  function \agda{I → IDesc I} (describing the type for which we are deriving a generator) 
  as input. We return an \emph{indexed} generator, which produces values of the type 
  dictated by the semantics of the input description. We build this generator by 
  defining it for the various constructors of the \agda{IDesc} type. 

\subsection{Unit, product and recursive positions}
  
  The definition for \agda{`var}, \agda{`1} and \agda{`×} can be readily transferred from the 
  definition of \agda{deriveGen}. Their definition is included below: 

\includeagda{7}{idescgentrivial}
  
\subsection{Generalized coproduct}

  The generic generators for the generalized coproduct are slightly more involved, since we have to return a generator that produces dependent pairs. This is tricky, because the applicative combinators are not expressive enough to capture the dependency between the generated \emph{value} of the first element, and the \emph{type} of the second element. This means that we have to utilize the monadic structure of the generator type in order to be able to capture this dependency. 

\includeagda{7}{idescgencop}

  Here we assume that \agda{Sl-gen : (n : ℕ) → Genᵢ (Sl n) Sl n} is in scope, producing 
  values of the selector type. We capture the dependency between the generated first 
  element of the pair, and the type of the second element using the monadic bind of 
  the generator type, similar to when we were defining a generator for the universe of 
  indexed containers. The definition is pretty straightforward, although we need to 
  explicitly pass around some metavariables, which Agda would otherwise not be able 
  to solve. 

\subsection{Dependent pairs}

  We can reuse this exact same structure when defining a generator for \agda{`Σ}, 
  however since the type of its first element is chosen by the user, we need the programmer 
  to supply a suitable generator. We use the same approach using a metadata structure as we did previously to enable the programmer to pass 
  generators as input to \agda{IDesc-gen}. We define this metadata structure as 
  a datatype \agda{data IDescM {I} (P : Set → Set) : IDesc I → Set}. It is largely similar to the metadata structure used for regular types (\cref
  {sec:genericgenreg}), so we refrain from including its entire definition here. The key difference is that we now require the 
  programmer to store a piece of data depending on the type of the first element of a \agda{`Σ}:

\includeagda{7}{idescmsigma}

  The constructor of the \agda{IDescM} type associated with the generalized coproduct 
  follows the same structure as \agda{`Σ$\sim$}, but without a value argument, and with \agda{S} 
  instantiated to the selector type. 

  If we now assume that \agda{IDesc-gen} is parameterized over a metadata structure 
  containing generators for the first argument of the \agda{`Σ} constructor, we can 
  define a generator for its interpretation: 

\includeagda{7}{idescgensigma}

  Given a definition for \ensuremath{\HSVar{deriveGen}}, we can use an instance of the \agda{Describe} record to 
  define a generic generator for all types that are isomorphic to the fixpoint of some indexed 
  description. 
 
\subsection{Example: deriving a generator for well-typed lambda terms}
of
  Let us look at an example in which we use \agda{deriveGen} to derive a generator in order 
  to get a feel for how the generic mechanism defined in this section works out when 
  we actually try to use it. We will use the inductive description of well-typed terms 
  to derive a generator from. 

  Looking at the description, we see that we use the \agda{`Σ} combinator to build 
  dependent pairs that have either a proof that some \agda{τ} is an element of a context 
  \agda{Γ}, or a type as their first element. This means that we require generators 
  that produce elements of type \agda{Γ ∋ τ } and \agda{Ty}: 

\includeagda{7}{genelem}

  How we obtain these generators is entirely up to us. We can use any of the generic 
  derivation mechanisms described throughout this thesis, or manually define them 
  according to our needs. The latter has the advantage that it lets us guide the 
  generation process somewhat. In the case of lambda terms, we need to choose a new 
  type $\sigma$ when using the application rule. It might be beneficial to, for 
  example, write a generator that will first produce a list of types that can be found 
  in the context, and only later will exhaustively enumerate the space of all types. 

  Given that the required generators are in scope, we define a metadata structure 
  indexed by the inductive description of well-typed lambda terms, which shown in listing 
  \ref{lst:wtmeta}. The structure of this metadata structure is entirely dependent on 
  how we defined the description in the first place. We only really have a choice for 
  the first element of \agda{`Σ$\sim$}. 

\includeagdalisting{7}{wtmeta}{Metadata structure for the inductive description of 
well-type lambda terms}{lst:wtmeta}

  The metadata structure for well-typed terms quite neatly demonstrates how our 
  approach separates the parts of generation that can be done mechanically from the 
  parts for which a little help from the programmer is required. Furthermore, after 
  creating this separation we leave the programmer with complete freedom over how they 
  provide the necessary generator, giving them the option to either reuse any of the generic derivation mechanisms we described or to define the required generators directly. 

\section{Proving completeness}

  We aim to prove the same completeness property for generators derived from indexed 
  descriptions as we did for generators derived from regular types. Since both 
  universes and the functions that we use to derive generators from their inhabitants 
  share quite a few structural similarities, so do their respective completeness 
  proofs. This means that we can recycle a considerable portion of the completeness 
  proof that we wrote for regular types. 

  Let us first look at the exact property we aim to prove. Since we deal with indexed 
  generators, the desired completeness property changes slightly. In natural language, 
  we might say that our goal is to prove that \emph{for every index \agda{i} and value \agda{x} 
  of type \agda{P i}, there is a depth such that \agda{x} occurs in the enumeration we derive 
  from the code describing \agda{P}}. In Agda we formalize this property as follows: 

\includeagda{7}{completeness}

  Which is essentially the same property we used for regular types, adapted for usage 
  with indexed types. To be able to inductively define the completeness proof, we use 
  a slight variation on this property that distinguishes between the generator we are 
  inducting over, and the generator describing recursive positions: 

\includeagda{7}{productivity}

  In general, the second property is equivalent to the first if the two supplied 
  generators are the same. We then define the following completeness lemma for the 
  generators derived from indexed descriptions: 

\includeagda{7}{idesccompletetype}

  We will show how to define a proof for this lemma by considering the various 
  constructors of the \agda{IDesc} type. 

\subsection{Unit, product and recursive positions}

  The completeness proofs for \agda{`var}, \agda{`1} and \agda{`×} can again be transplanted almost 
  without changes from the proof for regular types:  

\includeagda{7}{idesccompletetrivial}

  Where we assume that a proofs of the following lemmas is in scope: 

\includeagda{7}{incompletetype}

  We will not go into how we can prove these lemmas, as we already discussed this when 
  describing the completeness proof for regular types. 
  
\subsection{Generalized coproducts and dependent pairs}
  
\includeagdalisting{7}{bindcomplete}{Completeness for the bind operator}
{lst:bindcomplete}

  Since the generators for \agda{`Σ} and \agda{`σ} are assembled using \emph{monadic 
  bind}, we need to prove that this operation is completeness preserving. Defining 
  what completeness in general means for \agda{>>=} is very difficult, but since both 
  usages in \agda{IDesc-gen} follow the same structure, we can get away with proving a 
  completeness property over our specific use of the bind operator. The lemma we use 
  is shown in listing \ref{lst:bindcomplete}. 

  With this lemma, and an appropriate metadata parameter supplied to our completeness 
  proof, we can fill in the cases for the generalized coproduct and dependent pairs, 
  assuming that a completeness proof for the generator producing values of the 
  selector type is in scope. 

\subsection{Wrapping up the proof}

  It is worth noting that, since the universe of indexed descriptions exposes a 
  product combinator, we require a proof of \emph{monotonicity} for generators derived 
  using \agda{IDesc-gen} as well. We will not go into how to assemble this proof here 
  (since its structure is essentially the same as the monotonicity proof for regular 
  types), but it is obviously not possible to assemble this proof without proving the 
  monotonicity property over our bind operation first. 

\section*{Conclusion}

  In this chapter, we have shown how we can extend the generic derivation mechanism we 
  used for regular types and indexed containers can be extended to a more expressive 
  universe that is able to represent arbitrary indexed families. Furthermore, we have 
  proved that the generators we derive from codes in this universe satisfy our 
  completeness property. We demonstrated that this generic approach is powerful enough 
  to generate well-typed lambda terms, relying on the programmer to supply guidance 
  for those parts of the datatype that are too difficult to handle generically. 

  Given the fact that we have developed a mechanism to find inhabitants of arbitrary 
  indexed families, we may view this result though the Curry-Howard correspondence, 
  which implies that we have simultaneously obtained a mechanism is able to synthesize 
  proofs of propositions in arbitrary formal systems. If we place our work in the 
  context of proof search, we find that we can alternatively view our work as an 
  implementation of \emph{backward-chaining proof search} \cite{miller1991uniform} 
  parameterized over a formal system and whose proofs are correct by construction, 
  enforced by Agda's type system. In this context, our completeness property implies 
  that, if we enumerate these proofs, we will eventually find \emph{all} proofs of a 
  property, given enough time and memory. Consequently, if a theorem has a proof in a 
  given formal system, we are guaranteed to find one in finite time. It is important 
  to recognize that, although our approach offers a great deal of flexibility, it is 
  not very efficient. Eventually, we exhaustively enumerate all possible proof chains 
  that could have led to our goal type, meaning that the practical applications of 
  this work are most likely limited until we further optimizations have been 
  implemented. 

%% \chapter{A Combinator Library for Generators}
%% %include src/chap04/body.lhs

\part{Implementation}

\chapter{Generators for Indexed Descriptions in Haskell}
We implement part of the ideas described in this thesis in Haskell to show their 
practical applicability. More specifically, we port the universe of indexed 
descriptions as described in \cref{sec:idescdesc} together with the accompanying 
generic generator to Haskell. We show that it is possible using this approach to 
generate constrained test data by describing constrained data as an inductive datatype,
 and generating inhabitants of that datatype. We again consider well-typed lambda 
 terms as an example. 

\section{General approach}

  The general structure of our approach is not much different from how we derived 
  generators for indexed descriptions in Agda, and consists of the following steps: 

  \begin{enumerate}
    \item 
      First we define an abstract generator type, together with a mapping to 
      enumerators (i.e. functions with type \ensuremath{\HSCon{Int}\HSSym{\to} \HSSpecial{\HSSym{[\mskip1.5mu} }\HSVar{a}\HSSpecial{\HSSym{\mskip1.5mu]}}}). 

    \item 
      Next, we define a datatype for indexed descriptions, \ensuremath{\HSCon{IDesc}}, together with its 
      semantics

    \item 
      Then we write a function that derives a generator from a value of type \ensuremath{\HSCon{IDesc}}, 
      producing elements of a type dictated by the semantics of th input description. 

    \item 
      Finally, we convert the generated values to some user defined, "raw", datatype.  
  \end{enumerate}

Dagand originally defines the universe in a dependently typed setting \cite
{dagand2013cosmology}, and similarly we make extensive use of both dependent pairs and dependent 
function types in our Agda development. Haskell's type is unfortunately not expressive enough 
to facilitate this approach. Instead, we will use a lot of \emph{singleton types} \cite
{eisenberg2013dependently} to work around this limitation. Singleton types are a 
technique to simulate a restricted for of dependent types in a non dependently typed 
language. They are intended to work together with the \emph{DataKinds} extension \cite
{ghcdocsdatakinds}. A singleton type is indexed by some promoted datatype, and has 
exactly one inhabitant for every inhabitant of the type it is indexed with.   

\section{Representing indexed descriptions in Haskell}

  We take the datatype described in \cref{sec:idescdesc} as our basis, adding an extra 
  type parameter \ensuremath{\HSVar{a}\HSSym{::}\HSSym{*}}, describing the raw (non-indexed) type we will be 
  converting to. Listing \ref{lst:idescdef} contains the definition of this type, \ensuremath{\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}}, with constructors for \emph{empty types}, \emph{unit types}, \emph{recursive 
  positions} and \emph{product types} taken almost directly from the corresponding 
  Agda type. 

\begin{listing}{Definition of \ensuremath{\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}} in Haskell}{lst:idescdef}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{data}\;\HSCon{IDesc}\;\HSSpecial{(}\HSVar{a}\HSSym{::}\HSSym{*}\HSSpecial{)}\;\HSSpecial{(}\HSVar{i}\HSSym{::}\HSSym{*}\HSSpecial{)}\;\HSKeyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{One}{}\<[10]%
\>[10]{}\HSSym{::}\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{Empty}{}\<[10]%
\>[10]{}\HSSym{::}\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{Var}{}\<[10]%
\>[10]{}\HSSym{::}\HSVar{i}\HSSym{\to} \HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSSpecial{(}\ {\color{gray}\mathbin{:\hspace{-0.3pt}\mathclap{\raisebox{0.1pt}{\scalebox{1.2}{$*$}}}\hspace{-0.3pt}:}}\ \HSSpecial{)}{}\<[10]%
\>[10]{}\HSSym{::}\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}\HSSym{\to} \HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}\HSSym{\to} \HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSSpecial{(}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}}\ \HSSpecial{)}\HSSym{::}\HSCon{Sing}\;\HSVar{n}\HSSym{\to} \HSCon{Vec}\;\HSSpecial{(}\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}\HSSpecial{)}\;\HSVar{n}\HSSym{\to} \HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Sigma \HSSym{::}\HSCon{Proxy}\;\HSVar{s}\HSSym{\to} \HSCon{IDesc}\;\HSVar{a}\;\HSSpecial{(}\HSVar{s}\HSSym{\to} \HSVar{i}\HSSpecial{)}\HSSym{\to} \HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{listing}

  We use variations of the constructors for the generalized coproduct and dependent 
  pairs, mainly because their semantics is a dependent pair, making it 
  difficult to transfer their definitions directly to Haskell. 

\subsection{Generalized coproducts}

  In the original definition, the generalized coproduct was defined by a natural number 
  \ensuremath{\HSVar{n}} and a function that takes a value from the finite set of size \ensuremath{\HSVar{n}} (Fin n) to a 
  description number \ensuremath{\HSVar{n}}. We choose to use a \emph{vector} 
  (or size indexed list) in favor of a function, since this wil make it considerably 
  easier to define the semantics for this constructor. Assuming \ensuremath{\HSCon{Nat}\HSSym{\mathrel{=}}\HSCon{Zero}\HSSym{∣}\HSCon{Suc}\;\HSCon{Nat}} 
  is in scope, we use the following GADT to describe a vector: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{data}\;\HSCon{Vec}\;\HSSpecial{(}\HSVar{a}\HSSym{::}\HSSym{*}\HSSpecial{)}\;\HSSpecial{(}\HSVar{n}\HSSym{::}\HSCon{Nat}\HSSpecial{)}\;\HSKeyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{VNil}{}\<[10]%
\>[10]{}\HSSym{::}\HSCon{Vec}\;\HSVar{a}\;\HSCon{Zero}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSSpecial{(}\HSSym{:::}\HSSpecial{)}{}\<[10]%
\>[10]{}\HSSym{::}\HSVar{a}\HSSym{\to} \HSCon{Vec}\;\HSVar{a}\;\HSVar{n}\HSSym{\to} \HSCon{Vec}\;\HSVar{a}\;\HSSpecial{(}\HSCon{Suc}\;\HSVar{n}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  We require a singleton type for natural numbers to relate the first parameter 
  of \ensuremath{\HSSpecial{(}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}}\ \HSSpecial{)}} with the length of its second parameter. 

\subsection{The \ensuremath{\HSSpecial{`}\Sigma } constructor}

  We choose to use a more restrictive form of the \ensuremath{\HSSpecial{`}\Sigma } constructor, in order to be 
  able to encode its semantics in Haskell's type system. 
  Instead of having the second argument to \ensuremath{\HSSpecial{`}\Sigma } be a function that maps values of 
  the type \ensuremath{\HSVar{s}} stored in its first argument to descriptions, we use a single 
  description with with type \ensuremath{\HSCon{IDesc}\;\HSVar{a}\;\HSSpecial{(}\HSVar{s}\HSSym{\to} \HSVar{i}\HSSpecial{)}}. This has the effect of pushing the 
  dependency inwards: any recursive postion in this description will now store a 
  function of type \ensuremath{\HSVar{s}\HSSym{\to} \HSVar{i}}, meaning that the indices of recursive positions can still 
  depend on a the chosen value of type \ensuremath{\HSVar{s}}, while the structure of the stored 
  description will be constant. Although theoretically this means that we can describe 
  fewer types, we have yet to encounter an example of a type that cannot be described 
  with this more restrictive universe definition. 
  
  The motivation behind this alteration is that it eliminates the dependency between 
  the chosen value of type \ensuremath{\HSVar{s}}, and the semantics of the dependent pair as a whole. 
  This works because (as we will see in the next section, when we make the semantics 
  precise) we use \emph{shallow recursion}, unfolding the isomorphism between \ensuremath{\HSVar{a}} and 
  the semantics of the description that describes \ensuremath{\HSVar{a}} one layer at a time. For this 
  reason, the semantics of a recursive position is the type \ensuremath{\HSVar{a}}, meaning that the 
  semantics of a description is completely independent of its index type. By pushing 
  the dependency on the chosen values of type \ensuremath{\HSVar{s}} inwards to the recursive indices 
  stored, we have made this value irrelevant to the semantics of the description as a 
  whole. 
  
  It is important to note that we can map values of type \ensuremath{\HSCon{IDesc}\;\HSVar{a}\;\HSSpecial{(}\HSVar{s}\HSSym{\to} \HSVar{i}\HSSpecial{)}} to 
  functions with type \ensuremath{\HSVar{s}\HSSym{\to} \HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}}, such that the interpretation of the resulting 
  description is equal for all possible arguments of type \ensuremath{\HSVar{s}}. We will make this 
  mapping precise when we set out to derive generators from descriptions. 

\subsection{Semantics}

  We define the semantics of the \ensuremath{\HSCon{IDesc}} universe as a type family, mapping promoted 
  values to their semantics. The interpretation of descriptions is relatively 
  straightforward, and largely the same as for regular types. The semantics are shown 
  in listing \ref{lst:idescsem}. \ensuremath{\HSCon{E}} is a type with no constructors, representing the empty type. 
  
\begin{listing}{Semantics of the \ensuremath{\HSCon{IDesc}} type}{lst:idescsem}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{57}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{type}\;\HSKeyword{family}\;\HSCon{Interpret}\;\HSSpecial{(}\HSVar{d}\HSSym{::}\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}\HSSpecial{)}\HSSym{::}\HSSym{*}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Interpret}\;\HSCon{One}{}\<[57]%
\>[57]{}\HSSym{\mathrel{=}}\HSSpecial{(}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Interpret}\;\HSCon{Empty}{}\<[57]%
\>[57]{}\HSSym{\mathrel{=}}\HSCon{E}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Interpret}\;\HSSpecial{(}\HSCon{Var}\;\HSSym{\anonymous} \HSSym{::}\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}\HSSpecial{)}{}\<[57]%
\>[57]{}\HSSym{\mathrel{=}}\HSVar{a}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Interpret}\;\HSSpecial{(}\HSVar{dl}\ {\color{gray}\mathbin{:\hspace{-0.3pt}\mathclap{\raisebox{0.1pt}{\scalebox{1.2}{$*$}}}\hspace{-0.3pt}:}}\ \HSVar{dr}\HSSpecial{)}{}\<[57]%
\>[57]{}\HSSym{\mathrel{=}}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSSpecial{(}\HSCon{Interpret}\;\HSVar{dl}\HSSpecial{,}\HSCon{Interpret}\;\HSVar{dr}\HSSpecial{)}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Interpret}\;\HSSpecial{(}\HSCon{SZero}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}}\ \HSCon{VNil}\HSSpecial{)}{}\<[57]%
\>[57]{}\HSSym{\mathrel{=}}\HSCon{E}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Interpret}\;\HSSpecial{(}\HSCon{SSuc}\;\HSCon{SZero}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}}\ \HSSpecial{(}\HSVar{x}\HSSym{:::}\HSCon{VNil}\HSSpecial{)}\HSSpecial{)}{}\<[57]%
\>[57]{}\HSSym{\mathrel{=}}\HSCon{Interpret}\;\HSVar{x}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Interpret}\;\HSSpecial{(}\HSCon{SSuc}\;\HSSpecial{(}\HSCon{SSuc}\;\HSVar{n}\HSSpecial{)}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}}\ \HSSpecial{(}\HSVar{x}\HSSym{:::}\HSVar{xs}\HSSpecial{)}\HSSpecial{)}{}\<[57]%
\>[57]{}\HSSym{\mathrel{=}}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{Either}\;{}\<[11]%
\>[11]{}\HSSpecial{(}\HSCon{Interpret}\;\HSVar{x}\HSSpecial{)}\;\HSSpecial{(}\HSCon{Interpret}\;\HSSpecial{(}\HSCon{SSuc}\;\HSVar{n}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}}\ \HSVar{xs}\HSSpecial{)}\HSSpecial{)}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Interpret}\;\HSSpecial{(}\Sigma \;\HSVar{p}\;\HSVar{fd}\HSSpecial{)}{}\<[57]%
\>[57]{}\HSSym{\mathrel{=}}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSSpecial{(}\HSCon{UnProxy}\;\HSVar{p}\HSSpecial{,}\HSCon{Interpret}\;\HSVar{fd}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{listing}

  We use the following type synonym to unbox the type that is stored in a proxy:  

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{type}\;\HSCon{UnProxy}\;\HSSpecial{(}\HSVar{p}\HSSym{::}\HSCon{Proxy}\;\HSVar{a}\HSSpecial{)}\HSSym{\mathrel{=}}\HSVar{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks



  In case of the generalized coproduct, we map a vector of descriptions to a type 
  representing a choice between the interpretation of any of the descriptions carried 
  in that vector. For example, we would map a vector \ensuremath{\HSVar{d1}\HSSym{:::}\HSVar{d2}\HSSym{:::}\HSCon{VNil}} to the type 
  \ensuremath{\HSCon{Either}\;\HSSpecial{(}\HSCon{Interpret}\;\HSVar{d1}\HSSpecial{)}} \ensuremath{\HSSpecial{(}\HSCon{Interpret}\;\HSVar{d2}\HSSpecial{)}}. We build the appropriate type by induction 
  over the length of the vector. We have two base cases, one for empty vectors and one 
  for vectors containing one element. We do so to reduce the complexity of the 
  resulting type, preventing a vector with one element, \ensuremath{\HSVar{d}\HSSym{:::}\HSCon{VNil}}, to be mapped to 
  a coproduct of its semantics and the empty type. A secondary reason is to 
  prevent derived generators from including to many unneeded empty generators. 

\section{Deriving generators}

  Before we set out to describe how we derive generators from descriptions, we first 
  briefly outline the generator type used, and describe the singleton type for 
  descriptions needed to capture the dependency between the input description and the 
  type of values produced by the returned generator. 

\subsection{The generator type}

  We take the definition of the generator type, shown in listing \ref{lst:hsgendef}, 
  straight from our Agda development. Again, we choose to not have separate generator 
  types for indexed and non-indexed generators, representing non-indexed types as 
  types indexed by the unit tuple, \ensuremath{\HSSpecial{(}\HSSpecial{)}}. 

\begin{listing}{The \ensuremath{\HSCon{Gen}} type in Haskell}{lst:hsgendef}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{43}{@{}>{\hspre}l<{\hspost}@{}}%
\column{46}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{data}\;\HSCon{Gen}\;\HSVar{i}\;\HSVar{t}\;\HSVar{a}\;\HSKeyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{None}{}\<[9]%
\>[9]{}\HSSym{::}{}\<[46]%
\>[46]{}\HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{t}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{Pure}{}\<[9]%
\>[9]{}\HSSym{::}\HSVar{a}{}\<[43]%
\>[43]{}\HSSym{\to} \HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{t}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{Or}{}\<[9]%
\>[9]{}\HSSym{::}\HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{t}\HSSym{\to} \HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{t}{}\<[43]%
\>[43]{}\HSSym{\to} \HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{t}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{Ap}{}\<[9]%
\>[9]{}\HSSym{::}\HSCon{Gen}\;\HSVar{i}\;\HSSpecial{(}\HSVar{b}\HSSym{\to} \HSVar{a}\HSSpecial{)}\;\HSVar{t}\HSSym{\to} \HSCon{Gen}\;\HSVar{i}\;\HSVar{b}\;\HSVar{t}{}\<[43]%
\>[43]{}\HSSym{\to} \HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{t}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{Bind}{}\<[9]%
\>[9]{}\HSSym{::}\HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{t}\HSSym{\to} \HSSpecial{(}\HSVar{a}\HSSym{\to} \HSCon{Gen}\;\HSVar{i}\;\HSVar{b}\;\HSVar{t}\HSSpecial{)}{}\<[43]%
\>[43]{}\HSSym{\to} \HSCon{Gen}\;\HSVar{i}\;\HSVar{b}\;\HSVar{t}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mu {}\<[9]%
\>[9]{}\HSSym{::}\HSVar{i}{}\<[43]%
\>[43]{}\HSSym{\to} \HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{a}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{Call}{}\<[9]%
\>[9]{}\HSSym{::}\HSSpecial{(}\HSVar{j}\HSSym{\to} \HSCon{Gen}\;\HSVar{j}\;\HSVar{a}\;\HSVar{a}\HSSpecial{)}\HSSym{\to} \HSVar{j}{}\<[43]%
\>[43]{}\HSSym{\to} \HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{t}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{listing}

  We make the \ensuremath{\HSCon{Gen}} type an instance of \ensuremath{\HSCon{Functor}}, \ensuremath{\HSCon{Applicative}}, \ensuremath{\HSCon{Monad}} and \ensuremath{\HSCon{Alternative}} (by relating the functions they exposed with the associated 
  constructors), allowing us to define generators using the familiar applicative 
  programming style: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{tree}\HSSym{::}\HSCon{Gen}\;\HSSpecial{(}\HSSpecial{)}\;\HSCon{Tree}\;\HSCon{Tree}{}\<[E]%
\\
\>[B]{}\HSVar{tree}{}\<[7]%
\>[7]{}\HSSym{\mathrel{=}}\HSVar{pure}\;\HSCon{Leaf}\HSSym{<∣>}\HSCon{Node}\ {\color{gray}\mathbin{<\hspace{-1.6pt}\mathclap{\raisebox{0.1pt}{\scalebox{.8}{\$}}}\hspace{-1.6pt}>}}\ \mu \;\HSSpecial{(}\HSSpecial{)}\ {\color{gray}\mathbin{<\hspace{-1.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{1.2}{$*$}}}\hspace{-1.1pt}>} }\ \mu \;\HSSpecial{(}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{A singleton type for descriptions}

  Since our goal is eventually to define a function \ensuremath{\HSVar{idesc\char95 gen}\HSSym{::}\HSCon{Sing}\;\HSVar{d}\HSSym{\to} \HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSSpecial{(}\HSCon{Interpret}\;\HSVar{d}\HSSpecial{)}}, we require an appropriate singleton type for the \ensuremath{\HSCon{IDesc}} type. We 
  again start by defining this instance for \ensuremath{\HSCon{One}}, \ensuremath{\HSCon{Empty}}, \ensuremath{\HSCon{Var}} and \ensuremath{\ {\color{gray}\mathbin{:\hspace{-0.3pt}\mathclap{\raisebox{0.1pt}{\scalebox{1.2}{$*$}}}\hspace{-0.3pt}:}}\ }, shown in 
  listing \ref{lst:singidescdef}

\begin{listing}{Singleton instance for the \ensuremath{\HSCon{IDesc}} type}{lst:singidescdef}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{41}{@{}>{\hspre}c<{\hspost}@{}}%
\column{41E}{@{}l@{}}%
\column{45}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\HSCon{SOne}{}\<[11]%
\>[11]{}\HSSym{::}{}\<[45]%
\>[45]{}\HSCon{SingIDesc}\;\HSCon{One}{}\<[E]%
\\
\>[3]{}\HSCon{SEmpty}{}\<[11]%
\>[11]{}\HSSym{::}{}\<[45]%
\>[45]{}\HSCon{SingIDesc}\;\HSCon{Empty}{}\<[E]%
\\
\>[3]{}\HSCon{SVar}{}\<[11]%
\>[11]{}\HSSym{::}\HSVar{forall}\;\HSSpecial{(}\HSVar{i'}\HSSym{::}\HSVar{i}\HSSpecial{)}\ .\ \HSVar{i}{}\<[41]%
\>[41]{}\HSSym{\to} {}\<[41E]%
\>[45]{}\HSCon{SingIDesc}\;\HSSpecial{(}\HSCon{Var}\;\HSVar{i'}\HSSpecial{)}{}\<[E]%
\\
\>[3]{}\HSSpecial{(}\ {\color{gray}\mathbin{:\hspace{-0.3pt}\mathclap{\raisebox{0.1pt}{\scalebox{1.2}{$*$}}}\hspace{-0.3pt}:}}\ \HSVar{z}\HSSpecial{)}{}\<[11]%
\>[11]{}\HSSym{::}\HSCon{SingIDesc}\;\HSVar{l}\HSSym{\to} \HSCon{SingIDesc}\;\HSVar{r}\HSSym{\to} {}\<[45]%
\>[45]{}\HSCon{SingIDesc}\;\HSSpecial{(}\HSVar{l}\ {\color{gray}\mathbin{:\hspace{-0.3pt}\mathclap{\raisebox{0.1pt}{\scalebox{1.2}{$*$}}}\hspace{-0.3pt}:}}\ \HSVar{r}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{listing}

  In order to be able to define a singleton instance for the generalized coproduct, we 
  require a singleton instance of \ensuremath{\HSCon{SNat}}. We assume this instance, denoted \ensuremath{\HSCon{SNat2}}, is 
  in scope: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSSpecial{(}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}{\scalebox{1}{\$}}}\ \HSSpecial{)}\HSSym{::}\HSCon{SNat2}\;\HSVar{n}\HSSym{\to} \HSCon{SVec}\;\HSVar{xs}\HSSym{\to} \HSCon{SingIDesc}\;\HSSpecial{(}\HSVar{n}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}}\ \HSVar{xs}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  The singleton definition for the \ensuremath{\Sigma } constructor (listing \ref{lst:singsigmadef})
  has a few subtleties. First, the type stored in its first element is required to be 
  a member of the \ensuremath{\HSCon{Promote}} typeclass. This typeclass describes types which are an 
  instance of \ensuremath{\HSCon{Singleton}}, and for which we know how to promote a value of type \ensuremath{\HSVar{a}} 
  to a value of type \ensuremath{\HSCon{Sing}\;\HSVar{a}}. The \ensuremath{\HSCon{Promote}} class has one associated function \ensuremath{\HSVar{promote}\HSSym{::}\HSVar{a}\HSSym{\to} \HSCon{Promoted}\;\HSVar{a}\;\HSCon{Sing}}, where \ensuremath{\HSCon{Promoted}} is defined as follows: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{data}\;\HSCon{Promoted}\;\HSSpecial{(}\HSVar{a}\HSSym{::}\HSSym{*}\HSSpecial{)}\;\HSSpecial{(}\HSVar{f}\HSSym{::}\HSVar{a}\HSSym{\to} \HSSym{*}\HSSpecial{)}\HSSym{\mathrel{=}}\HSVar{forall}\;\HSSpecial{(}\HSVar{x}\HSSym{::}\HSVar{a}\HSSpecial{)}\ .\ \HSCon{Promoted}\;\HSSpecial{(}\HSVar{f}\;\HSVar{x}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  Storing singleton values, but hiding the their index. 

\begin{listing}{Singleton instance for the \ensuremath{\Sigma } constructor}{lst:singsigmadef}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSCon{SSigma}{}\<[9]%
\>[9]{}\HSSym{::}\HSCon{Promote}\;\HSVar{s}\HSSym{\Rightarrow} \HSCon{SingIDesc}\;\HSVar{d}{}\<[E]%
\\
\>[9]{}\HSSym{\to} \HSCon{Gen}\;\HSSpecial{(}\HSSpecial{)}\;\HSVar{s}\;\HSVar{s}{}\<[E]%
\\
\>[9]{}\HSSym{\to} \HSSpecial{(}\HSVar{forall}\;\HSVar{s'}\ .\ \HSCon{Sing}\;\HSVar{s'}\HSSym{\to} \HSCon{Interpret}\;\HSVar{d}\ {\color{gray}\mathbin{:\hspace{-0.3pt}\mathclap{\raisebox{0.1pt}{\scalebox{1.2}{$\sim$}}}\hspace{-0.3pt}:}}\ \HSCon{Interpret}\;\HSSpecial{(}\HSCon{Expand}\;\HSVar{d}\;\HSVar{s'}\HSSpecial{)}\HSSpecial{)}{}\<[E]%
\\
\>[9]{}\HSSym{\to} \HSCon{SingIDesc}\;\HSSpecial{(}\Sigma \;\HSSpecial{(}\HSCon{Proxy}\HSSym{::}\HSCon{Proxy}\;\HSVar{s}\HSSpecial{)}\;\HSVar{d}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{listing}

  This results in the complete definition of \ensuremath{\HSCon{SingIDesc}} shown in listing \ref{lst:singidesccomplete}.

\begin{listing}{Singleton indexed description}{lst:singidesccomplete}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{data}\;\HSCon{SingIDesc}\;\HSSpecial{(}\HSVar{d}\HSSym{::}\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}\HSSpecial{)}\;\HSKeyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\HSCon{SOne}{}\<[12]%
\>[12]{}\HSSym{::}\HSCon{SingIDesc}\;\HSCon{One}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\HSCon{SEmpty}\HSSym{::}\HSCon{SingIDesc}\;\HSCon{Empty}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\HSCon{SVar}{}\<[12]%
\>[12]{}\HSSym{::}\HSVar{forall}\;\HSSpecial{(}\HSVar{i'}\HSSym{::}\HSVar{i}\HSSpecial{)}\ .\ \HSVar{i}\HSSym{\to} \HSCon{SingIDesc}\;\HSSpecial{(}\HSCon{Var}\;\HSVar{i'}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\HSSpecial{(}\ {\color{gray}\mathbin{:\hspace{-0.3pt}\mathclap{\raisebox{0.1pt}{\scalebox{1.2}{$*$}}}\hspace{-0.3pt}:}{\scalebox{1}{\$}}}\ \HSSpecial{)}\HSSym{::}\HSCon{SingIDesc}\;\HSVar{l}\HSSym{\to} \HSCon{SingIDesc}\;\HSVar{r}\HSSym{\to} \HSCon{SingIDesc}\;\HSSpecial{(}\HSVar{l}\ {\color{gray}\mathbin{:\hspace{-0.3pt}\mathclap{\raisebox{0.1pt}{\scalebox{1.2}{$*$}}}\hspace{-0.3pt}:}}\ \HSVar{r}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\HSSpecial{(}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}{\scalebox{1}{\$}}}\ \HSSpecial{)}\HSSym{::}\HSCon{SNat2}\;\HSVar{n}\HSSym{\to} \HSCon{SVec}\;\HSVar{xs}\HSSym{\to} \HSCon{SingIDesc}\;\HSSpecial{(}\HSVar{n}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}}\ \HSVar{xs}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\HSCon{SSigma}\HSSym{::}\HSCon{Promote}\;\HSVar{s}\HSSym{\Rightarrow} \HSCon{SingIDesc}\;\HSVar{d}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\HSSym{\to} \HSCon{Gen}\;\HSVar{s}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\HSSym{\to} \HSSpecial{(}\HSVar{forall}\;\HSVar{s'}\ .\ \HSCon{Sing}\;\HSVar{s'}\HSSym{\to} \HSCon{Interpret}\;\HSVar{d}\ {\color{gray}\mathbin{:\hspace{-0.3pt}\mathclap{\raisebox{0.1pt}{\scalebox{1.2}{$\sim$}}}\hspace{-0.3pt}:}}\ \HSCon{Interpret}\;\HSSpecial{(}\HSCon{Expand}\;\HSVar{d}\;\HSVar{s'}\HSSpecial{)}\HSSpecial{)}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\HSSym{\to} \HSCon{SingIDesc}\;\HSSpecial{(}\Sigma \;\HSSpecial{(}\HSCon{Proxy}\HSSym{::}\HSCon{Proxy}\;\HSVar{s}\HSSpecial{)}\;\HSVar{d}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{listing}

  The singleton instance for \ensuremath{\Sigma } also stores an explicit generator for values of 
  type \ensuremath{\HSVar{s}}. We could have used a typeclass here, but as we will see, when considering 
  some examples, that it is often more convenient to explicitly supply the generator 
  to be used. This essentially has the effect that \ensuremath{\HSCon{SingIDesc}} will simultaneously 
  function to describe the dependency between the input description, and the type of 
  values produced by the output generator, and as a metadata structure carrying 
  generators for dependent pairs. 
  
  Finally, we require a proof that the interpretation of the \emph{expansion} of the 
  second argument is equal to the interpretation of the second argument, for all 
  values of type \ensuremath{\HSVar{s}}. We require this proof in order unify the index types of the 
  generator derived for a \ensuremath{\Sigma } and the generator derived from its second argument. 
  We define the expansion operation a the type level using a mutually recursive type 
  family, shown in listing \ref{lst:exptypefam}. 

\begin{listing}{Description expansion}{lst:exptypefam}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{33}{@{}>{\hspre}l<{\hspost}@{}}%
\column{47}{@{}>{\hspre}l<{\hspost}@{}}%
\column{50}{@{}>{\hspre}c<{\hspost}@{}}%
\column{50E}{@{}l@{}}%
\column{55}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{type}\;\HSKeyword{family}\;\HSCon{VExpand}\;\HSSpecial{(}\HSVar{sn}\HSSym{::}\HSCon{SNat}\;\HSVar{n}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSSpecial{(}\HSVar{xs}\HSSym{::}\HSCon{Vec}\;\HSSpecial{(}\HSCon{IDesc}\;\HSVar{a}\;\HSSpecial{(}\HSVar{s}\HSSym{\to} \HSVar{i}\HSSpecial{)}\HSSpecial{)}\;\HSVar{n}\HSSpecial{)}\;\HSSpecial{(}\HSVar{x}\HSSym{::}\HSVar{s}\HSSpecial{)}\HSSym{::}\HSCon{Vec}\;\HSSpecial{(}\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}\HSSpecial{)}\;\HSVar{n}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{VExpand}\;\HSCon{SZero}\;{}\<[33]%
\>[33]{}\HSCon{VNil}\;\HSVar{s}{}\<[47]%
\>[47]{}\HSSym{\mathrel{=}}\HSCon{VNil}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{VExpand}\;\HSSpecial{(}\HSCon{SSuc}\;\HSVar{sn}\HSSpecial{)}\;\HSSpecial{(}\HSVar{x}\HSSym{:::}\HSVar{xs}\HSSpecial{)}\;\HSVar{s}{}\<[47]%
\>[47]{}\HSSym{\mathrel{=}}{}\<[55]%
\>[55]{}\HSCon{Expand}\;\HSVar{x}\;\HSVar{s}{}\<[E]%
\\
\>[47]{}\hsindent{3}{}\<[50]%
\>[50]{}\HSSym{:::}{}\<[50E]%
\>[55]{}\HSCon{VExpand}\;\HSVar{sn}\;\HSVar{xs}\;\HSVar{s}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{35}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{type}\;\HSKeyword{family}\;\HSCon{Expand}\;\HSSpecial{(}\HSVar{d}\HSSym{::}\HSCon{IDesc}\;\HSVar{a}\;\HSSpecial{(}\HSVar{s}\HSSym{\to} \HSVar{i}\HSSpecial{)}\HSSpecial{)}\;\HSSpecial{(}\HSVar{x}\HSSym{::}\HSVar{s}\HSSpecial{)}\HSSym{::}\HSCon{IDesc}\;\HSVar{a}\;\HSVar{iconven}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Expand}\;\HSCon{One}\;{}\<[35]%
\>[35]{}\HSVar{s}\HSSym{\mathrel{=}}\HSCon{One}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Expand}\;\HSCon{Empty}\;{}\<[35]%
\>[35]{}\HSVar{s}\HSSym{\mathrel{=}}\HSCon{Empty}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Expand}\;\HSSpecial{(}\HSCon{Var}\;\HSVar{i}\HSSpecial{)}\;{}\<[35]%
\>[35]{}\HSVar{s}\HSSym{\mathrel{=}}\HSCon{Var}\;\HSSpecial{(}\HSVar{i}\;\HSVar{s}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Expand}\;\HSSpecial{(}\HSVar{dl}\ {\color{gray}\mathbin{:\hspace{-0.3pt}\mathclap{\raisebox{0.1pt}{\scalebox{1.2}{$*$}}}\hspace{-0.3pt}:}}\ \HSVar{dr}\HSSpecial{)}\;{}\<[35]%
\>[35]{}\HSVar{s}\HSSym{\mathrel{=}}\HSSpecial{(}\HSCon{Expand}\;\HSVar{dl}\;\HSVar{s}\HSSpecial{)}\ {\color{gray}\mathbin{:\hspace{-0.3pt}\mathclap{\raisebox{0.1pt}{\scalebox{1.2}{$*$}}}\hspace{-0.3pt}:}}\ \HSSpecial{(}\HSCon{Expand}\;\HSVar{dr}\;\HSVar{s}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Expand}\;\HSSpecial{(}\HSVar{sn}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}}\ \HSVar{xs}\HSSpecial{)}\;{}\<[35]%
\>[35]{}\HSVar{s}\HSSym{\mathrel{=}}\HSVar{sn}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}}\ \HSCon{VExpand}\;\HSVar{sn}\;\HSVar{xs}\;\HSVar{s}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Expand}\;\HSSpecial{(}\Sigma \;\HSVar{p}\;\HSVar{d}\HSSpecial{)}\;{}\<[35]%
\>[35]{}\HSVar{s}\HSSym{\mathrel{=}}\Sigma \;\HSVar{p}\;\HSSpecial{(}\HSCon{Expand}\;\HSVar{d}\;\HSVar{s}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{listing}

  Similarly, we use two mutually recursive functions to describe expansion for 
  singleton descriptions (listing \ref{lst:expdef})

\begin{listing}{Description expansion for singletons}{lst:expdef}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{33}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{vexpand}\HSSym{::}\HSSpecial{(}\HSCon{Singleton}\;\HSVar{s}\HSSpecial{)}{}\<[27]%
\>[27]{}\HSSym{\Rightarrow} \HSCon{Sing}\;\HSVar{sn}\HSSym{\to} \HSCon{Sing}\;\HSVar{xs}\HSSym{\to} \HSCon{Sing}\;\HSVar{s'}{}\<[E]%
\\
\>[27]{}\HSSym{\to} \HSCon{SVec}\;\HSSpecial{(}\HSCon{VExpand}\;\HSVar{sn}\;\HSVar{xs}\;\HSVar{s'}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSVar{vexpand}\;\HSCon{SZero2}\;{}\<[20]%
\>[20]{}\HSCon{SVNil}\;{}\<[33]%
\>[33]{}\HSVar{s}\HSSym{\mathrel{=}}\HSCon{SVNil}{}\<[E]%
\\
\>[B]{}\HSVar{vexpand}\;\HSSpecial{(}\HSCon{SSuc2}\;\HSVar{sn}\HSSpecial{)}\;\HSSpecial{(}\HSVar{x}\ {\color{gray}\mathbin{:\hspace{-0.3pt}:\hspace{-0.3pt}:\hspace{-0.3pt}\hspace{-0.1pt}}{\scalebox{1}{\$}}}\ \HSVar{xs}\HSSpecial{)}\;{}\<[33]%
\>[33]{}\HSVar{s}\HSSym{\mathrel{=}}\HSVar{expand}\;\HSVar{x}\;\HSVar{s}\ {\color{gray}\mathbin{:\hspace{-0.3pt}:\hspace{-0.3pt}:\hspace{-0.3pt}\hspace{-0.1pt}}{\scalebox{1}{\$}}}\ \HSVar{vexpand}\;\HSVar{sn}\;\HSVar{xs}\;\HSVar{s}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{expand}\HSSym{::}\HSSpecial{(}\HSCon{Singleton}\;\HSVar{s}\HSSpecial{)}\HSSym{\Rightarrow} \HSCon{Sing}\;\HSVar{d}\HSSym{\to} \HSCon{Sing}\;\HSVar{s'}\HSSym{\to} \HSCon{Sing}\;\HSSpecial{(}\HSCon{Expand}\;\HSVar{d}\;\HSVar{s'}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSVar{expand}\;\HSCon{SOne}\;{}\<[22]%
\>[22]{}\HSVar{sv}\HSSym{\mathrel{=}}\HSCon{SOne}{}\<[E]%
\\
\>[B]{}\HSVar{expand}\;\HSCon{SEmpty}\;{}\<[22]%
\>[22]{}\HSVar{sv}\HSSym{\mathrel{=}}\HSCon{SEmpty}{}\<[E]%
\\
\>[B]{}\HSVar{expand}\;\HSSpecial{(}\HSCon{SVar}\;\HSVar{ix}\HSSpecial{)}\;{}\<[22]%
\>[22]{}\HSVar{sv}\HSSym{\mathrel{=}}\HSCon{SVar}\;\HSSpecial{(}\HSVar{ix}\;\HSVar{sv}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSVar{expand}\;\HSSpecial{(}\HSVar{dl}\ {\color{gray}\mathbin{:\hspace{-0.3pt}\mathclap{\raisebox{0.1pt}{\scalebox{1.2}{$*$}}}\hspace{-0.3pt}:}{\scalebox{1}{\$}}}\ \HSVar{dr}\HSSpecial{)}\;{}\<[22]%
\>[22]{}\HSVar{sv}\HSSym{\mathrel{=}}\HSVar{expand}\;\HSVar{dl}\;\HSVar{sv}\ {\color{gray}\mathbin{:\hspace{-0.3pt}\mathclap{\raisebox{0.1pt}{\scalebox{1.2}{$*$}}}\hspace{-0.3pt}:}{\scalebox{1}{\$}}}\ \HSVar{expand}\;\HSVar{dr}\;\HSVar{sv}{}\<[E]%
\\
\>[B]{}\HSVar{expand}\;\HSSpecial{(}\HSVar{sn}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}{\scalebox{1}{\$}}}\ \HSVar{xs}\HSSpecial{)}\;{}\<[22]%
\>[22]{}\HSVar{sv}\HSSym{\mathrel{=}}\HSVar{sn}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}{\scalebox{1}{\$}}}\ \HSVar{vexpand}\;\HSVar{sn}\;\HSVar{xs}\;\HSVar{sv}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{listing}

\subsection{Constructing the generator}

  We now have all necessary ingredients in place to define a function \ensuremath{\HSVar{idesc\char95 gen}} that 
  returns a generator based on its input description. It has the following type 
  signature: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{idesc\char95 gen}\HSSym{::}\HSVar{forall}\;\HSSpecial{(}\HSVar{d}\HSSym{::}\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}\HSSpecial{)}\ .\ \HSSpecial{(}\HSCon{Singleton}\;\HSVar{i}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSSym{\Rightarrow} \HSCon{SingIDesc}\;\HSVar{d}\HSSym{\to} \HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{a}\;\HSSpecial{(}\HSCon{Interpret}\;\HSVar{d}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  The definitions for the unit type, empty type, recursive positions and product type 
  follow naturally: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{idesc\char95 gen}\;\HSCon{SOne}{}\<[25]%
\>[25]{}\HSSym{\mathrel{=}}\HSVar{pure}\;\HSSpecial{(}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSVar{idesc\char95 gen}\;\HSCon{SEmpty}{}\<[25]%
\>[25]{}\HSSym{\mathrel{=}}\HSVar{empty}{}\<[E]%
\\
\>[B]{}\HSVar{idesc\char95 gen}\;\HSSpecial{(}\HSCon{SVar}\;\HSVar{v}\HSSpecial{)}{}\<[25]%
\>[25]{}\HSSym{\mathrel{=}}\mu \;\HSVar{v}{}\<[E]%
\\
\>[B]{}\HSVar{idesc\char95 gen}\;\HSSpecial{(}\HSVar{dl}\ {\color{gray}\mathbin{:\hspace{-0.3pt}\mathclap{\raisebox{0.1pt}{\scalebox{1.2}{$*$}}}\hspace{-0.3pt}:}{\scalebox{1}{\$}}}\ \HSVar{dr}\HSSpecial{)}{}\<[25]%
\>[25]{}\HSSym{\mathrel{=}}\HSSpecial{(}\HSSpecial{,}\HSSpecial{)}\ {\color{gray}\mathbin{<\hspace{-1.6pt}\mathclap{\raisebox{0.1pt}{\scalebox{.8}{\$}}}\hspace{-1.6pt}>}}\ \HSVar{idesc\char95 gen}\;\HSVar{dl}\ {\color{gray}\mathbin{<\hspace{-1.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{1.2}{$*$}}}\hspace{-1.1pt}>} }\ \HSVar{idesc\char95 gen}\;\HSVar{dr}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  We define a generator for the generalized coproduct by (again) inducting over the 
  vector length, returning a choice between the generator derived from the head of the 
  vector and the generator derived from the tail of the vector.  

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{47}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{idesc\char95 gen}\;\HSSpecial{(}\HSCon{SZero2}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}{\scalebox{1}{\$}}}\ \HSCon{SVNil}\HSSpecial{)}{}\<[47]%
\>[47]{}\HSSym{\mathrel{=}}\HSVar{empty}{}\<[E]%
\\
\>[B]{}\HSVar{idesc\char95 gen}\;\HSSpecial{(}\HSCon{SSuc2}\;\HSCon{SZero2}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}{\scalebox{1}{\$}}}\ \HSSpecial{(}\HSVar{d}\ {\color{gray}\mathbin{:\hspace{-0.3pt}:\hspace{-0.3pt}:\hspace{-0.3pt}\hspace{-0.1pt}}{\scalebox{1}{\$}}}\ \HSCon{SVNil}\HSSpecial{)}\HSSpecial{)}{}\<[47]%
\>[47]{}\HSSym{\mathrel{=}}\HSVar{idesc\char95 gen}\;\HSVar{d}{}\<[E]%
\\
\>[B]{}\HSVar{idesc\char95 gen}\;\HSSpecial{(}\HSCon{SSuc2}\;\HSSpecial{(}\HSCon{SSuc2}\;\HSVar{n}\HSSpecial{)}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}{\scalebox{1}{\$}}}\ \HSSpecial{(}\HSVar{d}\ {\color{gray}\mathbin{:\hspace{-0.3pt}:\hspace{-0.3pt}:\hspace{-0.3pt}\hspace{-0.1pt}}{\scalebox{1}{\$}}}\ \HSVar{ds}\HSSpecial{)}\HSSpecial{)}{}\<[47]%
\>[47]{}\HSSym{\mathrel{=}}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\HSCon{Left}{}\<[13]%
\>[13]{}\ {\color{gray}\mathbin{<\hspace{-1.6pt}\mathclap{\raisebox{0.1pt}{\scalebox{.8}{\$}}}\hspace{-1.6pt}>}}\ \HSVar{idesc\char95 gen}\;\HSVar{d}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSSym{<|>}\HSCon{Right}\ {\color{gray}\mathbin{<\hspace{-1.6pt}\mathclap{\raisebox{0.1pt}{\scalebox{.8}{\$}}}\hspace{-1.6pt}>}}\ \HSVar{idesc\char95 gen}\;\HSSpecial{(}\HSCon{SSuc2}\;\HSVar{n}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}{\scalebox{1}{\$}}}\ \HSVar{ds}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  If we now turn our attention to the generator derived from the \ensuremath{\Sigma } combinator, 
  it becomes clear why we need to define the expansion operator and the proof of 
  equality between the interpretation of a description and the interpretation of its 
  expansion.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{idesc\char95 gen}\;\HSSpecial{(}\HSCon{SSigma}\;\HSVar{desc}\;\HSVar{gen}\;\HSVar{eq}\HSSpecial{)}\HSSym{\mathrel{=}}\HSKeyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSVar{x}\HSSym{\leftarrow} \HSCon{Call}\;\HSSpecial{(}\HSSym{\lambda} \HSSpecial{(}\HSSpecial{)}\HSSym{\to} \HSVar{gen}\HSSpecial{)}\;\HSSpecial{(}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSKeyword{let}\;\HSVar{px}\HSSym{\mathrel{=}}\HSVar{promote}\;\HSVar{x}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSKeyword{case}\;\HSVar{px}\;\HSKeyword{of}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\HSCon{Promoted}\;\HSVar{x'}\HSSym{\to} \HSKeyword{do}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\HSVar{p}\HSSym{\leftarrow} \HSVar{idesc\char95 gen}\;\HSSpecial{(}\HSVar{expand}\;\HSVar{desc}\;\HSVar{x'}\HSSpecial{)}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\HSVar{pure}\;\HSSpecial{(}\HSVar{x}\HSSpecial{,}\HSVar{eqConv}\;\HSSpecial{(}\HSVar{eq}\;\HSVar{x'}\HSSpecial{)}\;\HSVar{p}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  First, we obtain a suitable value for the first element by calling the supplied 
  generator. Next, we promote this value \ensuremath{\HSVar{x}} to get a singleton value \ensuremath{\HSVar{x'}} of type \ensuremath{\HSCon{Sing}\;\HSVar{x}}. We apply the promoted value \ensuremath{\HSVar{x'}} to the expansion of the second argument of 
  \ensuremath{\Sigma }, which returns a generator producing values which have the type \ensuremath{\HSCon{Interpret}\;\HSSpecial{(}\HSCon{Expand}\;\HSVar{desc}\;\HSVar{s}\HSSpecial{)}}. We use this generator to get a value \ensuremath{\HSVar{p}} of this type, which we 
  can cast to a value of type \ensuremath{\HSCon{Interpret}\;\HSVar{desc}} using the stored equality proof. 

  With the definition of \ensuremath{\HSVar{idesc\char95 gen}} complete, we can define a function \ensuremath{\HSVar{genDesc}\HSSym{::}\HSVar{forall}\;\HSSpecial{(}\HSVar{d}\HSSym{::}\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}\HSSpecial{)}\HSSym{\to} \HSCon{Sing}\;\HSVar{d}\HSSym{\to} \HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{a}} that produces elements of the raw 
  type represented by a description. Note that we need a conversion function \ensuremath{\HSVar{to}\HSSym{::}\HSCon{Interpret}\;\HSVar{d}\HSSym{\to} \HSVar{a}} to convert the values produced by \ensuremath{\HSVar{idesc\char95 gen}\;\HSVar{d}}. 

\section{Examples}

  We consider two examples to see how we can use the approach described in this 
  section to generate constrained test data. First we consider the type of finite sets 
  (e.g. \ensuremath{\HSCon{Fin}}), and after that the recurring example of well-typed lambda terms. In 
  order to be able to test the derived generators, we assume that a function \ensuremath{\HSVar{run}\HSSym{::}\HSSpecial{(}\HSVar{i}\HSSym{\to} \HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{a}\HSSpecial{)}\HSSym{\to} \HSVar{i}\HSSym{\to} \HSCon{Int}\HSSym{\to} \HSSpecial{\HSSym{[\mskip1.5mu} }\HSVar{a}\HSSpecial{\HSSym{\mskip1.5mu]}}} is in scope, interpreting abstract generators 
  as an exhaustive enumeration up to a certain depth. 

\subsection{Finite sets}

  We assume the canonical definition of \ensuremath{\HSCon{Fin}}, shown in listing \ref{lst:findef}. If we erase the index of 
  a value of type \ensuremath{\HSCon{Fin}\;\HSVar{n}}, we end up with a value of type \ensuremath{\HSCon{Nat}}, hence \ensuremath{\HSCon{Nat}} is the 
  raw type of our description. The goal is then to derive a generator producing values 
  of type \ensuremath{\HSCon{Nat}}, which we interpret as values of type \ensuremath{\HSCon{Fin}\;\HSVar{n}}, but with their indices 
  erased. This means that if we choose \ensuremath{\HSVar{n}} as our index, the generator can only 
  produce values that are \emph{less than} the chosen index \ensuremath{\HSVar{n}}. For example, index \ensuremath{\HSCon{Suc}\;\HSSpecial{(}\HSCon{Suc}\;\HSCon{Zero}\HSSpecial{)}} should only produce the values \ensuremath{\HSCon{Suc}\;\HSCon{Zero}} or \ensuremath{\HSCon{Zero}}, and using index 
  \ensuremath{\HSCon{Zero}} should result in a generator producing no values at all. 

\begin{listing}{Finite sets in Haskell}{lst:findef}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{data}\;\HSCon{Fin}\;\HSSpecial{(}\HSVar{n}\HSSym{::}\HSCon{Nat}\HSSpecial{)}\HSSym{::}\HSSym{*}\HSKeyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{FZero}{}\<[10]%
\>[10]{}\HSSym{::}\HSCon{Fin}\;\HSSpecial{(}\HSCon{Suc}\;\HSVar{n}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{FSuc}{}\<[10]%
\>[10]{}\HSSym{::}\HSCon{Fin}\;\HSVar{n}\HSSym{\to} \HSCon{Fin}\;\HSSpecial{(}\HSCon{Suc}\;\HSVar{n}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{listing}

  We start by defining a type family that maps indices to descriptions: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{37}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{type}\;\HSKeyword{family}\;\HSCon{FinDesc}\;\HSSpecial{(}\HSVar{n}\HSSym{::}\HSCon{Nat}\HSSpecial{)}\HSSym{::}\HSCon{IDesc}\;\HSCon{Nat}\;\HSCon{Nat}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{FinDesc}\;\HSCon{Zero}{}\<[32]%
\>[32]{}\HSSym{\mathrel{=}}\HSCon{Empty}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{FinDesc}\;\HSSpecial{(}\HSCon{Suc}\;\HSVar{n}\HSSpecial{)}{}\<[32]%
\>[32]{}\HSSym{\mathrel{=}}\HSSpecial{(}{}\<[37]%
\>[37]{}\HSCon{SSuc}\;\HSSpecial{(}\HSCon{SSuc}\;\HSCon{SZero}\HSSpecial{)}\HSSpecial{)}{}\<[E]%
\\
\>[37]{}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}}\ \HSSpecial{(}\HSCon{One}\HSSym{:::}\HSCon{Var}\;\HSVar{n}\HSSym{:::}\HSCon{VNil}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  If the index is Zero, we return an empty description. Otherwise we have a choice 
  between two constructors: \ensuremath{\HSCon{Suc}} and \ensuremath{\HSCon{Zero}}. Next, we need to a singleton value of 
  this description: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{finSDesc}\HSSym{::}\HSCon{Sing}\;\HSVar{n}\HSSym{\to} \HSCon{SingIDesc}\;\HSSpecial{(}\HSCon{FinDesc}\;\HSVar{n}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSVar{finSDesc}\;\HSCon{SZero}{}\<[19]%
\>[19]{}\HSSym{\mathrel{=}}\HSCon{SEmpty}{}\<[E]%
\\
\>[B]{}\HSVar{finSDesc}\;\HSSpecial{(}\HSCon{SSuc}\;\HSVar{n}\HSSpecial{)}\HSSym{\mathrel{=}}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{SSuc2}\;\HSSpecial{(}\HSCon{SSuc2}\;\HSCon{SZero2}\HSSpecial{)}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}{\scalebox{1}{\$}}}\ \HSSpecial{(}\HSCon{SOne}\ {\color{gray}\mathbin{:\hspace{-0.3pt}:\hspace{-0.3pt}:\hspace{-0.3pt}\hspace{-0.1pt}}{\scalebox{1}{\$}}}\ \HSCon{SVar}\;\HSVar{n}\ {\color{gray}\mathbin{:\hspace{-0.3pt}:\hspace{-0.3pt}:\hspace{-0.3pt}\hspace{-0.1pt}}{\scalebox{1}{\$}}}\ \HSCon{SVNil}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  In this case, the definition of \ensuremath{\HSVar{finSDesc}} is completely dictated by our definition 
  of \ensuremath{\HSCon{FinDesc}}. Finally, we define a conversion function, mapping interpretations to 
  values: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{toFin}\HSSym{::}\HSCon{Sing}\;\HSVar{n}\HSSym{\to} \HSCon{Interpret}\;\HSSpecial{(}\HSCon{FinDesc}\;\HSVar{n}\HSSpecial{)}\HSSym{\to} \HSCon{Nat}{}\<[E]%
\\
\>[B]{}\HSVar{toFin}\;\HSSpecial{(}\HSCon{SSuc}\;\HSVar{sn}\HSSpecial{)}\;\HSSpecial{(}\HSCon{Left}\;\HSSpecial{(}\HSSpecial{)}\HSSpecial{)}\HSSym{\mathrel{=}}\HSCon{Zero}{}\<[E]%
\\
\>[B]{}\HSVar{toFin}\;\HSSpecial{(}\HSCon{SSuc}\;\HSVar{sn}\HSSpecial{)}\;\HSSpecial{(}\HSCon{Right}\;\HSVar{n}\HSSpecial{)}\HSSym{\mathrel{=}}\HSCon{Suc}\;\HSVar{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  We are now ready to generate values using the description for \ensuremath{\HSCon{Fin}}. We do this 
  simply by promoting the provided index, and calling \ensuremath{\HSVar{genDesc}}.  

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{genFin}\HSSym{::}\HSVar{forall}\;\HSSpecial{(}\HSVar{n}\HSSym{::}\HSCon{Nat}\HSSpecial{)}\ .\ \HSCon{Nat}\HSSym{\to} \HSCon{Gen}\;\HSCon{Nat}\;\HSCon{Nat}\;\HSCon{Nat}{}\<[E]%
\\
\>[B]{}\HSVar{genFin}\;\HSVar{n}\HSSym{\mathrel{=}}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSKeyword{case}\;\HSVar{promote}\;\HSVar{n}\;\HSKeyword{of}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\HSSpecial{(}\HSCon{Promoted}\;\HSVar{sn}\HSSpecial{)}\HSSym{\to} \HSVar{genDesc}\;\HSVar{sn}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  If we now run \ensuremath{\HSVar{genFin}}, we see that it indeed produces the expected output: 

\begin{tabbing}\ttfamily
~\char62{}~run~genFin~Zero~10\\
\ttfamily ~\char91{}\char93{}\\
\ttfamily ~\char62{}~run~genFin~\char40{}Suc~\char40{}Suc~\char40{}Suc~Zero\char41{}\char41{}\char41{}~10\\
\ttfamily ~\char91{}Zero\char44{}Suc~Zero\char44{}Suc~\char40{}Suc~Zero\char41{}\char93{}
\end{tabbing}

\subsection{Well-typed lambda terms}

  The process for generating well-typed lambda terms is exactly the same as for finite 
  sets albeit slightly more involved due to the complexity of the datatype describing 
  well-formedness involved. We use the description shown in listing \ref{lst:slcdescinductive} as a basis, modelling types, terms and contexts with the following datatypes:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{data}\;\HSCon{Type}\HSSym{\mathrel{=}}\HSCon{Type}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$-$}}}\hspace{-0.3pt}>}}\ \HSCon{Type}\HSSym{\mid} \HSCon{T}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\HSKeyword{data}\;\HSCon{Term}\HSSym{\mathrel{=}}\HSCon{TVar}\;\HSCon{Nat}\HSSym{\mid} \HSCon{TAbs}\;\HSCon{Term}\HSSym{\mid} \HSCon{TApp}\;\HSCon{Term}\;\HSCon{Term}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\HSKeyword{type}\;\HSCon{Ctx}\HSSym{\mathrel{=}}\HSSpecial{\HSSym{[\mskip1.5mu} }\HSCon{Type}\HSSpecial{\HSSym{\mskip1.5mu]}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  We use the datatype \ensuremath{\HSCon{CtxPos}} to describe a position in a context: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{data}\;\HSCon{CtxPos}\HSSym{\mathrel{=}}\HSCon{Here}\HSSym{\mid} \HSCon{There}\;\HSCon{CtxPos}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  Next, we define a generator for context positions: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}c<{\hspost}@{}}%
\column{21E}{@{}l@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{genElem}\HSSym{::}\HSCon{Ctx}\HSSym{\to} \HSCon{Type}\HSSym{\to} \HSCon{Gen}\;\HSSpecial{(}\HSSpecial{)}\;\HSCon{CtxPos}\;\HSCon{CtxPos}{}\<[E]%
\\
\>[B]{}\HSVar{genElem}\;\HSSpecial{\HSSym{[\mskip1.5mu} }\HSSpecial{\HSSym{\mskip1.5mu]}}\;\HSSym{\anonymous} {}\<[21]%
\>[21]{}\HSSym{\mathrel{=}}{}\<[21E]%
\>[25]{}\HSVar{empty}{}\<[E]%
\\
\>[B]{}\HSVar{genElem}\;\HSSpecial{(}\HSVar{t}\HSCon{\mathbin{:}}\HSVar{ts}\HSSpecial{)}\;\HSVar{t'}{}\<[21]%
\>[21]{}\HSSym{\mathrel{=}}{}\<[21E]%
\>[25]{}\HSSpecial{(}\HSKeyword{if}\;\HSVar{t}\HSSym{\equiv} \HSVar{t'}\;\HSKeyword{then}\;\HSVar{pure}\;\HSCon{Here}\;\HSKeyword{else}\;\HSVar{empty}\HSSpecial{)}{}\<[E]%
\\
\>[25]{}\HSSym{<|>}\HSSpecial{(}\HSCon{There}\ {\color{gray}\mathbin{<\hspace{-1.6pt}\mathclap{\raisebox{0.1pt}{\scalebox{.8}{\$}}}\hspace{-1.6pt}>}}\ \HSVar{genElem}\;\HSVar{ts}\;\HSVar{t'}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  Here, \ensuremath{\HSVar{genElem}} takes a context and a type, and returns all positions at which that 
  type occurs in the context. With all the necessary prerequisites in 
  place to generate well-typed terms, we start by defining a type family that captures 
  an appropriate description, show in listing \ref{lst:wttermsdesc}. This is a direct 
  translation of the description shown in chapter 7 \ref{lst:slcdescinductive}. Since 
  we never need recursive indices at the type level, we use a type family \ensuremath{\HSCon{I}\;\HSSpecial{(}\HSVar{s}\HSSym{::}\HSSym{*}\HSSpecial{)}\HSSym{::}\HSVar{i}} as a placeholder for the recursive positions inside a \ensuremath{\Sigma }. 

\begin{listing}{Type level description of well typed terms}{lst:wttermsdesc}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{type}\;\HSCon{VarDesc}\HSSym{\mathrel{=}}\Sigma \;\HSSpecial{(}\HSCon{Proxy}\HSSym{::}\HSCon{Proxy}\;\HSCon{CtxPos}\HSSpecial{)}\;\HSCon{One}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSCon{AppDesc}\HSSym{\mathrel{=}}\Sigma \;\HSSpecial{(}\HSCon{Proxy}\HSSym{::}\HSCon{Proxy}\;\HSCon{Type}\HSSpecial{)}\;\HSSpecial{(}\HSCon{Var}\;\HSCon{I}\ {\color{gray}\mathbin{:\hspace{-0.3pt}\mathclap{\raisebox{0.1pt}{\scalebox{1.2}{$*$}}}\hspace{-0.3pt}:}}\ \HSCon{Var}\;\HSCon{I}\HSSpecial{)}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\HSKeyword{type}\;\HSKeyword{family}\;\HSCon{SLTCDesc}\;\HSSpecial{(}\HSVar{i}\HSSym{::}\HSSpecial{(}\HSCon{Ctx}\HSSpecial{,}\HSCon{Type}\HSSpecial{)}\HSSpecial{)}\HSSym{::}\HSCon{IDesc}\;\HSCon{Term}\;\HSSpecial{(}\HSCon{Ctx}\HSSpecial{,}\HSCon{Type}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{SLTCDesc}\;\HSSpecial{(}\HSSpecial{(}\HSSpecial{,}\HSSpecial{)}\;\Gamma \;\HSCon{T}\HSSpecial{)}\HSSym{\mathrel{=}}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{SSuc}\;\HSSpecial{(}\HSCon{SSuc}\;\HSCon{SZero}\HSSpecial{)}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}}\ \HSSpecial{(}\HSCon{VarDesc}\HSSym{:::}\HSCon{AppDesc}\HSSym{:::}\HSCon{VNil}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{SLTCDesc}\;\HSSpecial{(}\HSSpecial{(}\HSSpecial{,}\HSSpecial{)}\;\Gamma \;\HSSpecial{(}\HSVar{t1}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$-$}}}\hspace{-0.3pt}>}}\ \HSVar{t2}\HSSpecial{)}\HSSpecial{)}\HSSym{\mathrel{=}}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{SSuc}\;\HSSpecial{(}\HSCon{SSuc}\;\HSSpecial{(}\HSCon{SSuc}\;\HSCon{SZero}\HSSpecial{)}\HSSpecial{)}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}}\ {}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\HSSpecial{(}\HSCon{VarDesc}\HSSym{:::}\HSCon{Var}\;\HSSpecial{(}\HSSpecial{(}\HSSpecial{,}\HSSpecial{)}\;\HSSpecial{(}\HSVar{t1}\HSCon{\mathbin{:}}\Gamma \HSSpecial{)}\;\HSVar{t2}\HSSpecial{)}\HSSym{:::}\HSCon{AppDesc}\HSSym{:::}\HSCon{VNil}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{listing}

  Next we define a singleton value that inhabits this description (listing \ref
  {lst:wtsingdesc}). Its structure is again dictated completely by the type family \ensuremath{\HSCon{SLTCDesc}}. It now becomes clear why we chose to have the programmer explicitly 
  supply a generator to a \ensuremath{\Sigma }, since we can conveniently apply the index context 
  and type to \ensuremath{\HSVar{genElem}} to obtain a generator that produces the required context 
  positions. 

\begin{listing}{Singleton description of well typed terms}{lst:wtsingdesc}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}c<{\hspost}@{}}%
\column{3E}{@{}l@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{sltcDesc}\HSSym{::}\HSCon{Sing}\;\HSVar{i}\HSSym{\to} \HSCon{Sing}\;\HSSpecial{(}\HSCon{SLTCDesc}\;\HSVar{i}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSVar{sltcDesc}\;\HSSpecial{(}\HSCon{SPair}\;\Gamma \;\HSCon{ST}\HSSpecial{)}\HSSym{\mathrel{=}}\HSSpecial{(}\HSCon{SSuc2}\;\HSSpecial{(}\HSCon{SSuc2}\;\HSCon{SZero2}\HSSpecial{)}\HSSpecial{)}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}{\scalebox{1}{\$}}}\ {}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSSpecial{(}{}\<[3E]%
\>[9]{}\HSCon{SSigma}\;\HSCon{SOne}\;\HSSpecial{(}\HSVar{genElem}\;\Gamma \;\HSCon{T}\HSSpecial{)}\;\HSSpecial{(}\HSSym{\char92 \char95 }\HSSym{\to} \HSCon{Refl}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\ {\color{gray}\mathbin{:\hspace{-0.3pt}:\hspace{-0.3pt}:\hspace{-0.3pt}\hspace{-0.1pt}}{\scalebox{1}{\$}}}\ {}\<[3E]%
\>[9]{}\HSCon{SSigma}\;{}\<[17]%
\>[17]{}\HSSpecial{(}\HSCon{SVar}\;\HSSpecial{(}\HSSym{\lambda} \sigma \HSSym{\to} \HSSpecial{(}\Gamma \HSSpecial{,}\sigma \ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$-$}}}\hspace{-0.3pt}>}}\ \HSCon{T}\HSSpecial{)}\HSSpecial{)}\ {\color{gray}\mathbin{:\hspace{-0.3pt}\mathclap{\raisebox{0.1pt}{\scalebox{1.2}{$*$}}}\hspace{-0.3pt}:}{\scalebox{1}{\$}}}\ \HSCon{SVar}\;\HSSpecial{(}\Gamma \HSSpecial{,}\HSSpecial{)}\HSSpecial{)}\;{}\<[E]%
\\
\>[17]{}\HSVar{genType}\;\HSSpecial{(}\HSSym{\char92 \char95 }\HSSym{\to} \HSCon{Refl}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\ {\color{gray}\mathbin{:\hspace{-0.3pt}:\hspace{-0.3pt}:\hspace{-0.3pt}\hspace{-0.1pt}}{\scalebox{1}{\$}}}\ {}\<[3E]%
\>[9]{}\HSCon{SVNil}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSVar{sltcDesc}\;\HSSpecial{(}\HSCon{SPair}\;\Gamma \;\HSSpecial{(}\HSVar{t1}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$-$}}}\hspace{-0.3pt}>}{\scalebox{1}{\$}}}\ \HSVar{t2}\HSSpecial{)}\HSSpecial{)}\HSSym{\mathrel{=}}\HSSpecial{(}\HSCon{SSuc2}\;\HSSpecial{(}\HSCon{SSuc2}\;\HSSpecial{(}\HSCon{SSuc2}\;\HSCon{SZero2}\HSSpecial{)}\HSSpecial{)}\HSSpecial{)}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$+$}}}\hspace{-0.3pt}>}{\scalebox{1}{\$}}}\ {}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSSpecial{(}{}\<[3E]%
\>[9]{}\HSCon{SSigma}\;\HSCon{SOne}\;\HSSpecial{(}\HSVar{genElem}\;\HSSpecial{(}\Gamma \HSSpecial{)}\;\HSSpecial{(}\HSVar{t1}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$-$}}}\hspace{-0.3pt}>}}\ \HSVar{t2}\HSSpecial{)}\HSSpecial{)}\;\HSSpecial{(}\HSSym{\char92 \char95 }\HSSym{\to} \HSCon{Refl}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\ {\color{gray}\mathbin{:\hspace{-0.3pt}:\hspace{-0.3pt}:\hspace{-0.3pt}\hspace{-0.1pt}}{\scalebox{1}{\$}}}\ {}\<[3E]%
\>[9]{}\HSCon{SVar}\;\HSSpecial{(}\HSVar{t1}\HSCon{\mathbin{:}}\Gamma \HSSpecial{,}\HSVar{t2}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\ {\color{gray}\mathbin{:\hspace{-0.3pt}:\hspace{-0.3pt}:\hspace{-0.3pt}\hspace{-0.1pt}}{\scalebox{1}{\$}}}\ {}\<[3E]%
\>[9]{}\HSCon{SSigma}\;{}\<[17]%
\>[17]{}\HSSpecial{(}\HSCon{SVar}\;\HSSpecial{(}\HSSym{\lambda} \sigma \HSSym{\to} \HSSpecial{(}\Gamma \HSSpecial{,}\sigma \ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$-$}}}\hspace{-0.3pt}>}}\ \HSSpecial{(}\HSVar{t1}\ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$-$}}}\hspace{-0.3pt}>}}\ \HSVar{t2}\HSSpecial{)}\HSSpecial{)}\HSSpecial{)}\ {\color{gray}\mathbin{:\hspace{-0.3pt}\mathclap{\raisebox{0.1pt}{\scalebox{1.2}{$*$}}}\hspace{-0.3pt}:}{\scalebox{1}{\$}}}\ \HSCon{SVar}\;\HSSpecial{(}\Gamma \HSSpecial{,}\HSSpecial{)}\HSSpecial{)}\;{}\<[E]%
\\
\>[9]{}\hsindent{7}{}\<[16]%
\>[16]{}\HSVar{genType}\;\HSSpecial{(}\HSSym{\char92 \char95 }\HSSym{\to} \HSCon{Refl}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\ {\color{gray}\mathbin{:\hspace{-0.3pt}:\hspace{-0.3pt}:\hspace{-0.3pt}\hspace{-0.1pt}}{\scalebox{1}{\$}}}\ {}\<[3E]%
\>[9]{}\HSCon{SVNil}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{listing}

  We now only have to define a convertion function that takes generated values and 
  produces raw terms: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{toTerm}\HSSym{::}\HSCon{Sing}\;\HSVar{i}\HSSym{\to} \HSCon{Interpret}\;\HSSpecial{(}\HSCon{SLTCDesc}\;\HSVar{i}\HSSpecial{)}\HSSym{\to} \HSCon{Term}{}\<[E]%
\\
\>[B]{}\HSVar{toTerm}\;\HSSpecial{(}\HSCon{SPair}\;\HSSym{\anonymous} \;\HSCon{ST}\HSSpecial{)}\;\HSSpecial{(}\HSCon{Left}\;\HSSpecial{(}\HSVar{n}\HSSpecial{,}\HSSpecial{(}\HSSpecial{)}\HSSpecial{)}\HSSpecial{)}\HSSym{\mathrel{=}}\HSCon{TVar}\;\HSSpecial{(}\HSVar{toNat}\;\HSVar{n}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSVar{toTerm}\;\HSSpecial{(}\HSCon{SPair}\;\HSSym{\anonymous} \;\HSCon{ST}\HSSpecial{)}\;\HSSpecial{(}\HSCon{Right}\;\HSSpecial{(}\HSSym{\anonymous} \HSSpecial{,}\HSSpecial{(}\HSVar{t1}\HSSpecial{,}\HSVar{t2}\HSSpecial{)}\HSSpecial{)}\HSSpecial{)}\HSSym{\mathrel{=}}\HSCon{TApp}\;\HSVar{t1}\;\HSVar{t2}{}\<[E]%
\\
\>[B]{}\HSVar{toTerm}\;\HSSpecial{(}\HSCon{SPair}\;\HSSym{\anonymous} \;\HSSpecial{(}\HSSym{\anonymous} \ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$-$}}}\hspace{-0.3pt}>}{\scalebox{1}{\$}}}\ \HSSym{\anonymous} \HSSpecial{)}\HSSpecial{)}\;\HSSpecial{(}\HSCon{Left}\;\HSSpecial{(}\HSVar{n}\HSSpecial{,}\HSSpecial{(}\HSSpecial{)}\HSSpecial{)}\HSSpecial{)}\HSSym{\mathrel{=}}\HSCon{TVar}\;\HSSpecial{(}\HSVar{toNat}\;\HSVar{n}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSVar{toTerm}\;\HSSpecial{(}\HSCon{SPair}\;\HSSym{\anonymous} \;\HSSpecial{(}\HSSym{\anonymous} \ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$-$}}}\hspace{-0.3pt}>}{\scalebox{1}{\$}}}\ \HSSym{\anonymous} \HSSpecial{)}\HSSpecial{)}\;\HSSpecial{(}\HSCon{Right}\;\HSSpecial{(}\HSCon{Left}\;\HSVar{y}\HSSpecial{)}\HSSpecial{)}\HSSym{\mathrel{=}}\HSCon{TAbs}\;\HSVar{y}{}\<[E]%
\\
\>[B]{}\HSVar{toTerm}\;\HSSpecial{(}\HSCon{SPair}\;\HSSym{\anonymous} \;\HSSpecial{(}\HSSym{\anonymous} \ {\color{gray}\mathbin{:\hspace{-0.1pt}\mathclap{\raisebox{0.1pt}{\scalebox{.9}{$-$}}}\hspace{-0.3pt}>}{\scalebox{1}{\$}}}\ \HSSym{\anonymous} \HSSpecial{)}\HSSpecial{)}\;\HSSpecial{(}\HSCon{Right}\;\HSSpecial{(}\HSCon{Right}\;\HSSpecial{(}\HSSym{\anonymous} \HSSpecial{,}\HSSpecial{(}\HSVar{t1}\HSSpecial{,}\HSVar{t2}\HSSpecial{)}\HSSpecial{)}\HSSpecial{)}\HSSpecial{)}\HSSym{\mathrel{=}}\HSCon{TApp}\;\HSVar{t1}\;\HSVar{t2}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  Giving us everything we need to start generating well-typed terms. We do 
  this again by promoting the supplied index, and calling \ensuremath{\HSVar{genDesc}} with this value: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{termGen}\HSSym{::}\HSSpecial{(}\HSCon{Ctx}\HSSpecial{,}\HSCon{Type}\HSSpecial{)}\HSSym{\to} \HSCon{Gen}\;\HSSpecial{(}\HSCon{Ctx}\HSSpecial{,}\HSCon{Type}\HSSpecial{)}\;\HSCon{Term}\;\HSCon{Term}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSVar{termGen}\;\HSVar{i}\HSSym{\mathrel{=}}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\HSKeyword{case}\;\HSVar{promote}\;\HSVar{i}\;\HSKeyword{of}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\HSSpecial{(}\HSCon{Promoted}\;\HSVar{i'}\HSSpecial{)}\HSSym{\to} \HSVar{genDesc}\;\HSVar{i'}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  We can now use \ensuremath{\HSVar{run}\;\HSVar{termGen}} to produce well-typed given a context and a goal type: 

\begin{tabbing}\ttfamily
~λ\char62{}~run~termGen~\char40{}\char91{}T~\char44{}~T~\char58{}\char45{}\char62{}~T\char93{}~\char44{}~T\char41{}~3\\
\ttfamily ~\char91{}TVar~Zero\char44{}TApp~\char40{}TVar~\char46{}\char46{}\char46{}~\char46{}\char46{}\char46{}~\char46{}\char46{}\char46{}~\char40{}TVar~\char40{}Suc~\char40{}Suc~\char40{}Suc~Zero\char41{}\char41{}\char41{}\char41{}\char41{}\char41{}\char93{}
\end{tabbing}

  To assert that the produced values are indeed type correct, we define a function \ensuremath{\HSVar{check}\HSSym{::}\HSCon{Ctx}\HSSym{\to} \HSCon{Type}\HSSym{\to} \HSCon{Term}\HSSym{\to} \HSCon{Bool}} that checks whether a raw term has a certain 
  type under certain context. 

\begin{tabbing}\ttfamily
~λ\char62{}~all~\char40{}check~\char91{}T~\char44{}~T~\char58{}\char45{}\char62{}~T\char93{}~T\char41{}~\char36{}~run~termGen~\char40{}\char91{}T~\char44{}~T~\char58{}\char45{}\char62{}~T\char93{}~\char44{}~T\char41{}~3\\
\ttfamily ~True
\end{tabbing}

\section*{Conclusion}

  We have given an implementation of the generic generator for indexed descriptions in 
  Haskell, whose produced elements satisfy the constraint described by the input 
  description by construction. Perhaps surprisingly so, we have been able to enforce 
  the same static guarantees in the Haskell development as in our Agda development, 
  without sacrificing too much in terms of expressiveness. Of course, the question 
  what exactly we lose by restricting the \ensuremath{\HSSpecial{`}\Sigma } constructor remains a lingering 
  question, which is definitely not easy to answer; writing a description in Agda that 
  we cannot convert to the Haskell development is easy, but who is to say that no 
  other description exists describing the same type, which we \emph{can} write with 
  the Haskell datatype. 

  It is worth noting that we have been as true as possible to the Agda development, 
  forfeiting possible change in design. The primary reason for this is that it allows 
  us to use the completeness proof we have written in Agda as an argument for the 
  correctness of our Haskell development with greater confidence. 

  With this implementation, we have provided a framework in Haskell with which it is 
  indeed possible to generate constrained test data, so long we are able to find a 
  suitable indexed family that describes the relevant constraints. We considered the 
  recurring example of well-typed lambda terms, and have shown how well-formed raw 
  terms can be generated. 

\chapter{Discussion}
In this final chapter, we will discuss the work presented in this thesis and place it in the context of existing literature. Will also consider some possible next steps, and reflect on the results and some of the design choices we have made. 

\section{Conclusion}

  We have explored various approaches to the generation of test data 
  using datatype generic programming, with the ultimate goal being to be able to 
  generate test data that is subject to arbitrary constraints. Based on the observation that constrained test 
  data can often be described as an indexed family, we approached this problem by 
  looking at how to generate values of indexed families. We have looked at three 
  distinct type universes, starting with the universe of Regular types, which is able 
  to describe a set of algebraic datatypes roughly equal to the algebraic datatypes in 
  Haskell 98 \cite{jones2003haskell}. We described this universe in Agda, and showed 
  how a generator can be derived from a code in this universe. Although the exact 
  generator type is kept abstract in this derivation, we have described an example 
  instantiation where generators are functions of type \agda{Int → List a}, similar to 
  SmallCheck's \ensuremath{\HSCon{Series}} \cite{runciman2008smallcheck} typeclass. For this particular generator 
  type, we have proved that the generator derived from a code is \emph{complete}. That 
  is, every value of the type described by the input code will eventually show up in 
  the enumeration. 

  We then looked at two more expressive type universes, which are able to describe 
  (some) indexed datatypes: \emph{Indexed Containers} \cite{altenkirch2015indexed} and 
  \emph{Indexed Descriptions} \cite{dagand2013cosmology}. For both universes, we 
  described how a generic generator may be constructed from codes in these universes. 
  For the universe of indexed descriptions, we also proved that the enumerative 
  instantiation of the generator type satisfied our completeness property. For indexed 
  containers, we were unfortunately not able to complete this proof. Attempts to 
  construct a proof using the same structure as used to construct the completeness 
  proofs for regular types and indexed descriptions failed, as this approach would 
  require induction over function types. 

  Having constructed a mechanism that allows generation for arbitrary indexed families 
  in Agda, we implemented the generic generator for indexed descriptions in Haskell. 
  Although in order to enforce correctness of the generated data in Haskell's type 
  system we needed to impose some restrictions on the descriptions that could be used, 
  we were still able to describe all the example datatypes. We used this 
  implementation to generate some example constrained test data, including well-typed 
  lambda terms. The final result is a Haskell library that is able to generate 
  constrained test data, given that the user provides a description of an indexed 
  family that describes the desired test data. 

  

\section{Reflection}

  While the framework we have developed is very flexible and expressive in terms of what 
  kind of test data we can generate, it is important to recognize that it is still very 
  much experimental, and that much improvement is needed before it can be used in any 
  practical setting. Here, we shortly outline some of the problems that remain with 
  our current development, and critically reflect on some of the design choices 
  made along the way. 

\subsection{Remaining problems}

  First, finding a description that accurately describes an indexed family is not at all trivial. Often, there exist 
  multiple descriptions that all describe the same datatype. These different 
  descriptions are all mapped to distinct generators, which may not necessarily 
  exhibit the same behavior in terms of computational efficiency, or the order in 
  which elements are generated. The fact that Haskell's type system in no way enforces 
  the semantics of the input description to be actually isomorphic to the datatype it 
  describes leaves room for mistakes when defining descriptions and the conversion 
  between their semantics and the desired datatype. Furthermore, it is hard to say how 
  well this approach scales when we require more complex test data, especially since 
  this would require the programmer to come up with increasingly complex descriptions. 
  Although our Agda formalization allows us to be reasonably confident that the 
  generators we derive indeed produce values of the intended datatype, we have no 
  knowledge about how efficient they are at doing this, and to what extent a 
  generator's efficiency depends on the structure of the derived generator. 

\subsection{Design choices}

  While we did in the end reach our goal of developing a method for generation of 
  arbitrary indexed families, there are some aspects of our development for which, 
  in hindsight, a different approach or design might have been beneficial. 

\subsubsection{Instantiation of the abstract generator type}

  The primary reason we settled for the particular enumerative interpretation of 
  generators that we use in our model is that it is relatively convenient to work
  with and easy to reason about. While these are important properties when assembling
  a theoretical model, there are some practical downsides. Most notably, the size parameter 
  we choose is very crude, giving the programmer little control over the amount of 
  test values generated. 

  We have looked at \emph{Colists} in combination with \emph{sized types} 
  \cite{abel2010miniagda} to use as a result type for our generators. Colists allow 
  (possible) infinite lists to be defined in Agda (normally the termination checker
  does not allow this) by making the operational semantics explicit. \emph{Sized types}
  further expand the space of functions we can define by including information about 
  the size of values in the type. The nice thing about having colists as our result 
  type is that they give the user a lot of control over the amount of elements generated.   
  Furthermore, infinite lists are idiomatic in Haskell, making it likely that generators 
  producing colists carry over well once we implement our development in Haskell. 

  Unfortunately, we were unable to make this approach work, specifically because we had 
  trouble convincing Agda's termination checker that our notion of cartesian product 
  between two colists was terminating, even with the usage of sized types. 

\subsubsection{Usage of existing libraries}

  In many places throughout our Agda model, we have performed unnecessary work by 
  defining functionality that is already defined in Agda's standard library. Although 
  this is perhaps unsurprising given the author's unfamiliarity with Agda previous to 
  this work, it still harms the composability and reusability of our development. A 
  similar concern exists with the Haskell library, which relies on our own notion of 
  singleton types, instead of using the existing package.  

\subsubsection{Completeness property}

  While our completeness property guarantees that all values of a type will eventually 
  be generated, it still leaves a lot of room for erroneous behavior of generators. Mainly, 
  it does not guarantee anything about the order in which generators produce elements, 
  and allows enumerations to contain the same value more than once. While the completeness 
  property we have chosen works fine if we regard it just as 
  a sanity check that the generators we derive do not contain any fatal mistakes, it 
  does not guarantee that these generators are actually usable in practice. 

\section{Related Work}

  In this section, we briefly discuss some of the academic context surrounding our work. 

\subsection{Libraries for property based testing}

  Different libraries may take different approaches towards the generation of 
  test data. Studying these libraries provides us with valuable insight into the 
  established methods for test data generation, and how these methods relate to 
  our work. 

\subsubsection{QuickCheck}

  Published in 2000 by Claessen \& Hughes \cite{claessen2011quickcheck}, QuickCheck 
  implements property based testing for Haskell. Test values are generated by sampling 
  randomly from the domain of test values. QuickCheck supplies the typeclass \texttt
  {Arbitrary}, whose instances are those types for which random values can be 
  generated. A property of type \ensuremath{\HSVar{a}\HSSym{\to} \HSCon{Bool}} can be tested if \ensuremath{\HSVar{a}} is an instance of 
  \texttt{Arbitrary}. Although instances for most common Haskell types are supplied by the 
  library, QuickCheck refrains from employing any form of generic programming, instead 
  choosing to provide a comprehensive set of combinators with which a programmer can 
  assemble generators. 

  Perhaps somewhat surprising is that QuickCheck is also able randomly generate values 
  for function types by modifying the seed of the random generator (which is used to 
  generate the function's output) based on it's input. 

\subsubsection{SmallCheck} 

  Contrary to QuickCheck, SmallCheck \cite{runciman2008smallcheck} takes an \textit
  {enumerative} approach to the generation of test data. While the approach to 
  formulation and testing of properties is largely similar to QuickCheck's, test 
  values are not generated at random, but rather exhaustively enumerated up to a 
  certain \textit{recursive depth}. Zero-arity constructors have depth $0$, while 
  the depth of any positive arity constructor is one greather than the maximum depth 
  of its arguments. The motivation behind this approach is the 
  \textit{small scope hypothesis}, which states that if a program is incorrect, then it 
  will almost allways fail on some small input value \cite{andoni2003evaluating}. 

  In addition to SmallCheck, there is also \textit{Lazy} SmallCheck, which evaluates 
  properties on partial test values, making it possible to test entire classes 
  of test data at once. 

\subsubsection{LeanCheck} 

  Where SmallCheck uses a value's \textit{depth} to bound the number of test values, 
  LeanCheck uses a value's \textit{size} \cite{matela2017tools}, where size is defined 
  as the number of construction applications of positive arity. This gives a more 
  fine-grained notion of size, which helps to battle the rapid growth of the space
  of test values. 

\subsubsection{Feat}

  A downside to both SmallCheck and LeanCheck is that they they are very inefficient when 
  it comes to the generation of large test values; they both require all that are smaller 
  (in terms of their respective definition of size) to be enumerated first. 
  QuickCheck has no problem with either, but generators are often more tedious to write 
  compared to their SmallCheck counterpart. Feat \cite{duregaard2013feat} aims to fill 
  this gap by providing a way to efficiently enumerate algebraic types, employing 
  memoization techniques to efficiently index these enumerations. 

\subsubsection{Hedgehog}

  Hedgehog \cite{hedgehog} is a framework similar to QuickCheck, that employs random sampling 
  to find test values. Hedgehog has no facilities for the automatic derivation of generators, 
  and is even more rigorous in its approach than QuickCheck, only exposing a minimal set 
  of combinators with which users can assemble their own generator. 

\subsubsection{QuickChick} 

  QuickChick is a QuickCheck clone for the proof assistant Coq \cite
  {denes2014quickchick}. The fact that Coq is a proof assistant enables the user to 
  reason about the testing framework itself \cite{paraskevopoulou2015foundational}. 
  This allows one, for example, to prove that generators adhere to some distribution. 

\subsubsection{QuickSpec}

  A surprising application of property based testing is the automatic generation of 
  program specifications, proposed by Claessen et al. \cite{claessen2010quickspec} 
  with the tool \textit{QuickSpec}. QuickSpec automatically generates a set of 
  candidate formal specifications given a list of pure functions, specifically in the 
  form of algebraic equations. Random property based testing is then used to falsify 
  specifications. In the end, the user is presented with a set of equations for which 
  no counterexample was found.  

\subsection{Type universes}

  Besides the universes of of indexed containers and indexed descriptions, other generic 
  representations of indexed families have been developed as well. Here we briefly discuss 
  some alternative type universes. 

\subsubsection{Indexed functors}

  Löh and Magalhães propose in their paper \emph{Generic Programming with Indexed 
  Functors} \cite{loh2011generic} a type universe for generic programming in Agda, 
  that is able to handle a large class of indexed datatypes. Their universe takes the 
  universe of regular types as a basis. 
  
  The semantics of the universe, however, is not a functor \agda{Set → Set}, but rather an 
  \emph{indexed} functor \agda{(I → Set) → O → Set}. Additionally, they add some 
  combinators, such as first order constructors to encode isomorphisms and fixpoints 
  as part of their universe. 

\subsubsection{Combinatorial species}

  Combinatorial species \cite{yorgey2010species} were 
  originally developed as a mathematical framework, but can also be used as an 
  alternative way of looking at datatypes. A species can, in terms of functional 
  programming, be thought of as a type constructor with one polymorphic argument. 
  Haskell’s algebraid datatypes (or regular types in general) can be described by defining familiar 
  combinators for species, such as sum and product.

\subsubsection{Mutually recursive sums of product}

  On of the more simple representations is the so called \textit{Sum of Products} view 
  \cite{de2014true}, where datatypes are respresented as a choice between an arbitrary 
  amount of constructors, each of which can have any arity. This view corresponds to 
  how datatypes are defined in Haskell, and is closely related to the universe of 
  regular types. As we have seen when discussing regular types, other 
  universes too employ sum and product combinators to describe the structure of 
  datatypes, though they do not necessarily enforce the representation to be in 
  disjunctive normal form. Sum of Products, in its simplest form, cannot represent 
  mutually recursive families of datatypes. An extension that allows this has been 
  developed in \cite{miraldo2018sums}, and is available as a Haskell library through 
  \emph{Hackage}.  

\subsection{Generating constrained test data}

  Some work in the direction of generating constrained test data has already be done. 
  For example, an approach to generation of constrained test data for Coq's QuickChick 
  was proposed by Lampropoulos et al. \cite{lampropoulos2017generating} in their 2017 
  paper \textit{Generating Good Generators for Inductive Relations}. They observe a 
  the same common pattern on which the work in this thesis is based, where the required 
  test data is of a simple type, but constrained by some precondition. The precondition 
  can then be modeled as some inductive dependent relation indexed by said simple type. 
  The \agda{Sorted} datatype shown in chapter \ref{sec:introduction} is a good example of 
  this

  They derive generators for such datatypes by abstracting over dependent inductive 
  relations indexed by simple types. For every constructor, the resulting type uses a 
  set of expressions as indices, that may depend on the constructor's arguments and 
  universally quantified variables. These expressions induce a set of unification 
  constraints that apply when using that particular constructor. These unification 
  constraints are then used when constructing generators to ensure that only values 
  for which the dependent inductive relation is inhabited are generated. 

  A slightly different approach was taken by Claessen and Duregaard 
  \cite{claessen2015generating}, who adapt the techniques described 
  by Duregaard \cite{duregaard2013feat} to allow efficient generation of constrained 
   data. They use a variation on rejection sampling, where the space of values is 
  gradually refined by rejecting classes of values through partial evaluation 
  (similar to Lazy SmallCheck \cite{runciman2008smallcheck}) until a value satisfying 
  the imposed constrained is found. 

\subsection{Generating well-typed lambda terms}

  A problem often considered in literature is the generation of (well-typed) lambda 
  terms \cite{palka2011testing, grygiel2013counting, claessen2015generating}. Good 
  generation of arbitrary program terms is especially interesting in the context of 
  testing compiler infrastructure, and lambda terms provide a natural first step 
  towards that goal. 

  An approach centered around the semantics of the simply typed lambda 
  calculus is described by Pa{\l}ka et al. \cite{palka2011testing}. Contrary to the 
  work done by Claessen and Duregaard \cite{claessen2015generating}, where 
  typechecking is viewed as a black box, they utilize definition of the typing rules 
  to devise an algorithm for generation of random lambda terms. The basic approach is 
  to take some input type, and randomly select an inference rule from the set of rules 
  that could have been applied to arrive at the goal type. Obviously, such a procedure 
  does not guarantee termination, as repeated application of the function application 
  rule will lead to an arbitrarily large goal type. As such, the algorithm requires a 
  maximum search depth and backtracking in order to guarantee that a suitable term 
  will eventually be generated, though it is not guaranteed that such a term exists if 
  a bound on term size is enforced \cite{moczurad2000statistical}. 

  Wang \cite{wang2005generating} considered the problem of generating closed untyped 
  lambda terms. Furthermore, Claessen and Duregaard \cite{claessen2015generating} 
  specifically apply their work to the problem of generating well-typed lambda terms, 
  considering this particular problem as a running example throughout their paper.  

\section{Next steps \& future work}

  As highlighted throughout this chapter, there is plenty of room for improvement upon 
  the current state of the work. In this section we discuss a few of the possibilities. 

\subsubsection{Generator optimizations}

  As of yet, no work has been done to make generators more efficient. In practice, 
  this means that the derived generators are likely to be too slow to generate usable 
  data for most practical applications. One of the more promising approaches to fix 
  this is by memoization. It is likely that a generator solves the same subproblem 
  many times, so it could greatly benefit in terms of efficiency by reusing previous 
  solutions. For example, when generating a well-typed lambda term, the generator 
  might encounter the same combination of goal context and type multiple times, 
  meaning that it solves the same subproblem more often than it needs to. We might 
  find inspiration in the work done by Claessen and Dureg{\aa}rd \cite
  {duregaard2013feat}, who devised a memoization strategy that allows for efficient 
  indexing of the enumeration of algebraic datatypes. 

\subsubsection{Generating mutually recursive families}

  As of yet, the library we have developed cannot be used to generate inhabitants of 
  mutually recursive datatypes. This is a severe limitation, as many abstract syntax 
  datatypes utilize mutual recursion. Type universes that are able to represent 
  mutually recursive types exist \cite{miraldo2018sums}\cite{yakushev2009generic}, however 
  they are not necessarily able to represent arbitrary indexed families. Bringert and 
  Ranta \cite{bringert2006pattern} propose a pattern for converting mutually recursive 
  types to a GADT, indexed with a tag that marks which datatype of the mutually 
  recursive family a recursive position refers to. Yakushev et al. \cite
  {yakushev2009generic} use this technique for their approach. Our Haskell library is 
  expressive enough to generate values for these GADT's, so this appears to be a 
  promising approach to generation of mutually recursive indexed families. 

\subsubsection{Integration with existing testing frameworks}

  We have provided a sample instantiation of the abstract generator type as a bounded 
  enumeration. However, theoretically it is possible to transform the abstract 
  generator type to any desired generator type, as long as we are able to come up with 
  a suitable mapping. This allows our library to be potentially integrated with 
  external testing libaries by defining a mapping between the abstract generator type, 
  and the type of generators used by a particular library. For SmallCheck, this is 
  simple enough, as their generator type is almost exactly equal to our example 
  instantiation. However, when transforming abstract generators to sampling generators 
  (such as used in QuickCheck and Hedgehog), this mapping is not at all trivial. Most 
  notably, it is not immediately clear how we should deal with generators that produce 
  no elements, and recursive positions. Especially deriving \emph{sized} generators 
  for the QuickCheck library is challenging without including additional information 
  in the abstract generator type. 

\subsubsection{Property based testing for GADT's}

  Most testing frameworks for Haskell currently only include functionality to generate 
  values of regular algebraic datatypes. If we were to test a function that has a GADT 
  as its input type, we are only left with the possibility of defining a custom 
  generator for the type. Since the universe of indexed descriptions is potentially 
  expressive enough to describe any GADT, we could leverage the work from this thesis 
  to extend existing testing libraries with the possibility to automatically derive 
  generators for GADT's. 

\subsubsection{Increasing usability and practicality of the Haskell Library}

  Currently, the provided library that implements generic generators for indexed 
  descriptions is very basic, and requires the user to supply both a type family 
  describing the datatype, as well as a singleton value. Additionally, they need to 
  write a conversion function that converts the generated values to a non-indexed 
  type. In terms of practicality and usability there is much to be gained by further 
  automating this process. Possibilities include the definition of smart constructors 
  to abstract over common patterns, and using template Haskell \cite
  {sheard2002template} to (partially) automate the definition of the singleton 
  description from the type level description, making a "bootstrapping" approach in which 
  we single out the difficult parts of generation for a larger datatype, and reuse 
  our facilities to derive generators for these bottlenecks much more feasible. 

\subsubsection{Generating well-formed programs in a realistic programming language}

  The examples presented in this thesis are mostly relatively simple indexed families. 
  In order to further investigate the practical applicability of our work, we think 
  that it is essential to study how our approach applies to a more complex example. 
  A prime candidate for this purpose would be term generation for Plutus Core, which 
  motivated our work in the first place. James Chapman's formalization in Agda, which 
  is available through IOHK's website \cite{systemfagda}, would be a natural starting 
  point for this. 

%% \appendix
%% \chapter{Datatype Definitions}
%% %include src/appA/body.lhs

\backmatter
\listoffigures

\bibliographystyle{acm}
\bibliography{references}

\end{document}


