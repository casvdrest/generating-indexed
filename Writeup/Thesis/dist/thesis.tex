\documentclass[a4paper,msc,twosized=semi]{uustthesis}

\usepackage{framed}
\usepackage{mdframed}
\usepackage{setspace}
% \usepackage{extsizes}

\renewcommand{\figurename}{Listing}
\renewcommand{\listfigurename}{Code listings}

%% Listings 
\newenvironment{listing}[2] %% #1 = caption #2 = label
{
    \begin{figure}[h]
      \label{#2}
      \begin{framed}
        \caption{#1}
}
{
      \end{framed}
    \end{figure}
}

%% Agda snippets 
\newcommand{\includeagda}[2]{\vspace*{-0.35cm}\begin{center}\ExecuteMetaData[../src/chap0#1/latex/code.tex]{#2}\end{center}\vspace*{-0.35cm}}

%% Agda snippets, without removed spacing
\newcommand{\includeagdanv}[2]{\begin{center}\ExecuteMetaData[../src/chap0#1/latex/code.tex]{#2}\end{center}}

%% Agda snippets, not centered
\newcommand{\includeagdanc}[2]{\ExecuteMetaData[../src/chap0#1/latex/code.tex]{#2}\vspace*{-0.35cm}}

%% Agda listings
\newcommand{\includeagdalisting}[4]{
  \begin{listing}{#3}{#4} 
    \includeagdanc{#1}{#2}
  \end{listing} 
}

%% Agda snippets (appendices)
\newcommand{\appincludeagda}[2]{\ExecuteMetaData[../src/app#1/latex/code.tex]{#2}}

%% Agda listings (appendices)
\newcommand{\appincludeagdalisting}[4]{
  \begin{listing}{#3}{#4} 
    \appincludeagda{#1}{#2}
  \end{listing}
}

\newmdenv[
  topline=false,
  bottomline=false,
  rightline=false,
  skipabove=\topsep,
  skipbelow=\topsep
]{siderules}

\newenvironment{example}[0] 
{
  \begin{siderules}
    \vspace{-0.5cm}
    \paragraph{\textbf{Example}}
}
{
  \end{siderules}
}

%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
%
%
\ReadOnlyOnce{colorcode.fmt}%

\RequirePackage{colortbl}
\RequirePackage{calc}

\makeatletter
\newenvironment{colorhscode}%
  {\hsnewpar\abovedisplayskip
   \hscodestyle
   \tabular{@{}>{\columncolor{codecolor}}p{\linewidth}@{}}%
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \endtabular
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{tightcolorhscode}%
  {\hsnewpar\abovedisplayskip
   \hscodestyle
   \tabular{@{}>{\columncolor{codecolor}\(}l<{\)}@{}}%
   \pmboxed}%
  {\endpmboxed%
   \endtabular
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{barhscode}%
  {\hsnewpar\abovedisplayskip
   \hscodestyle
   \arrayrulecolor{codecolor}%
   \arrayrulewidth=\coderulewidth
   \tabular{|p{\linewidth-\arrayrulewidth-\tabcolsep}@{}}%
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \endtabular
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}
\makeatother

\def\colorcode{\columncolor{codecolor}}
\definecolor{codecolor}{rgb}{1,1,.667}
\newlength{\coderulewidth}
\setlength{\coderulewidth}{3pt}

\newcommand{\colorhs}{\sethscode{colorhscode}}
\newcommand{\tightcolorhs}{\sethscode{tightcolorhscode}}
\newcommand{\barhs}{\sethscode{barhscode}}

\EndFmtInput

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 
%% Haskell Styling
%%
%% TODO: Figure out spacing!

%% Colors (from duo-tone light syntax)
\definecolor{hsblack}{RGB}{45,32,3}
\definecolor{hsgold1}{RGB}{179,169,149}
\definecolor{hsgold2}{RGB}{177,149,90}
\definecolor{hsgold3}{RGB}{190,106,13}%{192,96,4}%{132,97,19}
\definecolor{hsblue1}{RGB}{173,176,182}
\definecolor{hsblue2}{RGB}{113,142,205}
\definecolor{hsblue3}{RGB}{0,33,132}
\definecolor{hsblue4}{RGB}{97,108,132}
\definecolor{hsblue5}{RGB}{34,50,68}
\definecolor{hsred2}{RGB}{191,121,103}
\definecolor{hsred3}{RGB}{171,72,46}

%% LaTeX Kerning nastiness. By using curly braces to delimit color group,
%% it breaks spacing. The following seems to work:
%%
%% https://tex.stackexchange.com/questions/85033/colored-symbols/85035#85035
%%
\newcommand*{\mathcolor}{}
\def\mathcolor#1#{\mathcoloraux{#1}}
\newcommand*{\mathcoloraux}[3]{%
  \protect\leavevmode
  \begingroup
    \color#1{#2}#3%
  \endgroup
}
\newcommand{\HSKeyword}[1]{\mathcolor{hsgold3}{\textbf{#1}}}
\newcommand{\HSNumeral}[1]{\mathcolor{hsred3}{#1}}
\newcommand{\HSChar}[1]{\mathcolor{hsred2}{#1}}
\newcommand{\HSString}[1]{\mathcolor{hsred2}{#1}}
\newcommand{\HSSpecial}[1]{\mathcolor{hsblue4}{#1}}
\newcommand{\HSSym}[1]{\mathcolor{hsblue4}{#1}}
\newcommand{\HSCon}[1]{\mathcolor{hsblue3}{\mathit{#1}}}
\newcommand{\HSVar}[1]{\mathcolor{hsblue5}{\mathit{#1}}}
\newcommand{\HSComment}[1]{\mathcolor{hsgold2}{\textit{#1}}}


%%% lhs2TeX parser does not recognize '*' 
%%% in kind annotations, it thinks it is a multiplication.



\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{textcomp}

%% Haskell snippet 
\newenvironment{myhaskell}
{
  \vspace{-0.35cm}
  \begin{center}
}
{
  \end{center}
  \vspace{-0.35cm}
}

%% Haskell snippet 
\newenvironment{myhaskellnv}
{
  \begin{center}
}
{
  \end{center}
}


\title{Generating Constrained Test Data using Datatype Generic Programming}

\author{C.R. van der Rest}

\supervisor{Dr. W.S. Swierstra \\ Dr. M.M.T. Chakravarty \\ Dr. A. Serrano Mena }

\begin{document}
\maketitle

%% Set up the front matter of our book
\frontmatter
\tableofcontents

\chapter{Declaration}
Thanks to family, supervisor, friends and hops!
\\ \\
I declare that this thesis has been composed solely by myself and that it has not been
submitted, in whole or in part, in any previous application for a degree. Except where
stated otherwise by reference or acknowledgment, the work presented is entirely my
own.

\chapter{Abstract}
The generation of suitable test data is an essential part of \emph{property based testing}. Obtaining test data is simple enough when there are no additional constraints, however things become more complicated once we require data with a richer structure, for example well-formed programs when testing a compiler. We observe that we can often describe constrained data as an \emph{indexed family}. By generating values of an indexed family that describes a set of constrained test data, we simultaneously obtain a way to generate the constrained data itself. To achieve this goal, we consider three increasingly expressive type universes: \emph{regular types}, \emph{indexed containers} and \emph{indexed descriptions}. We show how generators can be derived from codes in these universes, and for \emph{regular types} and \emph{indexed descriptions} we show that these derived generators are \emph{complete}. We implement the generic generator for indexed descriptions in Haskell, and use this implementation to generate constrained test data, such as well-typed lambda terms. 

%% Starts the mainmatter
\mainmatter

\chapter{Introduction}
This thesis concerns itself with the generation of complex test data in the context of property based testing specifically, and generic programming for indexed datatypes in general. 

\section{Problem Statement}

  In \emph{property based testing} is a technique in which the correctness of a program is asserted by defining properties that should hold over a program's output and behavior, and checking that those properties are true for a collection of input values. There exist many libraries for property based testing, of which QuickCheck \cite{claessen2011quickcheck} and SmallCheck \cite{runciman2008smallcheck} are perhaps the most notable in the realm of functional programming. 

  At first glance defining properties that capture the desired behavior of a program may seem like the most challenging aspect of property based testing. While this certainly can be difficult, one should not underestimate the effort that goes into generation of suitable test data. For example, suppose we are testing a function that operates on sorted lists. To do so, we would need a generator that produces sorted lists. Suppose we have a predicate that asserts sortedness: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{isSorted}\HSSym{::}\HSSpecial{\HSSym{[\mskip1.5mu} }\HSCon{Int}\HSSpecial{\HSSym{\mskip1.5mu]}}\HSSym{\to} \HSCon{Bool}{}\<[E]%
\\
\>[B]{}\HSVar{isSorted}\;\HSSpecial{\HSSym{[\mskip1.5mu} }\HSSpecial{\HSSym{\mskip1.5mu]}}{}\<[20]%
\>[20]{}\HSSym{\mathrel{=}}\HSCon{True}{}\<[E]%
\\
\>[B]{}\HSVar{isSorted}\;\HSSpecial{\HSSym{[\mskip1.5mu} }\HSVar{x}\HSSpecial{\HSSym{\mskip1.5mu]}}{}\<[20]%
\>[20]{}\HSSym{\mathrel{=}}\HSCon{True}{}\<[E]%
\\
\>[B]{}\HSVar{isSorted}\;\HSSpecial{(}\HSVar{x}\HSCon{\mathbin{:}}\HSVar{y}\HSCon{\mathbin{:}}\HSVar{xs}\HSSpecial{)}{}\<[20]%
\>[20]{}\HSSym{\mathrel{=}}\HSVar{x}\HSSym{\leq} \HSVar{y}\HSSym{\mathrel{\wedge}}\HSVar{isSorted}\;\HSSpecial{(}\HSVar{y}\HSCon{\mathbin{:}}\HSVar{xs}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  We can use this predicate as a precondition for some property (i.e. a function \ensuremath{\HSVar{prop}\HSSym{::}\HSSpecial{\HSSym{[\mskip1.5mu} }\HSCon{Int}\HSSpecial{\HSSym{\mskip1.5mu]}}\HSSym{\to} \HSCon{Bool}}) that expects a sorted list as its input. However, this causes some problems. 

\begin{tabbing}\ttfamily
~Test\char46{}QuickCheck\char62{}~quickCheck~\char40{}sorted~xs\char41{}~\char61{}\char61{}\char62{}~prop~xs\char41{}\\
\ttfamily ~\char42{}\char42{}\char42{}~Gave~up\char33{}~Passed~only~70~tests\char59{}~1000~discarded~tests\char46{}
\end{tabbing}

  QuickCheck was not able to find enough lists that satisfy the predicate sorted! As it turns out, only \emph{very few} random lists actually turn out to be sorted. The trouble does not stop there, since from those lists that QuickCheck is able to find that are sorted, most will only contain very few elements. This is simply a result of the fact that a small random list has a much higher probability of being sorted than a larger list. The way forward in this case is actually to define a custom generator that is specifically designed to produce sorted lists. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{gen\char95 sorted}\HSSym{::}\HSCon{Gen}\;\HSSpecial{\HSSym{[\mskip1.5mu} }\HSCon{Int}\HSSpecial{\HSSym{\mskip1.5mu]}}{}\<[E]%
\\
\>[B]{}\HSVar{gen\char95 sorted}\HSSym{\mathrel{=}}\HSVar{arbitrary}\HSSym{\bind} \HSVar{return}\HSSym{\mathbin{\circ}}\HSVar{diff}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSKeyword{where}\;{}\<[10]%
\>[10]{}\HSVar{diff}\HSSym{::}\HSSpecial{\HSSym{[\mskip1.5mu} }\HSCon{Int}\HSSpecial{\HSSym{\mskip1.5mu]}}\HSSym{\to} \HSSpecial{\HSSym{[\mskip1.5mu} }\HSCon{Int}\HSSpecial{\HSSym{\mskip1.5mu]}}{}\<[E]%
\\
\>[10]{}\HSVar{diff}\;\HSSpecial{\HSSym{[\mskip1.5mu} }\HSSpecial{\HSSym{\mskip1.5mu]}}{}\<[23]%
\>[23]{}\HSSym{\mathrel{=}}\HSSpecial{\HSSym{[\mskip1.5mu} }\HSSpecial{\HSSym{\mskip1.5mu]}}{}\<[E]%
\\
\>[10]{}\HSVar{diff}\;\HSSpecial{(}\HSVar{x}\HSCon{\mathbin{:}}\HSVar{xs}\HSSpecial{)}{}\<[23]%
\>[23]{}\HSSym{\mathrel{=}}\HSVar{x}\HSCon{\mathbin{:}}\HSVar{map}\;\HSSpecial{(}\HSSym{+}\HSVar{x}\HSSpecial{)}\;\HSSpecial{(}\HSVar{diff}\;\HSVar{xs}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  In this case, the custom generator is not too complicated. However, as the preconditions of our properties grow more complex, so do their generators. For example, when testing a compiler, well-formedness of input programs is often a precondition of the test data. Generating well-formed programs is hard. Even synthesizing well-typed lambda terms is a surprisingly tricky problem \cite{palka2011testing, grygiel2013counting, claessen2015generating}.

  We observe that the desired precondition of test data can often be expressed as using an \emph{indexed family}. For example, the following indexed family describes sortedness for lists: 

\includeagda{2}{sorted}

  Given a value of type \ensuremath{\HSCon{Sorted}\;\HSVar{xs}}, it is easy to convert it to a value of type \ensuremath{\HSCon{List}\;\HSCon{ℕ}}. This means that if we are able to generate values that inhabit an indexed family such as \ensuremath{\HSCon{Sorted}}, we are able to generate constrained test data. Some research has been done in this direction \cite{lampropoulos2017generating}, but a generic procedure for generation of indexed families does not exist yet in the literature. 

\section{Research Question and Goals}

  This thesis aims to work towards an answer to the following question: 

  \begin{center} \emph{
    How can we obtain constrained test data by generically deriving enumeration and/or sampling mechanisms for indexed datatypes?
  }\end{center}

  By obtaining a way to generically generate values of indexed families, we hope to be able to generate constrained test data without having to define custom generation procedures.

\section{Contributions}

  This thesis makes the following contributions: 

  \begin{itemize}
    \item 
      A formalization in Agda of enumerative generators for \emph{regular datatypes}, together with a proof that these generators satisfy a completeness property. 

    \item 
      A formalization in Agda of enumerative generators for inductive families that can be described as an \emph{indexed container}. 

    \item 
      A formalization in Agda of enumerative generators for inductive families that can be described as an \emph{indexed description}, together with a proof that they satisfy a completeness property. 

    \item 
      A small Haskell library that implements the enumerative generator for indexed description, and is able to generate constrained test data. 
  \end{itemize}

\section{Thesis Structure}

  This thesis is structured as follows: in chapter 2 we discuss some relevant 
  theoretical background and some of the work related to 
  this thesis. Chapters 3 through 5 describe various type universes, and show how we may derive 
  generators for any type in those universes. Additionally, we sketch how we may prove 
  that the associated enumerations are complete. Chapter 6 is concerned with 
  how we can implement these ideas in Haskell, and provide a comprehensive framework 
  for the generation of well formed programs. Finally, chapter 7 provides a discussion 
  of the work and lists some of the possible future work.

%% \section{Methodology}

%% \subsection{Agda Model}

%% \subsection{Haskell Library}

%% \subsection{Notational Conventions}

\chapter{Background \& Related Work}
In this section, we will briefly discuss some of the relevant theoretical background 
for this thesis. We assume the reader to be familiar with the general concepts of both 
Haskell and Agda, as well as functional programming in general. We shortly touch upon 
the following subjects:

\begin{itemize}
  \item
  \emph{Type theory} and its relationship with \emph{classical logic} through the 
  \emph{Curry-Howard correspondence}

  \item 
  Some of the more advanced features of the programming language \emph{Agda}, which we 
  use for the formalization of our ideas: \emph{Codata}, \emph{Sized Types} and \emph
  {Universe Polymorphism}. 

  \item 
  \emph{Datatype generic programming} using \emph{type universes} and the design 
  patterns associated with datatype generic programming.  
\end{itemize}

  We present this section as a courtesy to those readers who might not be familiar 
  with these topics; anyone experienced in these areas should feel free to skip ahead. 

\section{Type Theory}

  \emph{Type theory} is the mathematical foundation that underlies the \emph{type 
  systems} of many modern programming languages. In type theory, we reason about \emph\
  {terms} and their \emph{types}. We briefly introduce some basic concepts, and show 
  how they relate to our proofs in Agda. 

  \subsection{Intuitionistic Type Theory}

  In Intuitionistic type theory consists of terms, types and judgements $a : A$ 
  stating that terms have a certain type. Generally we have the following two finite 
  constructions: $\mathbb{0}$ or the \emph{empty type}, containing no terms, and 
  $\mathbb{1}$ or the \emph{unit type} which contains exactly $1$ term. Additionally,
  the \emph{equality type}, $=$, captures the notion of equality for both terms and 
  types. The equalit type is constructed from \emph{reflexivity}, i.e. it is 
  inhabited by one term $refl$ of the type $a = a$. 

  Types may be combined using three constructions. The \emph{function type}, $a 
  \rightarrow b$ is inhabited by functions that take an element of type $a$ as input 
  and produce something of type $b$. The \emph{sum type}, $a + b$ creates a type that 
  is inhabited by \emph{either} a value of type $a$ \emph{or} a 
  value of type $b$. The \emph{product type}, $a * b$, is inhabited by a pair of 
  values, one of type $a$ and one of type $b$. In terms of set theory, these 
  operations correspond respectively to functions, \emph{cartesian product} and \emph
  {tagged union}. 

  \subsection{The Curry-Howard Equivalence}

  The \emph{Curry-Howard equivalence} establishes an isomorphism between \emph
  {propositions and types} and \emph{proofs and terms} \cite{wadler2015propositions}. 
  This means that for any type there is a corresponding proposition, and any term 
  inhabiting this type corresponds to a proof of the associated proposition. Types and 
  propositions are generally connected using the mapping shown in \cref{tbl:chiso}.

\begin{table}[h]\label{tbl:chiso}
\begin{center}\begin{framed}
\begin{tabular}{ll}
\multicolumn{1}{c}{\textbf{Classical Logic}} & \textbf{Type Theory} \\ \hline \hline
False                                        & $\bot$               \\
True                                         & $\top$               \\
$P \vee Q$                                   & $P + Q$              \\
$P \wedge Q$                                 & $P * Q$              \\
$p \Rightarrow Q$                            & $P \rightarrow Q$                       
\end{tabular}
\caption{Correspondence between classical logic and type theory}
\end{framed}\end{center}
\end{table}

  \begin{example}

    We can model the proposition $P \wedge (Q \vee R) \Rightarrow (P \wedge Q) \vee (P 
    \wedge R)$ as a function with the following type: 

\includeagdanv{2}{tautologytype}

    We can then prove that this implication holds on any proposition by supplying a 
    definition that inhabits the above type: 

\includeagda{2}{tautologydef}

  \end{example}

  In general, we may prove any proposition that captured as a type by writing a 
  programin that inhabits that type. Allmost all constructs are readily translatable 
  from proposition logic, except boolean negation, for which there is no corresponding 
  construction in type theory. Instead, we model negation using functions to the empty 
  type $\bot$. That is, we can prove a property $P$ to be false by writing a function \
  $P \rightarrow \bot$. This essentially says that $P$ is true, we can derive a \
  contradiction, hence it must be false. Alowing us to prove many properties including negation. 
  
  \begin{example}

    For example, we might prove that a property 
    cannot be both true and false, i.e. $\forall\ P\ .\ \neg(P \wedge \neg P)$: 

\includeagdanv{2}{notpandnotp}

  \end{example}

  However, there are properties of classical logic which do not carry over well 
  through the Curry-Howard isomorphism. A good example of this is the \emph{law of 
  excluded middle}, which cannot be proven in type theory: 

\includeagda{2}{excludedmiddle}

  This implies that type theory is incomplete as a proof system, in the sense that 
  there exist properties wich we cannot prove, nor disprove. 

\subsection{Dependent Types}

  Dependent type theory allows the definition of types that depend on values. In 
  addition to the constructs introduced above, one can use so-called $\Pi$-types and 
  $\Sigma$-types. 
  $\Pi$-types capture the idea of \emph{dependent function types}, that is, functions 
  whose output type may depend on the values of its input. Given some type $A$ and a 
  family $P$ of types indexed by values of type $A$ (i.e. $P$ has type $A \rightarrow 
  Type$), $\Pi$-types have the following form: 

\begin{equation*}
\Pi_{(x : A)} P(x) \equiv (x : A) \rightarrow P(x) 
\end{equation*}

  In a similar spirit, $\Sigma$-types are ordered \textit{pairs} of which the type
  of the second value may depend on te first value of the pair:

\begin{equation*}
\Sigma_{(x : A)} P(x) \equiv (x : A) \times P(x) 
\end{equation*}

  The Curry-Howard equivalence extends to $\Pi$- and $\Sigma$-types as well: they 
  can be used to model universal and existential quantification \cite
  {wadler2015propositions} (\cref{chisodependent}).

\begin{table}[h]\label{tbl:chisodependent}
\begin{center}\begin{framed}
\begin{tabular}{ll}
\multicolumn{1}{c}{\textbf{Classical Logic}} & \textbf{Type Theory}    \\ \hline \hline
$\exists\ x\ .\ P\ x$                        & $\Sigma_{(x : A)} P(x)$ \\
$\forall\ x\ .\ P\ x$                        & $\Pi_{(x : A)} P(x)$                    
\end{tabular}
\caption{Correspondence between quantifiers in classical logic and type theory}
\end{framed}\end{center}
\end{table}

  \begin{example} 
  
    we might capture the relation between universal and negated existential 
    quantification ($\forall\ x\ .\ \neg P\ x \Rightarrow \neg \exists\ x\ .\ P\ x$) 
    as follows: 

\includeagdanv{2}{forallnottonotexists} 

  \end{example}

  The correspondence between dependent pairs and existential quantification quite \
  beautifullly illustrates the constructive nature of proofs in type theory; we prove 
  any existential property by presenting a term together with a proof that the 
  required property holds for that term. 

\section{Agda}

  Agda is a programming language based on Intuitionistic type theory\cite
  {norell2008dependently}. Its syntax is broadly similar to Haskell's, though Agda's 
  type system is arguably more expressive, since types may depend on term level 
  values. 

  Due to the aforementioned correspondence between types and propositions, any Agda 
  program we write is simultaneously a proof of the proposition associated with its 
  type. Through this mechanism, Agda serves a dual purpose as a proof assistent. 

\subsection{Universe Polymorphism}

  Contrary to Haskell, Agda does not have separate notions for \emph{types}, 
  \emph{kinds} and \emph{sorts}. Instead it provides an infinite hierarchy of 
  type universes, where level is a member of the next, i.e. \ensuremath{\HSCon{Set}\;\HSVar{n}\HSCon{\mathbin{:}}\HSCon{Set}\;\HSSpecial{(}\HSVar{n}\HSSym{+}\HSNumeral{1}\HSSpecial{)}}. 
  Agda uses this construction in favor of simply declaring \ensuremath{\HSCon{Set}\HSCon{\mathbin{:}}\HSCon{Set}} to avoid 
  the construction of contradictory statements through Russel's paradox. 

  This implies that every construction in Agda that ranges over some \ensuremath{\HSCon{Set}\;\HSVar{n}} can 
  only be used for values that are in \ensuremath{\HSCon{Set}\;\HSVar{n}}. It is not possible to define, for 
  example, a \ensuremath{\HSCon{List}} datatype that may contain both \emph{values} and \emph{types}
   for this reason. 

   We can work around this limitation by defining a \emph{universe polymorphic} 
   construction for lists: 

\includeagda{2}{upolylist}

  Allowing us to capture lists of types (such as \ensuremath{\HSCon{ℕ}\HSSym{∷}\HSCon{Bool}\HSSym{∷}\HSSpecial{\HSSym{[\mskip1.5mu} }\HSSpecial{\HSSym{\mskip1.5mu]}}}) and lists of 
  values (such as \ensuremath{\HSNumeral{1}\HSSym{∷}\HSNumeral{2}\HSSym{∷}\HSSpecial{\HSSym{[\mskip1.5mu} }\HSSpecial{\HSSym{\mskip1.5mu]}}}) using a single datatype. Agda allows for the 
  programmer to declare that \ensuremath{\HSCon{Set}\HSCon{\mathbin{:}}\HSCon{Set}} using the \ensuremath{\mbox{\enskip\{-\# OPTIONS --type-in-type  \#-\}\enskip}} 
  pragma. Throughout the development accompanying this thesis, we will refrain from 
  using this pragma wherever possible. The examples included in this thesis are often 
  not universe-polymorphic, since the universe level variables required often pollute 
  the code, and obfuscate the concept we are trying to convey. 

\section{Generic Programming and Type Universes}

  In \emph{Datatype generic programming}, we define functionality not for individual 
  types, but rather by induction on \emph{structure} of types. This means that generic 
  functions will not take values of a particular type as input, but a \emph{code} that 
  describes the structure of a type. Haskell's \ensuremath{\HSKeyword{deriving}} mechanism is a prime example 
  of this mechanism. Anytime we add \ensuremath{\HSKeyword{deriving}\;\HSCon{Eq}} to a datatype definition, GHC will, 
  in the background, convert our datatype to a structural representation, and use a 
  \emph{generic equality} to create 
  an instance of the \ensuremath{\HSCon{Eq}} typeclass for our type. 

\subsection{Design Pattern}\label{sec:tudesignpattern}

  Datatype generic programming often follows a common design pattern that is 
  independent of the structural representation of types involved. In general 
  we follow the following steps: 

  \begin{enumerate}
    \item
      First, we define a datatype \ensuremath{\HSCon{𝓤}} representing the structure of types, 
      often called a \emph{Universe}. 
    \item 
      Next, we define a semantics \ensuremath{\HSSym{⟦\char95 ⟧}\HSCon{\mathbin{:}}\HSCon{𝓤}\HSSym{→}\HSCon{K}} that associates codes in \ensuremath{\HSCon{𝓤}} 
      with an appropriate value of kind \ensuremath{\HSCon{K}}. In practice this is often a functorial 
      representation of kind \ensuremath{\HSCon{Set}\HSSym{→}\HSCon{Set}}.
    \item 
      Finally, we (often) define a fixed point combinator of type \ensuremath{\HSSpecial{(}\HSVar{u}\HSCon{\mathbin{:}}\HSCon{𝓤}\HSSpecial{)}\HSSym{→}\HSCon{Set}} 
      that calculates the fixpoint of \ensuremath{\HSSym{⟦}\HSVar{u}\HSSym{⟧}}. 
  \end{enumerate}

  This imposes the implicit requirement that if we want to represent some type 
  \ensuremath{\HSCon{T}} with a code \ensuremath{\HSVar{u}\HSCon{\mathbin{:}}\HSCon{𝓤}}, the fixpoint of \ensuremath{\HSVar{u}} should be isomorphic to \ensuremath{\HSCon{T}}. 

  Given these ingredients we have everything we need at hand to write generic 
  functions. Section $3$ of Ulf Norell's \emph{Dependently Typed Programming 
  in Agda} \cite{norell2008dependently} contains an in depth explanation of 
  how this can be done in Agda. We will only give a rough sketch of the most 
  common design pattern here. In general, a datatype generic function is supplied
  with a code \ensuremath{\HSVar{u}\HSCon{\mathbin{:}}\HSCon{𝓤}}, and returns a function whose type is dependent on the 
  code it was supplied with. 
  
  \begin{example}

    Suppose we are defining a generic procedure for decidable equality. We might use the following type signature for such a procedure:

\includeagdanv{2}{eqdef}

    If we now define \ensuremath{\HSSym{≟}} by induction over \ensuremath{\HSVar{u}}, we have a decision procedure 
    for decidable equality that may act on values on any type, provided their 
    structure can be described as a code in \ensuremath{\HSCon{𝓤}}. 

  \end{example}

\subsection{Example Universes}

  There exist many different type universes. We will give a short overview of 
  the universes used in this thesis here; they will be explained in more detail 
  later on when we define generic generators for them. The literature review in 
  \cref{sec:lituniverses} contains a brief discussion of type universes beyond 
  those used we used for generic enumeration. 

  \paragraph{Regular Types} 
    Although the universe of regular types is arguably 
    one of the simplest type universes, it can describe a wide variaty of 
    recursive algebraic datatypes \texttt{[citation]}, roughly corresponding to 
    the algebraic types in Haskell98. Examples of regular types are 
    \emph{natural numbers}, \emph{lists} and \emph{binary trees}. Regular types are 
    insufficient once we want to have a generic representation of mutually recursive 
    or indexed datatypes. 

  \paragraph{Indexed Containers}
    The universe of \emph{Indexed Containers} \cite{altenkirch2015indexed} 
    provides a generic representation of large class indexed datatypes by 
    induction on the index type. Datatypes we can describe using this universe 
    include \ensuremath{\HSCon{Fin}} (\cref{lst:deffin}), \ensuremath{\HSCon{Vec}} (\cref{lst:defvec}) and closed 
    lambda terms (\cref{lst:defwellscoped}).

  \paragraph{Indexed Descriptions}
    Using the universe of \emph{Indexed Descriptions} \cite{dagand2013cosmology}
    we can represent arbitrary indexed datatypes. This allows us to describe 
    datatypes that are beyond what can be described using indexed containers, 
    that is, datatypes with recursive subtrees that are interdependent or whose 
    recursive subtrees have indices that cannot be uniquely determined from the 
    index of a value. 

    In this section, we discuss some of the existing literature that is relevant in the 
domain of generating test data for property based testing. We take a look at some 
existing testing libraries, techniques for generation of constrained test data, and a 
few type universes beyond those we used that aim to describe (at least a subset of) 
indexed datatypes. 

\section{Libraries for Property Based Testing}

  \textit{Property Based Testing} aims to assert properties that universally hold for 
  our programs by parameterizing tests over values and checking them against a 
  collection of test values. Libraries for property based testing often include some 
  kind of mechanism to automatically generate collections of test values. Existing 
  tools take different approaches towards generation of test data: \textit{QuickCheck} 
  \cite{claessen2011quickcheck} randomly generates values within the test domain, 
  while \textit{SmallCheck} \cite{runciman2008smallcheck} and \textit{LeanCheck} \cite
  {matela2017tools} exhaustively enumerate all values in the test domain up to a 
  certain point. There exist many libraries for property based testing. For brevity we 
  constrain ourselves here to those that are relevant in the domain of functional 
  programming and/or haskell. 

\section{Generating Constrained Test Data}\label{genconstrainedtd}

  Defining a suitable generation of test data for property based testing potentially very challenging, independent of whether we choose to sample from 
  or enumerate the space of test values. Writing generators for mutually recursive 
  datatypes with a suitable distribution is especially challenging. 
    
  We run into prolems when we desire to generate test data for properties with a 
  precondition. If a property's precondition is satisfied by few input values, it 
  becomes unpractical to test such a property by simply generating random input data, 
  and using rejection sampling to filter out those values that satisfy the desired 
  precondition. We will often end up with very few testcases, and we will end up with 
  a skewed distribution favoring those test values that have the largest probability 
  to be picked at random (often these are the simplest values that satisfy the 
  precondition). 
  
  The usual solution to this problem is to define a custom test data generator that 
  only produces data that satisfies the precondition. There are cases in which this is 
  not too difficult, however once we require more complex test data, such as 
  well-formed programs, this is quite a challenging task. 

\subsection{W-Types}\label{sec:wtypes}

  Introduced by Per Martin-Löf \cite{martin1984intuitionistic}, \emph{W-types} 
  abstract over tree-shaped data structures, such as natural numbers or binary trees. 
  W-types are defined by their \emph{shape} and \emph{position}, describing 
  respectively the set of constructors and the number of recursive positions. 

  Perhaps the best known definition of W-types is using an inductive datatype, with 
  one constructor taking a shape value, and a function from position to W-type: 

\includeagda{3}{winductive}

  However, we can use an alternate definition where we separate the universe into 
  codes, semantics and a fixpoint operation (listing \ref{lst:wtypes})

\includeagdalisting{3}{wtypes}{W-types defined with separate codes and semantics}
{lst:wtypes}

  We take this redundant step for two reasons: 

  \begin{enumerate}
    \item To unify the definition of W-types with the design pattern for type 
    universes we described in \cref{sec:tudesignpattern}. 

    \item To emphasize the the similarities between W-types, and the universe of 
    indexed containers, which will be further discussed in (TODO ref chapter 6)
  \end{enumerate}

  \begin{example} 

    Let us look at the natural numbers (listing \ref{lst:defnat}) as an example. We 
    can define the following W-type that is isomorphic to \ensuremath{\HSCon{ℕ}}:

\includeagdanv{3}{wnat}

    The \ensuremath{\HSCon{ℕ}} type has two constructors, hence our shape is a finite type with two 
    inhabitants (\ensuremath{\HSCon{Bool}} in this case). We then map \ensuremath{\HSVar{false}} to the empty type, 
    signifying that \ensuremath{\HSVar{zero}} has no recursive subtrees, and \ensuremath{\HSVar{true}} to the unit type, 
    denoting that \ensuremath{\HSVar{suc}} has one recursive subtree. The isomorphism between \ensuremath{\HSCon{ℕ}} and \ensuremath{\HSCon{Wℕ}}
     is established in listing \ref{wnatiso}. 

  \end{example}

\includeagdalisting{3}{wnatiso}{Isomorphism between \ensuremath{\HSCon{ℕ}} and \ensuremath{\HSCon{Wℕ}}}{lst:wnatiso}



\chapter{Generic Generators for Regular types}

  A large class of recursive algebraic data types can be described with the universe 
  of \emph{regular types}. In this section we lay out this universe, together with its 
  semantics, and describe how we may define functions over regular types by induction 
  over their codes. We will then show how this allows us to derive from a code a 
  generic generator that produces all values of a regular type. We sketch how we can 
  prove that these generators are indeed complete. 

\section{The universe of regular types}

  Though the exact definition may vary across sources, the universe of regular types 
  is generally regarded to consist of the \emph{empty type} (or $\mathbb{0}$), the 
  unit type (or $\mathbb{1}$) and constants types. It is closed under both products 
  and coproducts \footnote{This roughly corresponds to datatypes in Haskell 98}. We 
  can define a datatype for this universe in Agda as shown in lising \ref{lst:regular}, 
  with its associated semantics of type \ensuremath{\HSCon{Reg}\HSSym{\to} \HSCon{Set}\HSSym{\to} \HSCon{Set}} shown in listing \ref{lst:regsem}.

\includeagdalisting{5}{regular}{The universe of regular types}{lst:regular}

  The semantics of the universe of regular types map a code to a functorial representation of the datatype it describes, commonly 
  known as its \emph{pattern functor}. The datatype that is represented by a code is 
  isomorphic to the least fixpoint of its pattern functor. We fix pattern functors 
  using the following fixpoint combinator: 

\includeagda{5}{regularfix}

\includeagdalisting{5}{regularsemantics}{Semantics of the universe of regular types}
{lst:regsem}

  \begin{example}

    The type of natural numbers (see listing \ref{lst:defnat}) 
    exposes two constructors: the nullary constructor \ensuremath{\HSVar{zero}}, and the unary 
    constructor \ensuremath{\HSVar{suc}} that takes one recursive argument. We may thus view this type as 
    a coproduct (i.e. choice) of either a \emph{unit type} or a \emph{recursive 
    subtree}: 

\includeagdanv{5}{natregular}

    We convince ourselves that \ensuremath{\HSCon{ℕ'}} is indeed equivalent to \ensuremath{\HSCon{ℕ}} by defining conversion 
    functions, and showing their composition is extensionally equal to the identity 
    function, shown in listing \ref{lst:natiso}. 

  \end{example}

\includeagdalisting{5}{natiso}{Isomorphism between \ensuremath{\HSCon{ℕ}} and \ensuremath{\HSCon{ℕ'}}}{lst:natiso}

  We may then say that a type is regular if we can provide a proof that it is 
  isomorphic to the fixpoint of some \ensuremath{\HSVar{c}} of type \ensuremath{\HSCon{Reg}}. We use a record to capture 
  this notion, consisting of a code and an value that witnesses the isomorphism.

\includeagda{5}{regularrecord}

  By instantiating \ensuremath{\HSCon{Regular}} for a type, we may use any generic functionality that is defined over regular types. 

\subsection{Non-regular data types}

  Although there are many algebraic datatypes that can be described in the universe 
  of regular types, some cannot. Perhaps the most obvious limitation the is lack of 
  ability to capture data families indexed with values. The regular universe 
  imposes the implicit restriction that a datatype is uniform in the sense that all 
  recursive subtrees are of the same type. Indexed families, such as \ensuremath{\HSCon{Vec}} and \ensuremath{\HSCon{Fin}}, on the other hand allow for 
  recursive subtrees to have a structure that is different from the structure of the 
  datatype they are a part of. Furethermore, any family of mutually recursive datatypes cannot be described as a 
  regular type; again, this is a result of the restriction that recursive positions 
  allways refer to a datatype with the same structure. 

\section{Generic Generators for regular types}

  We can derive generators for all regular types by induction over their associated 
  codes. Furthermore, we will show in section \cref{regularproof} that, once 
  interpreted as enumerators, these generators are complete; i.e. any value will 
  eventually show up in the enumerator.

\subsection{Defining functions over codes}

  If we apply the approach described in \cref{sec:tudesignpattern} without care, we 
  run into problems. Simply put, we cannot work with values of type \ensuremath{\HSCon{Fix}\;\HSVar{c}}, since 
  this implicitly imposes the restriction that any \ensuremath{\HSCon{I}} in \ensuremath{\HSVar{c}} refers to \ensuremath{\HSCon{Fix}\;\HSVar{c}}. 
  However, as we descend into recursive calls, the code we are working with changes, 
  and with it the type associated with recursive positions. For example: the \ensuremath{\HSCon{I}} in (\ensuremath{\HSCon{U}\HSSym{⊕}\HSCon{I}}) refers to values of type \ensuremath{\HSCon{Fix}\;\HSSpecial{(}\HSCon{U}\HSSym{⊕}\HSCon{I}\HSSpecial{)}}, not \ensuremath{\HSCon{Fix}\;\HSCon{I}}. We need to make a 
  distinction between the code we are currently working on, and the code that describes the type of recursive positions. 
  For this reason, we cannot define the generic generator, \ensuremath{\HSVar{deriveGen}}, with the following type signature. We observe that \ensuremath{\HSSym{⟦}\HSVar{c}\HSSym{⟧}\HSSpecial{(}\HSCon{Fix}\;\HSVar{c}\HSSpecial{)}} is isomorphic to \ensuremath{\HSCon{Fix}\;\HSVar{c}}, thus if we define a function \ensuremath{\HSVar{deriveGen}} with the following type signature, and supply it with two equal codes, the resulting generator produces elements that are isomorphic to values of type \ensuremath{\HSCon{Fix}\;\HSVar{c}}. 

\includeagda{5}{genericgen2}

  This intermediate step allows us to perform induction over the first input code, while still being able to have 
  recursive positions reference the correct \emph{top-level code}. The 
  first and second type parameter of \ensuremath{\HSCon{Gen}} are different. This is intentional, as we 
  would otherwise not be able to use the $\mu$ constructor to mark recursive 
  positions.  

\subsection{Composing generic generators}

  Now that we have the correct type for \ensuremath{\HSVar{deriveGen}} in place, we can start defining 
  it. Starting with the cases for \ensuremath{\HSCon{Z}} and \ensuremath{\HSCon{U}}: 

\includeagda{5}{genericgenZU}

  Both cases are trivial. In case of the \ensuremath{\HSCon{Z}} combinator, we yield a generator that 
  produces no elements. As for the \ensuremath{\HSCon{U}} combinator, \ensuremath{\HSSym{⟦}\HSCon{U}\HSSym{⟧}\HSSpecial{(}\HSCon{Fix}\;\HSVar{c'}\HSSpecial{)}} equals \ensuremath{\HSSym{⊤}}, so we 
  need to return a generator that produces all inhabitants of \ensuremath{\HSSym{⊤}}. This is simply done 
  by lifting the single value \ensuremath{\HSVar{tt}} into the generator type. 

  In case of the \ensuremath{\HSCon{I}} combinator, we cannot simply use the $\mu$ constructor right 
  away. In this context, $\mu$ has the type \ensuremath{\HSCon{Gen}\;\HSSpecial{(}\HSSym{⟦}\HSVar{c'}\HSSym{⟧}\HSSpecial{(}\HSCon{Fix}\;\HSVar{c'}\HSSpecial{)}\HSSpecial{)}\;\HSSpecial{(}\HSSym{⟦}\HSVar{c'}\HSSym{⟧}\HSSpecial{(}\HSCon{Fix}\;\HSVar{c'}\HSSpecial{)}\HSSpecial{)}}
  . However, since \ensuremath{\HSSym{⟦}\HSCon{I}\HSSym{⟧}\HSSpecial{(}\HSCon{Fix}\;\HSVar{c}\HSSpecial{)}} equals \ensuremath{\HSCon{Fix}\;\HSVar{c}}, the types do not align. We need 
  to map the \ensuremath{\HSCon{In}} constructor over $\mu$ to fix this: 

\includeagda{5}{genericgenI}

  Moving on to products and coproducts: with the correct type for \ensuremath{\HSVar{deriveGen}} in place,
   we can define their generators quite easily by recursing on the left and right 
   subcodes, and combining their results using the appropriate generator combinators: 

\includeagda{5}{genericgenPCOP}

  Although defining \ensuremath{\HSVar{deriveGen}} constitutes most of the work, we are not quite there 
  yet. Since the the \ensuremath{\HSCon{Regular}} record expects an isomorphism with \ensuremath{\HSCon{Fix}\;\HSVar{c}}, we still 
  need to wrap the resulting generator in the \ensuremath{\HSCon{In}} constructor: 

\includeagda{5}{genericgenFinal}

  The elements produced by \ensuremath{\HSVar{genericGen}} can now readily be transformed into the 
  required datatype through an appropriate isomorphism. 

  \begin{example}

    We derive a generator for natural numbers by invoking \ensuremath{\HSVar{genericGen}} on the 
    appropriate code \ensuremath{\HSCon{U}\HSSym{⊕}\HSCon{I}}, and applying the isomorphism defined in listing \ref
    {natiso} to its results: 

\includeagdanv{5}{genericgenNat}

  \end{example}

  In general, we can derive a generator for any type \ensuremath{\HSCon{A}}, as long as there is an 
  instance argument of the type \ensuremath{\HSCon{Regular}\;\HSCon{A}} in scope: 

\includeagda{5}{isogen}

\section{Constant Types}

  In some cases, we describe datatypes as a compositions of other datatypes. An 
  example of this would be lists of numbers, \ensuremath{\HSCon{List}\;\HSCon{ℕ}}. Our current universe definition 
  is not expressive enough to do this. 
  
  \begin{example}

    Given the code representing natural numbers (\ensuremath{\HSCon{U}\HSSym{⊕}\HSCon{I}}) and lists (\ensuremath{\HSCon{U}\HSSym{⊕}\HSSpecial{(}\HSCon{C}\HSSym{⊗}\HSCon{I}\HSSpecial{)}}, 
    where \ensuremath{\HSCon{C}} is a code representing the type of elements in the list), we might be 
    tempted to try and replace \ensuremath{\HSCon{C}} with the code for natural numbers in the code for 
    lists: 

  \includeagdanv{5}{natlist}

    This code does not describe lists of natural numbers. The problem here is that the 
    two recursive positions refer to the \emph{same} code, which is incorrect. We need 
    the first \ensuremath{\HSCon{I}} to refer to the code of natural numbers, and the second \ensuremath{\HSCon{I}} to refer 
    to the entire code. 

  \end{example}

\subsection{Definition and Semantics}

  In order to be able to refer to other recursive datatypes, the universe of regular 
  types often includes a constructor marking \emph{constant types}: 

  The \ensuremath{\HSCon{K}} constructor takes one parameter of type \ensuremath{\HSCon{Set}}, marking the type it 
  references. The semantics of \ensuremath{\HSCon{K}} is simply the type it carries: 

  \begin{example}
    
    Given the addition of \ensuremath{\HSCon{K}}, we can now define a code that represents lists of 
    natural numbers: 

\includeagdanv{5}{natlist2}

    With the property that \ensuremath{\HSVar{listℕ}\HSSym{≃}\HSCon{List}\;\HSCon{ℕ}}. 

  \end{example}

\subsection{Generic Generators for Constant Typse}\label{sec:genericgenreg}

  When attempting to define \ensuremath{\HSVar{deriveGen}} on \ensuremath{\HSCon{K}\;\HSVar{s}}, we run into a problem. We need to 
  return a generator that produces values of type \ensuremath{\HSVar{s}}, but we have no information 
  about \ensuremath{\HSVar{s}} whatsoever, apart from knowing that it lies in \ensuremath{\HSCon{Set}}. This is a problem, 
  since we cannot derive generators for arbitrary values in \ensuremath{\HSCon{Set}}. This leaves us with 
  two options: either we restrict the types that \ensuremath{\HSCon{K}} may carry to those types for 
  which we can generically derive a generator, or we require the programmer to supply 
  a generator for every constant type in a code. We choose the latter, since it has 
  the advantage of being more flexible. 

  We have the programmer supply the necessary generators by defining a \emph{metadata} 
  structure, indexed by a code, that carries additional information for every \ensuremath{\HSCon{K}} 
  constructor used. We then parameterize \ensuremath{\HSVar{deriveGen}} with a metadata structure, 
  indexed by the code we are inducting over. The definition of the metadata structure 
  is shown in listing \ref{lst:mdstructure}. 

\includeagdalisting{5}{mdstructure}{Metadata structure carrying additional information 
for constant types}{lst:mdstructure}

  We then adapt the type of \ensuremath{\HSVar{deriveGen}} to accept a parameter containing the required 
  metadata structure: 

\includeagda{5}{derivegenKTy} 

  We then define \ensuremath{\HSVar{deriveGen}} as follows for constant types. All cases for existing 
  constructors remain the same. 

\includeagda{5}{derivegenKCase}

\section{Complete Enumerators For Regular Types}

  By applying the \ensuremath{\HSVar{toList}} interpretation shown in listing \ref{lst:tolist} to our 
  generic generator for regular types we obtain a complete enumeration for regular 
  types. Obviously, this relies on the programmer to supply complete generators for 
  all constant types referred to by a code. 

  We formulate the desired completeness property as follows: \textit{for every code c 
  and value x it holds that there is an n such that x occurs at depth n in the 
  enumeration derived from c}. In Agda, this amounts to proving the following 
  statement: 

\includeagda{5}{genericgencomplete}

  Just as was the case with deriving generators for codes, we need to take into the 
  account the difference between the code we are currently working with, and the top 
  level code. To this end, we generalize the previous statement slightly. 

\includeagda{5}{derivegencomplete}

  If we invoke this lemma with two equal codes, we may leverage the fact that \ensuremath{\HSCon{In}} is 
  bijective to obtain a proof that \ensuremath{\HSVar{genericGen}} is complete too. The key observation 
  here is that mapping a bijective function over a complete generator results in 
  another complete generator. 

  The completeness proof roughly follows the following steps: 

  \begin{itemize}

    \item 
      First, we prove completeness for individual generator combinators 

    \item 
      Next, we assemble a suitable metadata structure to carry the required proofs 
      for constant types in the code. 

    \item 
      Finally, we assemble the individual components into a proof of the statement 
      above. 

  \end{itemize}

\subsection{Combinator Correctness}

  We start our proof by asserting that the used combinators are indeed complete. That 
  is, we show for every constructor of \ensuremath{\HSCon{Reg}} that the generator we return in \ensuremath{\HSVar{deriveGen}} produces all elements of the interpretation of that constructor. In the 
  case of \ensuremath{\HSCon{Z}} and \ensuremath{\HSCon{U}}, this is easy. 

\includeagda{5}{derivegencompleteZU}

  The semantics of \ensuremath{\HSCon{Z}} is the empty type, so any generator producing values of type \ensuremath{\HSSym{⊥}}
   is trivially complete. Similarly, in the case of \ensuremath{\HSCon{U}} we simply need to show that 
   interpreting \ensuremath{\HSVar{pure}\;\HSVar{tt}} returns a list containing \ensuremath{\HSVar{tt}}. 

  Things become a bit more interesting once we move to products and coproducts. In the 
  case of coproducts, we know the following equality to hold, by definition of both \ensuremath{\HSVar{toList}} and \ensuremath{\HSVar{deriveGen}}: 

\includeagda{5}{tolistcopeq}

  Basically, this equality unfolds the \ensuremath{\HSVar{toList}} function one step. Notice how the 
  generators on the left hand side of the equation are \emph{almost} the same as the 
  recursive calls we make. This means that we can prove completeness for coproducts by 
  proving the following lemmas, where we obtain the required completeness proofs by 
  recursing on the left and right subcodes of the coproduct. 

\includeagda{5}{mergecomplete}

  Similarly, by unfolding the toList function one step in the case of products, we get 
  the following equality:

\includeagda{5}{tolistpeq}

  We can prove the right hand side of this equality by proving the following lemma 
  about the applicative instance of lists:

\includeagda{5}{apcomplete}

  Again, the preconditions of this lemma can be obtained by recursing on the left and 
  right subcodes of the product. 

\subsection{Completeness for Constant Types}

  Since our completeness proof relies on completeness of the generators for constant 
  types, we need the programmer to supply a proof that the supplied generators are 
  indeed complete. To this end, we add a metadata parameter to the type of \ensuremath{\HSVar{deriveGen}}
  -\ensuremath{\HSVar{complete}}, with the following type: 

\includeagda{5}{proofinfotype}

  In order to be able to use the completeness proof from the metadata structure in the 
  \ensuremath{\HSCon{K}} branch of \ensuremath{\HSVar{deriveGen}}-\ensuremath{\HSCon{Complete}}, we need to be able to express the relationship 
  between the metadata structure used in the proof, and the metadata structure used by 
  \ensuremath{\HSVar{deriveGen}}. To do this, we need a way to transform the type of information that is 
  carried by a value of type \ensuremath{\HSCon{KInfo}}: 

\includeagda{5}{kinfomap}

  Given the definition of \ensuremath{\HSCon{KInfo}}-\ensuremath{\HSVar{map}}, we can take the first projection of the 
  metadata input to \ensuremath{\HSVar{deriveGen}}-\ensuremath{\HSCon{Complete}}, and use the resulting structure as input 
  to \ensuremath{\HSVar{deriveGen}}: 

\includeagda{5}{proofinfotype}

  This amounts to the following final type for \ensuremath{\HSVar{deriveGen}}-\ensuremath{\HSCon{Complete}}, where \ensuremath{\HSSym{◂}\HSVar{m}} = \ensuremath{\HSCon{KInfo}}-\ensuremath{\HSVar{map}\;\HSVar{proj₁}\;\HSVar{m}}:  

\includeagda{5}{derivegenwithmd}

  Now, with this explicit relation between the completeness proofs and the generators 
  given to \ensuremath{\HSVar{deriveGen}}, we can simply retrun the proof contained in the metadata of 
  the \ensuremath{\HSCon{K}} branch. 
  
\subsection{Generator Monotonicity}

  The lemma \ensuremath{\HSSym{×}}-\ensuremath{\HSVar{complete}} is not enough to prove completeness in the case of 
  products. We make two recursive calls, that both return a dependent pair with a 
  depth value, and a proof that a value occurs in the enumeration at that depth. 
  However, we need to return just such a dependent pair stating that a pair of both 
  values does occur in the enumeration at a certain depth. The question is what depth 
  to use. The logical choice would be to take the maximum of both depths. This comes 
  with the problem that we can only combine completeness proofs when they have the 
  same depth value. 

  For this reason, we need a way to transform a proof that some value \ensuremath{\HSVar{x}} occurs in 
  the enumeration at depth \ensuremath{\HSVar{n}} into a proof that \ensuremath{\HSVar{x}} occurs in the enumeration at 
  depth \ensuremath{\HSVar{m}}, given that $n \leq m$. In other words, the set of values that occurs in 
  an enumeration monotoneously increases with the enumeration depth. To finish our 
  completeness proof, this means that we require a proof of the following lemma: 

\includeagda{5}{derivegenmonotone}

  We can complete a proof of this lemma by using the same approach as for the 
  completeness proof. 

\subsection{Final Proof Sketch}

  By bringing all these elements together, we can prove that \ensuremath{\HSVar{deriveGen}} is complete 
  for any code \ensuremath{\HSVar{c}}, given that the programmer is able to provide a suitable 
  metadatastructure. We can transform this proof into a proof that \ensuremath{\HSVar{isoGen}} returns a 
  complete generator by observing that any isomorphism \ensuremath{\HSCon{A}\HSSym{≃}\HSCon{B}} establishes a bijection 
  between the types \ensuremath{\HSCon{A}} and \ensuremath{\HSCon{B}}. Hence, if we apply such an isomorphism to the 
  elements produced by a generator, completeness is preserved. 

  We have the required isomorphism readily at our disposal in \ensuremath{\HSVar{isoGen}}, since it is 
  contained in the instance argument \ensuremath{\HSCon{Regular}\;\HSVar{a}}. This allows us to have \ensuremath{\HSVar{isoGen}} 
  return a completeness proof for the generator it derives: 

\includeagda{5}{isogenproven}

  With which we have shown that if a type is regular, we can derive a complete 
  generator producing elements of that type. 

\chapter{Deriving Generators for Indexed Containers}
  This chapter discusses the universe of \emph{indexed containers} \cite{altenkirch2015indexed}, which provide a generic framework to describe those datatypes that can be defined by induction on their index type. Examples of datatypes we can describe using this universe include finite types \ref{}, vectors \ref{} and well-scoped lambda terms. In this chapter, we give the definition for this universe together with a few examples, and show how a generic generator may be derived for indexed containers. 

\section{Universe Description}

  We choose to follow the representation used by Dagand in \emph{The Essence Of Ornaments} \cite{dagand2017essence}, which provides an excellent introduction to indexed containers, alongside numerous examples. Just as in the previous chapter, we follow the pattern of first defining a datatype describing codes before giving the semantics and fixpoint operation. 

\subsection{Definition}

  Recall our definition of \emph{W-types} in \cref{sec:wtypes}. We purposefully split the canonical definition into three separate definitions for codes, semantics and fixpoint operation. If we consider the datatype describing codes in the universe of indexed descriptions (listing \ref{lst:signatures}), their similarities become clear. Signatures consist of a triple of \emph{operations}, \emph{arities} and \emph{typing discipline} .

\includeagdalisting{6}{signature}{Signatures}{lst:signatures}

  The operations of a signature correspond to a W-type's \emph{shape}, describing the set of available operations. The major difference is that the operations in a signature are parameterized over the index type. Similarly, arity corresponds to position in a W-type, describing the set of recursive subtrees for a given operation. Again, a signature's arity is parameterized over the index type. The typing discipline maps arities to the indices of the corresponding subtrees. 

  The semantics of a signature is, just as for a W-type, a dependent pair, with the first element being a choice of operation, and the second element a function mapping arities to an appropriate recursive type. Contrary to the semantics of a W-type, which maps a code to a value in \ensuremath{\HSCon{Set}\HSSym{\to} \HSCon{Set}}, the semantics of a signature are parameterized over the index type, meaning they map a signature to a value in \ensuremath{\HSSpecial{(}\HSCon{I}\HSSym{\to} \HSCon{Set}\HSSpecial{)}\HSSym{\to} \HSSpecial{(}\HSCon{I}\HSSym{\to} \HSCon{Set}\HSSpecial{)}}. The semantics are shown in listing \ref{lst:sigmtheory}. 

\includeagdalisting{6}{sigmtheory}{The semantics of a signature}{lst:sigmtheory}

  Consequently, the fixpoint operation needs to be lifted from \ensuremath{\HSCon{Set}} to \ensuremath{\HSCon{I}\HSSym{\to} \HSCon{Set}} as well. The required adaptation follows naturally from the definition of the semantics: 

\includeagda{6}{sigfix}

  It is worth noting that, since \ensuremath{\HSCon{Set}\HSSym{≅}\HSSym{⊤}\HSSym{\to} \HSCon{Set}}, we can describe non-indexed datatypes as an indexed container by choosing \ensuremath{\HSSym{⊤}} as the index type. More precisely, there exists a bijection between W-types and signatures indexed with the unit type, such that for every W-type, its interpretation is isomorphic to the interpretation of the corresponding signature, and vice versa. 
  
\subsection{Example Signatures}

  Let us now consider a few examples of datatypes represented as a signature. 

  \begin{example}

    We start by defining a suitable set of operations. The \ensuremath{\HSCon{ℕ}} datatype has two constructor, so we return a type with two inhabitants. We use \ensuremath{\HSSym{⊤}} as the index of the signature, since \ensuremath{\HSCon{ℕ}} is a non-indexed datatype.

\includeagdanv{6}{natop}

    Next, we map each of those operations to the right arity. The \ensuremath{\HSVar{zero}} constructor has no recursive branches, so its arity is the empty type (\ensuremath{\HSSym{⊥}}), while the \ensuremath{\HSVar{suc}} constructor has a single recursive argument, so its arity is the unit type (\ensuremath{\HSSym{⊤}}). 

\includeagdanv{6}{natar}

    Since the index type has only one inhabitant, the associated typing discipline just returns \ensuremath{\HSVar{tt}} in all cases. We bring all these elements together into a single signature, for which we can show that its fixpoint is isomorphic to \ensuremath{\HSCon{ℕ}}.

\includeagdanv{6}{natsig}

  \end{example}

  The signature for natural numbers is quite similar to how we would represent them as a W-type. This example, however, does not tell us much about how signatures enable us to represent indexed datatypes, so let us look at another example. 

  \begin{example}

    We consider the type of finite sets (listing \ref{lst:deffin}). Contrary to natural numbers, the set of available operations varies with different indices. That is, \ensuremath{\HSCon{Fin}\;\HSNumeral{0}} is uninhabited, so the set of operations associated with index \ensuremath{\HSNumeral{0}} is empty. A value of type \ensuremath{\HSCon{Fin}\;\HSSpecial{(}\HSVar{suc}\;\HSVar{n}\HSSpecial{)}} can be constructed using both \ensuremath{\HSVar{suc}} and \ensuremath{\HSVar{zero}}, hence the set of associated operations has two elements: 

\includeagdanv{6}{finop}

    The arity of the \ensuremath{\HSCon{Fin}} type is exactly the same as the arity of \ensuremath{\HSCon{ℕ}}, with the exception of an absurd pattern in the case of index \ensuremath{\HSVar{zero}}. 

\includeagdanv{6}{finar}

    Recall the type of the \ensuremath{\HSVar{suc}} constructor: \ensuremath{\HSCon{Fin}\;\HSVar{n}\HSSym{\to} \HSCon{Fin}\;\HSSpecial{(}\HSVar{suc}\;\HSVar{n}\HSSpecial{)}}. The index of the recursive argument is one less than the index of the constructed value. The typing discipline describes this relation between index of the constructed value, and indices of recursive arguments. In the case of \ensuremath{\HSCon{Fin}}, this means that we map \ensuremath{\HSVar{suc}\;\HSVar{n}} to \ensuremath{\HSVar{n}}, if the index is greater than \ensuremath{\HSNumeral{0}}, and the operation corresponding to the \ensuremath{\HSVar{suc}} constructor is selected. 

\includeagdanv{6}{finty}

    Again, we combine operations, arity and typing into a signature: 

\includeagdanv{6}{finsig}

  \end{example}

  One thing to keep in mind while defining signatures for types is that part of their semantics is a dependent function type. This means that proving an isomorphism between a signature and the type it represents requires some extra work. More specifically, we need to postulate a variation of \emph{extensional equality} for function types: 

\includeagda{6}{funext} 

  One aspect we have not yet addressed is how to represent parameterized types, such as \ensuremath{\HSCon{Vec}\;\HSVar{a}} (listing \ref{lst:defvec}). Indexed containers do not have an explicit way to refer to other types, such as is the case with regular types, but rather include this kind of information as part of a type's operations. 

  \begin{example}

    We consider the \ensuremath{\HSCon{Vec}} type as an example, defining the following operations: 

\includeagdanv{6}{vecop}

    Notice that we map \ensuremath{\HSVar{suc}\;\HSVar{n}} to \ensuremath{\HSCon{A}}, indicating that the \ensuremath{\HSSym{∷}} constructor requires an argument of type \ensuremath{\HSCon{A}}. The remainder of the signature is then quite straightforward: 

\includeagdanv{6}{vecsig}

  \end{example}

\section{Generic Generators for Indexed Containers}

  In order to be able to derive generators from signatures, there are two additional steps we need to take: restricting the set of possible operations and arities, and defining \emph{co-generators} for regular types. 

\subsection{Restricting Operations and Arities}
  
  The set of operations of a signature, \ensuremath{\HSCon{Op}}, is a value in \ensuremath{\HSCon{Set}}. This implies that we have no way to generate values of type \ensuremath{\HSCon{Op}\;\HSVar{i}} without any further input of the programmer. The same problem occurs with arities. We solve this problem by restricting operations and arities to regular types. By doing this, we can reuse the generators we defined for regular types to generate operations and arities. This leads to the slightly altered variation on indexed containers shown in listing (\ref{lst:sigreg}), where \ensuremath{\HSCon{FixR}} and \ensuremath{\HSCon{InR}} denote the fixpoint operation for regular types. The fixpoint operation for signatures remains the same. 

\includeagdalisting{6}{sigreg}{Indexed containers with restricted operations and arities}{lst:sigreg}

  This implies that the definition of signatures changes slightly as well. 

  \begin{example}

    We use the following operation, arity and typing to describe the \ensuremath{\HSCon{Fin}} type as a restricted signature:

\includeagdanv{6}{sigfinreg}

    This definition does not differ too much from the previous one, except that we now pattern match on the fixpoint of some code in \ensuremath{\HSCon{Reg}} instead of directly on the operation or arity. 

  \end{example}

\subsection{Generating Function Types}

  To derive a generator from a signature, we need, in addition to generic generators for regular types, a way to generate function types whose input argument is a regular type. That is, we need to define the following function: 

\includeagda{6}{cogenerate}

  We draw inspiration from SmallCheck's \cite{runciman2008smallcheck} \ensuremath{\HSCon{CoSeries}} typeclass, for which instances can be automatically derived. Co-generators for constant types are to be supplied by a programmer using a metadata structure; we choose to not make this explicit in the type signature. An example definition of \ensuremath{\HSVar{cogenerate}} is included in listing \ref{lst:cogen}.

\includeagdalisting{6}{cogen}{Definition of \ensuremath{\HSVar{cogenerate}}}{lst:cogen}

  Since part of the semantics of an indexed container is a \emph{dependent} function type,  we need to extend \ensuremath{\HSVar{cogenerate}} to work for dependent function types as well. 

\includeagda{6}{picogen}

  The type signature of $\Pi$-\ensuremath{\HSVar{cogenerate}} may look a bit daunting, but it essentially follows the exact same structure as \ensuremath{\HSVar{cogenerate}}. The only real difference is that the the result type of the generated functions may depend on the code we are inducting over, and that we do not take a generator as input, but rather a function from index to generator. The definitions of $\Pi$-\ensuremath{\HSVar{cogenerate}} and \ensuremath{\HSVar{cogenerate}} are virtually the same, but we need to make the dependency between argument and result type explicit in the type in order for Agda to be able to solve all metavariables. 

\subsection{Constructing the Generator}

  We are now ready to construct a the generic generator for indexed descriptions. Recall that \ensuremath{\HSVar{deriveGen}} returns a generator for the regular type represented by r. 

\includeagda{6}{gensignature}

  The final generator is quite simple, really. We use the existing functionality for regular types to generate operations and arities, and return them as a dependent pair, wrapping and unwrapping fixpoint operations as we go along. The dependency between the first and second element of said pair is captured using by using the monadic structure of the generator type.

  Unfortunately, we have not been able to assemble a completeness proof for the enumeration derived using $\Sigma$-\ensuremath{\HSVar{generate}}. As was the case with the completeness proof for regular types, we need to explicitly pattern match on the value for which we are proving that it occurs in the enumeration in order for the termination checker to recognize that the proof can be constructed in finite time. However, since part of the semantics of a signature is a function type, we would require induction over function types in order to complete the proof. 


\chapter{Deriving Generators for Indexed Descriptions}

We use the generic description for indexed datatypes proposed by Dagand \cite{dagand2013cosmology} in his PhD thesis. First, we give the definition and semantics of this universe, before showing how a generator can be derived from codes in this universe. Finally, we prove that the enumerations resulting from these generators are complete. 

\section{Universe Description}\label{sec:idescdesc}

\subsection{Definition}\label{sec:idescdef}

  Indexed descriptions are not much unlike the codes used to describe regular types (that is, the \ensuremath{\HSCon{Reg}} datatype), with the differences being: 

\begin{enumerate}
  \item 
  A type parameter \ensuremath{\HSCon{I}\HSCon{\mathbin{:}}\HSCon{Set}}, describing the type of indices.

  \item 
  A generalized coproduct, \ensuremath{\HSSpecial{`}}$\sigma$, that denotes choice between $n$ constructors, in favor of the \ensuremath{\HSSym{⊕}} combinator. 

  \item 
  A combinator, \ensuremath{\HSSpecial{`}}$\Sigma$, denoting dependent pairs. 

  \item 
  Recursive positions, \ensuremath{\HSSpecial{`}\HSVar{var}}, storing the index of recursive values. 
\end{enumerate}

  This amounts to the Agda datatype describing indexed descriptions shown in listing \ref{lst:idesc}. 

\includeagdalisting{7}{idesc}{The Universe of indexed descriptions}{lst:idesc}

  Notice how we retain the regular product of codes as a first-order construct in our universe. The \ensuremath{\HSCon{Sl}} datatype is used to select the right branch from the generic coproduct, and is isomorphic to the \ensuremath{\HSCon{Fin}} datatype. 

\includeagda{7}{sl}

  The semantics associated with the \ensuremath{\HSCon{IDesc}} universe is largely the same as the semantics of the universe of regular types. The key difference is that we do not map codes to a functor \ensuremath{\HSCon{Set}\HSSym{→}\HSCon{Set}}, but rather to \ensuremath{\HSCon{IDesc}\;\HSCon{I}\HSSym{→}\HSSpecial{(}\HSCon{I}\HSSym{→}\HSCon{Set}\HSSpecial{)}\HSSym{→}\HSCon{Set}}. The semantics is shown in listing \ref{lst:idescsem}.

\includeagdalisting{7}{idescsem}{Semantics of the IDesc universe}{lst:idescsem}

  We do not require a separate constructor representing the empty type, as we can encode it as a coproduct over zero constructors: \ensuremath{\HSSpecial{`}}$\sigma$ \ensuremath{\HSNumeral{0}} $\lambda$ \ensuremath{\HSSpecial{(}\HSSpecial{)}}. 

  We calculate the fixpoint of interpreted codes using the following fixpoint combinator: 

\includeagda{7}{idescfix}

  \begin{example}
    We can describe the \ensuremath{\HSCon{Fin}} datatype, listing \ref{lst:deffin}, as follows using a code in the universe of indexed descriptions: 

\includeagdanv{7}{idescfin}

    If the index is \ensuremath{\HSVar{zero}}, there are no inhabitants, so we return a coproduct of zero choices. Otherwise, we may choose between two constructors: \ensuremath{\HSVar{zero}} or \ensuremath{\HSVar{suc}}. Notice that we describe the datatype by induction on the index type. This is not required, althoug convenient in this case. A different, but equally valid description exists, in which we use the \ensuremath{\HSSpecial{`}}$\Sigma$ constructor to explicitly enforce the constraint that the index \ensuremath{\HSVar{n}} is the successor of some \ensuremath{\HSVar{n'}}. 
    
\includeagdanv{7}{idescfin2}
    
    Listing \ref{lst:finiso} establishes that the fixpoint of \ensuremath{\HSVar{finD}} is indeed isomorphic to \ensuremath{\HSCon{Fin}}. 

  \end{example}

\includeagdalisting{7}{idescfiniso}{Isomorphism between \ensuremath{\HSCon{Fix}\;\HSVar{finD}} and \ensuremath{\HSCon{Fin}}}{lst:finiso}

  We generalize the notion of datatypes that can be described in the universe of indexed descriptions by again constructing a record that stores a description and a proof that said description is isomorphic to the type we are describing: 

\includeagda{7}{describe}

\subsection{Exmample: describing well typed lambda terms}

  To demonstrate the expressiveness of the \ensuremath{\HSCon{IDesc}} universe, and to show how one might model a more complex datatype, we consider simply typed lambda terms as an example. We model the simply typed lambda calculus in Agda according to the representation used in Philip Wadler and Wen Kokke's PLFA \cite{wadler2019plfa}. 

\subsubsection{Modelling SLC in Agda}

  Wadler and Kokke use a representation using De Bruijn indices \cite{de1972lambda}, which represents variables as a natural denoting the number of lambda abstractions between the variable and the binder it refers to. Using De Bruijn indices has the clear advantage that $\alpha$-equivalent terms have the same representation. Listing \ref{lst:lambdadatatypes} contains the datatype definitions for raw terms, types and contexts. Raw terms represent untyped lambda terms. Types can be either the ground type \ensuremath{\HSSpecial{`}}$\tau$, or a function type $sigma$\ensuremath{\HSSpecial{`}\HSSym{\to} }$\tau$. Since we are using De Bruijn indices, we do not need to store variable names in the context, only types. Hence the \ensuremath{\HSCon{Ctx}} type is isomorphic to \ensuremath{\HSCon{List}\;\HSCon{Ty}}. 

\includeagdalisting{7}{lambdadatatypes}{Datatypes for raw terms, types and contexts}{lst:lambdadatatypes}

  We write $\Gamma \ni \tau$ to signify that a variable with type $\tau$ is bound in context $\Gamma$. Context membership is described by the following inference rules: 

\begin{equation*}
\texttt{[Top]}
  \frac{}{\Gamma , \tau \ni \alpha : \tau} \quad 
\texttt{[Pop]}
  \frac{\Gamma \ni \tau}{\Gamma , \sigma \ni \alpha : \tau}
\end{equation*}

  We describe these inference rules in Agda using an inductive datatype, shown in listing \ref{lst:ctxmem}, indexed with a type and a context, whose inhabitants correspond to all proofs that a context $\Gamma$ contains a variable of type $\tau$. 

\includeagdalisting{7}{ctxmembership}{Context membership in Agda}{lst:ctxmem}

  We write $\Gamma \vdash t : \tau$ to express a typing judgement stating that term $t$ has type $\tau$ when evaluated under context $\Gamma$. The following inference rules determine when a term is type correct: 

\begin{equation*}
\texttt{[Var]}
  \frac{\Gamma \ni \alpha : \tau}{\Gamma \vdash \alpha : \tau} \quad 
\texttt{[Abs]}
  \frac{\Gamma , \alpha : \sigma \vdash t : \tau}{\Gamma \vdash \lambda\ \alpha\ .\ t : \sigma \rightarrow \tau} \quad
\texttt{[App]}
  \frac{\Gamma \vdash t1 : \sigma \rightarrow \tau \quad \Gamma \vdash t2 : \sigma}{\Gamma \vdash t_1\ t_2 : \tau}
\end{equation*} 

  We model these inference rules in Agda using a binary relation between contexts and types whose inhabitants correspond to all terms that have a given type under a given context (listing \ref{lst:wflambda})

\includeagdalisting{7}{typejudgement}{Well-typed lambda terms as a binary relation}{lst:wflambda}

  Given an inhabitant $\Gamma$ \ensuremath{\HSSym{⊢}} $\tau$ of this relationship, we can write a function \ensuremath{\HSVar{toTerm}} that transforms the typing judgement to its corresponding untyped term, which simply \emph{erases} the indices of a proof $\Gamma \vdash \tau$ to obtain an untyped term. 

\includeagda{7}{toterm}

  The term returned by \ensuremath{\HSVar{toTerm}} will has type $\tau$ under context $\Gamma$. 

\subsubsection{Describing well typed terms}

  In \cref{sec:idescdef}, we saw that we can describe the \ensuremath{\HSCon{Fin}} both by induction on the index, as well as by adding explicit constraints. Similarly, we can choose to define a description for well-typed terms in two ways: either by induction on the type of the terms we are describing, or by including an explicit constraint that the index type is a function type for the description of the abstraction rule. In either case, we start by defining descriptions for each of the three possible constructors (listing \ref{lst:sltcconstructordesc}). 

\includeagdalisting{7}{sltcconstructordesc}{Descriptions for the constructors of the simply typed lambda calculus}{lst:sltcconstructordesc}

  Given the descriptions for the individual constructors, we can assemble a description for the entire datatype by pattern matchin on the index type, and returning for each branch a coproduct of the descriptions of all constructors that could have been used to create a value with that particular index (listing \ref{lst:slcdescinductive}). 

\includeagdalisting{7}{slcdescinductive}{Inductive description of the simply typed lambda calculus}{lst:slcdescinductive}

  Alternatively, we can describe the simply typed lambda calculus as a coproduct of the descriptions of all its constructors, and adding an explicit constraint in the case of the abstraction rule that requires a proof that the index type is a function type (listing \ref{lst:slcdescconstrained}). 
  
\includeagdalisting{7}{slcdescconstrained}{Description of the simply typed lambda calculus with explicit constraints}{lst:slcdescconstrained}
  
  To convince ourselves that these descriptions do indeed describe the same type, we can show that their fixpoints are isomorphic: 

\includeagda{7}{desciso}

  Given an isomorphism between the fixpoints of two descriptions, we can prove that they are both isomorphic to the target type by establishing an isomorphism between the fixpoint of one of them and the type we are describing. For example, we might prove the following isomorphism: 

\includeagda{7}{constrainediso}

  Using the transitivity of \ensuremath{\HSSym{\anonymous} \HSSym{≃\char95 }}, we can show that the inductive description also describes well typed terms. 

  Both variations are equally valid descriptions of the simply typed lambda calculus (they are isomorphic), but depending on the situation one might prefer one over the other. A downside to defining descriptions by induction over the index type is that we often end up with at least some code duplication, making them unnecessarily verbose. Descriptions with explicit constraints do not have this downside. We could even substitute \ensuremath{\HSVar{varDesc}}, \ensuremath{\HSVar{absDesc}} and \ensuremath{\HSVar{appDesc}} for their respective definitions, since they are only referred to once. This often results in descriptions that are much more succinct, but arguably less straightforward. 

  When looking ahead to the derivation of generators from descriptions, we see that using a description with explicit constraints has the side effect that we delay the point at which we find out that a certain constructor could not have been used to construct a value with a particular index. In the case of inductive descriptions, we find out this fact relatively early, since the set of available operations explicitly depends on the index, so this set will never include descriptions that could not have been used in the first place. Contrary, when using a description that explicitly includes constraints, we only find that a particular constructor could not have been used when we fail to synthesize the required equality proof. In the end this means that the choice of descriptions style comes down to a tradeof between brevity and efficiency. Throughout the remainder of this thesis, we will stick with the inductive style of defining descriptions. 

\section{Generic Generators for Indexed Descriptions}

  The process of deriving a generator for indexed descriptions is mostly the same as for regular types. There are a few subtle differences, which we will outline in this section. We define a function \ensuremath{\HSCon{IDesc}\HSSym{-}\HSVar{gen}} that derives a generator from an indexed description. Let us first look at its type signature: 

\includeagda{7}{idescgen}

  We take a value of type \ensuremath{\HSCon{IDesc}\;\HSCon{I}} (the description we are inducting over) and a function \ensuremath{\HSCon{I}\HSSym{\to} \HSCon{IDesc}\;\HSCon{I}} (describing the type for which we are deriving a generator) as input. We return an \emph{indexed} generator, which produces values of the type dictated by the semantics of the input description. The definition for \ensuremath{\HSSpecial{`}\HSVar{var}}, \ensuremath{\HSSpecial{`}\HSNumeral{1}} and \ensuremath{\HSSpecial{`}\HSSym{×}} can be readily transferred from the definition of \ensuremath{\HSVar{deriveGen}}. The generic generators for the generalized coproduct and the \ensuremath{\HSSpecial{`}\Sigma } constructor are slightly more involved, since the both have to produce dependent pairs. Since the generalized coproduct is a particular instantiation of \ensuremath{\HSSpecial{`}\Sigma }, we will consider it first. 

\includeagda{7}{idescgencop}

  Here we assume that \ensuremath{\HSCon{Sl}}-\ensuremath{\HSVar{gen}\HSCon{\mathbin{:}}\HSSpecial{(}\HSVar{n}\HSCon{\mathbin{:}}\HSCon{ℕ}\HSSpecial{)}\HSSym{→}\HSCon{Genᵢ}\;\HSSpecial{(}\HSCon{Sl}\;\HSVar{n}\HSSpecial{)}\;\HSCon{Sl}\;\HSVar{n}} is in scope, producing values of the selector type. We capture the dependency between the generated first element of the pair, and the type of the second element using the monadic bind of the generator type, similar to when we were defining a generator for the universe of indexed containers. The definition is pretty straightforward, although we need to pass around some metavariables in order to convince Agda that everything is in order. 

  We can reuse this exact same structure when defining a generator for \ensuremath{\HSSpecial{`}\Sigma }, however since the type of its first element is chosen by the user, we cannot define a generator for it in adavance, as we did for the selector type. We use the same approach using a metadata structure as for regular types to have the programmer pass appropriate generators as input to \ensuremath{\HSCon{IDesc}\HSSym{-}\HSVar{gen}}. We define this metadata structure as a datatype \ensuremath{\HSKeyword{data}\;\HSCon{IDescM}\;\HSSpecial{\HSSym{\{\mskip1.5mu} }\HSCon{I}\HSSpecial{\HSSym{\mskip1.5mu\}}}\;\HSSpecial{(}\HSCon{P}\HSCon{\mathbin{:}}\HSCon{Set}\HSSym{→}\HSCon{Set}\HSSpecial{)}\HSCon{\mathbin{:}}\HSCon{IDesc}\;\HSCon{I}\HSSym{→}\HSCon{Set}}. Its constructors are largely equivalent to the metadata structure used for regular types (\cref{sec:genericgenreg}), with the key difference being that we now require the programmer to store a piece of data depending on the type of the first element of a \ensuremath{\HSSpecial{`}\Sigma }: 

\includeagda{7}{idescmsigma}

  The constructor of the \ensuremath{\HSCon{IDescM}} type associated with the generalized coproduct follows the same structure as \ensuremath{\HSSpecial{`}\Sigma \HSSym{\mathrel{\sim}}}, but without a value argument, and with \ensuremath{\HSCon{S}} instantiated to the selector type. 

  If we now assume that \ensuremath{\HSCon{IDesc}\HSSym{-}\HSVar{gen}} is parameterized over a metadata structure containing generators for the first argument of the \ensuremath{\HSSpecial{`}\Sigma } constructor, we can define a generator for its interpretation: 

\includeagda{7}{idescgensigma}

  By using an instance of \ensuremath{\HSCon{Describe}}, we may use the isomorphism stored within to convert the values generated by \ensuremath{\HSCon{IDesc}\HSSym{-}\HSVar{gen}} to the type we are describing. 
 
\section{Completeness Proof for Enumerators Derived From Indexed Descriptions}

  We aim to prove the same completeness property for generators derived from indexed descriptions as we did for generators derived from regular types. Since both universes and the functions that we use to derive generators from their inhabitants are structurally quite similar, so are their completeness proofs. This means that we can recycle a considerable portion of the proof for regular types. 

  Let us first look at the exact property we aim to prove. Since we deal with indexed generators, the desired completeness property changes slightly. In natural language, we might say that our goal is to prove that \emph{for every index \ensuremath{\HSVar{i}} and value \ensuremath{\HSVar{x}} of type \ensuremath{\HSCon{P}\;\HSVar{i}}, there is a depth such that \ensuremath{\HSVar{x}} occurs in the enumeration we derive from the code describing \ensuremath{\HSCon{P}}}. In Agda we formalize this property as follows: 

\includeagda{7}{completeness}

  Which is essentially the same property we used for regular types, adapted for usage with indexed types. The completeness proofs for \ensuremath{\HSSpecial{`}\HSVar{var}}, \ensuremath{\HSSpecial{`}\HSNumeral{1}} and \ensuremath{\HSSpecial{`}\HSSym{×}} can be transplanted from the proof for regular types with only a few minor changes. However, generators for \ensuremath{\HSSpecial{`}\sigma } and \ensuremath{\HSSpecial{`}\Sigma } are assembled using \emph{monadic bind}, for which we have not yet proven that it satisfies our notion of completeness. Defining what completeness even means for \ensuremath{\HSSym{\bind} } is very difficult in itself, but luckily since both usages in \ensuremath{\HSCon{IDesc}\HSSym{-}\HSVar{gen}} follow the same structure, we only have to prove a completeness property over our specific use of the bind operator. We replace \ensuremath{\HSCon{Complete}} with a slight variation that makes the value \ensuremath{\HSVar{x}} we are quantifying over explicit in the type. 

\includeagdalisting{7}{bindcomplete}{Completeness for the bind operator}{lst:bindcomplete}

   Given that the proof is supplied with a metadata structure that provides generators with completeness proofs for all \ensuremath{\HSSpecial{`}\Sigma } in a description, and that we have a completeness proof over the generator for the selection type in scope, we can complete the proof for the case of \ensuremath{\HSSpecial{`}\sigma } and \ensuremath{\HSSpecial{`}\Sigma } with a call to \ensuremath{\HSVar{bind}\HSSym{-}\HSCon{Complete}}. 

  It is worth noting that, since the universe of indexed descriptions exposes a product combinator, we require a proof of \emph{monotonicity} for generators derived using \ensuremath{\HSCon{IDesc}\HSSym{-}\HSVar{gen}} as well. We will not go into how to assemble this proof here (since its structure is essentially the same as the monotonicity proof for regular types), but it is obviously not possible to assemble this proof without proving the monotonicity property over our bind operation first. 


%% \chapter{A Combinator Library for Generators}
%% %include src/chap04/body.lhs

\chapter{Implementation in Haskell}
We implement part of the ideas described in this thesis in Haskell to show their practical applicability. More specifically, we port the universe of indexed descriptions as described in \cref{sec:idescdesc} together with the accompanying generic generator to Haskell. We show that it is possible using this approach to generate constrained test data by describing constrained data as an inductive datatype, and generating inhabitants of that datatype. 

\section{General Approach}

  The general structure of our approach is not much different from how we derived generators for indexed descriptions in Agda, and consists of the following steps: 

  \begin{enumerate}
    \item 
      First we define an abstract generator type, together with a mapping to enumerators (i.e. functions with type \ensuremath{\HSCon{Int}\HSSym{\to} \HSSpecial{\HSSym{[\mskip1.5mu} }\HSVar{a}\HSSpecial{\HSSym{\mskip1.5mu]}}}). 

    \item 
      Next, we define a datatype for indexed descriptions, \ensuremath{\HSCon{IDesc}}, together with its semantics

    \item 
      Then we write a function that derives a generator from a value of type \ensuremath{\HSCon{IDesc}}, producing elements of a type dictated by the semantics of th input description. 

    \item 
      Finally, we convert the generated values to some user defined "raw" datatype.  
  \end{enumerate}

Dagand originally defines the universe in a dependently typed setting \cite{dagand2013cosmology}, and we make extensive use of both dependent pairs and dependent function types in our definition in Agda. Haskell's type system does not facilitate such relations between types. We will use a lot of \emph{singleton types} \cite{eisenberg2013dependently} to work around this limitation. Singleton types is a technique to simulate a restricted for of dependent types in a non dependently typed language. They are intended to work together with the \emph{DataKinds} extension \cite{ghcdocsdatakinds}. A singleton type is indexed by some promoted datatype, and has exactly one inhabitant for every inhabitant of the type it is indexed with.   

\section{Representing Indexed Descriptions In Haskell}

  We take the datatype described in \cref{sec:idescdesc} as an example. We add an extra type parameter \ensuremath{\HSVar{a}\HSSym{::}\HSSym{*}} besides a parameter describing the index type, which is the raw type we will be converting to. Listing \ref{idescdef} contains tbe definition of \ensuremath{\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}}, with constructors for \emph{empty types}, \emph{unit types}, \emph{recursive positions} and \emph{product types}. We purposefully omit the constructors for the generalized coproduct and the \ensuremath{\HSSpecial{`}\Sigma } combinator, since transferring them to Haskell is slightly more involved. 

\begin{listing}{Definition of \ensuremath{\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}} in Haskell}{lst:idescdef}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{data}\;\HSCon{IDesc}\;\HSSpecial{(}\HSVar{a}\HSSym{::}\HSSym{*}\HSSpecial{)}\;\HSSpecial{(}\HSVar{i}\HSSym{::}\HSSym{*}\HSSpecial{)}\;\HSKeyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{One}{}\<[10]%
\>[10]{}\HSSym{::}\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{Empty}{}\<[10]%
\>[10]{}\HSSym{::}\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{Var}{}\<[10]%
\>[10]{}\HSSym{::}\HSVar{i}\HSSym{\to} \HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSSpecial{(}\HSSym{:*:}\HSSpecial{)}{}\<[10]%
\>[10]{}\HSSym{::}\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}\HSSym{\to} \HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}\HSSym{\to} \HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{listing}

\subsection{Generalized coproducts}

  Recall that the generalized coproduct in Dagand's representation was given by a natural number \ensuremath{\HSVar{n}}, and a function taking a finite type of size \ensuremath{\HSVar{n}} and returning a description. We choose to use a \emph{size indexed list} or \emph{vector} in favor of a function from finite type to description. Assuming a type \ensuremath{\HSCon{Nat}} is in scope, we use the following GADT to describe a vector: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{data}\;\HSCon{Vec}\;\HSSpecial{(}\HSVar{a}\HSSym{::}\HSSym{*}\HSSpecial{)}\;\HSSpecial{(}\HSVar{n}\HSSym{::}\HSCon{Nat}\HSSpecial{)}\;\HSKeyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{VNil}{}\<[10]%
\>[10]{}\HSSym{::}\HSCon{Vec}\;\HSVar{a}\;\HSCon{Zero}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSSpecial{(}\HSSym{:::}\HSSpecial{)}{}\<[10]%
\>[10]{}\HSSym{::}\HSVar{a}\HSSym{\to} \HSCon{Vec}\;\HSVar{a}\;\HSVar{n}\HSSym{\to} \HSCon{Vec}\;\HSVar{a}\;\HSSpecial{(}\HSCon{Suc}\;\HSVar{n}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  Given a singleton instance of the \ensuremath{\HSCon{Nat}} datatype, \ensuremath{\HSCon{Sing}\;\HSVar{n}}, we can define a generalized coproduct:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\HSSpecial{(}\HSSym{:+>}\HSSpecial{)}\HSSym{::}\HSCon{Sing}\;\HSVar{n}\HSSym{\to} \HSCon{Vec}\;\HSSpecial{(}\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}\HSSpecial{)}\;\HSVar{n}\HSSym{\to} \HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  Which describes a choice between \ensuremath{\HSVar{n}} descriptions. 

\subsection{The \ensuremath{\HSSpecial{`}\Sigma } combinator}

  Originally, the semantics of the \ensuremath{\HSSpecial{`}\Sigma } combinator is a dependent pair. However, we observe that this dependency between the first and second element of the pair is not necessary to represent any of the examples we have looked at. For this reason, we choose a slightly weaker version of the \ensuremath{\HSSpecial{`}\Sigma } combinator, which does not have a dependent pair as its semantics, but rather a regular pair, making it considerably easier to work with. 

  In all the examples uses of \ensuremath{\HSSpecial{`}\Sigma } we have seen so far, the \emph{structure} of the description returned by the function stored as its second argument remained the same each time, with only the indices stored for recursive positins depending on the choice of first element. This implies that, if we choose the semantics of a recursive position \ensuremath{\HSCon{Var}\;\HSVar{i}} to be the raw type \ensuremath{\HSVar{a}}, the semantics of the description returned by the second element will remain constant, independent of the value chosen for the first element. This means that there is no dependency between the two elements of the pair, enabling us to interpret \ensuremath{\HSSpecial{`}\Sigma } as a regular pair. 

  The question that remains is what description to supply for the second element of the pair. Since the values stored in recursive positions have no effect on the semantics of a description, neither has their types. This means that two descriptions with \emph{different} index types may map to the same interpretation, as long as their \emph{structure} is the same. Based on this observation, we use a description of type \ensuremath{\HSCon{IDesc}\;\HSVar{a}\;\HSSpecial{(}\HSVar{s}\HSSym{\to} \HSVar{i}\HSSpecial{)}} to describe the second element of a \ensuremath{\HSSpecial{`}\Sigma }, where \ensuremath{\HSVar{i}} is the index type of the description we are constructing, and \ensuremath{\HSVar{s}} the type stored in the first element of a \ensuremath{\HSSpecial{`}\Sigma }. This amounts to the following constructor of the \ensuremath{\HSCon{IDesc}} type: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Sigma \HSSym{::}\HSCon{Proxy}\;\HSVar{s}\HSSym{\to} \HSCon{IDesc}\;\HSVar{a}\;\HSSpecial{(}\HSVar{s}\HSSym{\to} \HSVar{i}\HSSpecial{)}\HSSym{\to} \HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
  
  It is important to note that there exist a mapping from \ensuremath{\HSCon{IDesc}\;\HSVar{a}\;\HSSpecial{(}\HSVar{s}\HSSym{\to} \HSVar{i}\HSSpecial{)}} to \ensuremath{\HSVar{s}\HSSym{\to} \HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}}, such that the interpretation is equal for all possible arguments of type \ensuremath{\HSVar{s}}. We will make this mapping precise when we set out to derive generators from descriptions. 

\subsection{Semantics}

  We define the semantics of the \ensuremath{\HSCon{IDesc}} universe as a type family, mapping promoted values to their semantics. The interpretation of descriptions is relatively straightforward, and largely the same as for regular types. The semantics are shown in listing \ref{lst:idescsem}, without the generalized coproduct (\ensuremath{\HSSpecial{(}\HSSym{:+>}\HSSpecial{)}}) and \ensuremath{\Sigma }. Here \ensuremath{\HSCon{E}} is a type with no constructors, representing the empty type. 
  
\begin{listing}{Semantics of the \ensuremath{\HSCon{IDesc}} type}{lst:idescsem}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{57}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{type}\;\HSKeyword{family}\;\HSCon{Interpret}\;\HSSpecial{(}\HSVar{d}\HSSym{::}\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}\HSSpecial{)}\HSSym{::}\HSSym{*}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Interpret}\;\HSCon{One}{}\<[57]%
\>[57]{}\HSSym{\mathrel{=}}\HSSpecial{(}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Interpret}\;\HSCon{Empty}{}\<[57]%
\>[57]{}\HSSym{\mathrel{=}}\HSCon{E}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Interpret}\;\HSSpecial{(}\HSCon{Var}\;\HSSym{\anonymous} \HSSym{::}\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}\HSSpecial{)}{}\<[57]%
\>[57]{}\HSSym{\mathrel{=}}\HSVar{a}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Interpret}\;\HSSpecial{(}\HSVar{dl}\HSSym{:*:}\HSVar{dr}\HSSpecial{)}{}\<[57]%
\>[57]{}\HSSym{\mathrel{=}}\HSSpecial{(}\HSCon{Interpret}\;\HSVar{dl}\HSSpecial{,}\HSCon{Interpret}\;\HSVar{dr}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{listing}

  For \ensuremath{\Sigma }, we need a type synonym to map a proxy to the type it carries: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{type}\;\HSCon{UnProxy}\;\HSSpecial{(}\HSVar{p}\HSSym{::}\HSCon{Proxy}\;\HSVar{a}\HSSpecial{)}\HSSym{\mathrel{=}}\HSVar{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  Given \ensuremath{\HSCon{UnProxy}}, its interpretation is now simply a pair with the type carried in the proxy, and the interpretation of the second element: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{57}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Interpret}\;\HSSpecial{(}\Sigma \;\HSVar{p}\;\HSVar{fd}\HSSpecial{)}{}\<[57]%
\>[57]{}\HSSym{\mathrel{=}}\HSSpecial{(}\HSCon{UnProxy}\;\HSVar{p}\HSSpecial{,}\HSCon{Interpret}\;\HSVar{fd}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  In case of the generalized coproduct, we would like to map a vector of descriptions to a type representing a choice between the interpretation of any of the descriptions carried in said vector. For example, we would map a vector \ensuremath{\HSVar{d1}\HSSym{:::}\HSVar{d2}\HSSym{:::}\HSCon{VNil}} to the type \ensuremath{\HSCon{Either}\;\HSSpecial{(}\HSCon{Interpret}\;\HSVar{d1}\HSSpecial{)}\;\HSSpecial{(}\HSCon{Interpret}\;\HSVar{d2}\HSSpecial{)}}. We build the appropriate type by induction over the length of the vector: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{57}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Interpret}\;\HSSpecial{(}\HSCon{SZero}\HSSym{:+>}\HSCon{VNil}\HSSpecial{)}{}\<[57]%
\>[57]{}\HSSym{\mathrel{=}}\HSCon{E}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Interpret}\;\HSSpecial{(}\HSCon{SSuc}\;\HSCon{SZero}\HSSym{:+>}\HSSpecial{(}\HSVar{x}\HSSym{:::}\HSCon{VNil}\HSSpecial{)}\HSSpecial{)}{}\<[57]%
\>[57]{}\HSSym{\mathrel{=}}\HSCon{Interpret}\;\HSVar{x}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Interpret}\;\HSSpecial{(}\HSCon{SSuc}\;\HSSpecial{(}\HSCon{SSuc}\;\HSVar{n}\HSSpecial{)}\HSSym{:+>}\HSSpecial{(}\HSVar{x}\HSSym{:::}\HSVar{xs}\HSSpecial{)}\HSSpecial{)}{}\<[57]%
\>[57]{}\HSSym{\mathrel{=}}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{Either}\;\HSSpecial{(}\HSCon{Interpret}\;\HSVar{x}\HSSpecial{)}\;\HSSpecial{(}\HSCon{Interpret}\;\HSSpecial{(}\HSCon{SSuc}\;\HSVar{n}\HSSym{:+>}\HSVar{xs}\HSSpecial{)}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  We have two base cases, one for empty vectors and one for vectors containing one element. We do so to reduce the complexity of the resulting type, preventing a vector with one element, \ensuremath{\HSVar{d}\HSSym{:::}\HSCon{VNil}}, to be mapped to a coproduct of its interpretation and the empty type. 

\section{Deriving Generators for Indexed Descriptions in Haskell}

  Before we set out to describe how we derive generators from descriptions, we first briefly outline the generator type used, and describe the singleton for descriptions needed to describe the dependency between the input description, and the type of values produced by the returned generator. 

\subsection{The generator type}

  We again use an abstract generator type, representing a deep embedding of the combinators we use. The definition is shown in listing \ref{lst:hsgendef}, and is mostly the same as the definition we used in Agda. We choose to not have separate types for indexed and non-indexed generators, representing non-indexed types as types indexed by the unit type. 

\begin{listing}{The \ensuremath{\HSCon{Gen}} type in Haskell}{lst:hsgendef}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{43}{@{}>{\hspre}l<{\hspost}@{}}%
\column{46}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{data}\;\HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{t}\;\HSKeyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{None}{}\<[9]%
\>[9]{}\HSSym{::}{}\<[46]%
\>[46]{}\HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{t}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{Pure}{}\<[9]%
\>[9]{}\HSSym{::}\HSVar{a}{}\<[43]%
\>[43]{}\HSSym{\to} \HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{t}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{Or}{}\<[9]%
\>[9]{}\HSSym{::}\HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{t}\HSSym{\to} \HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{t}{}\<[43]%
\>[43]{}\HSSym{\to} \HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{t}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{Ap}{}\<[9]%
\>[9]{}\HSSym{::}\HSCon{Gen}\;\HSVar{i}\;\HSSpecial{(}\HSVar{b}\HSSym{\to} \HSVar{a}\HSSpecial{)}\;\HSVar{t}\HSSym{\to} \HSCon{Gen}\;\HSVar{i}\;\HSVar{b}\;\HSVar{t}{}\<[43]%
\>[43]{}\HSSym{\to} \HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{t}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{Bind}{}\<[9]%
\>[9]{}\HSSym{::}\HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{t}\HSSym{\to} \HSSpecial{(}\HSVar{a}\HSSym{\to} \HSCon{Gen}\;\HSVar{i}\;\HSVar{b}\;\HSVar{t}\HSSpecial{)}{}\<[43]%
\>[43]{}\HSSym{\to} \HSCon{Gen}\;\HSVar{i}\;\HSVar{b}\;\HSVar{t}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mu {}\<[9]%
\>[9]{}\HSSym{::}\HSVar{i}{}\<[43]%
\>[43]{}\HSSym{\to} \HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{a}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{Call}{}\<[9]%
\>[9]{}\HSSym{::}\HSSpecial{(}\HSVar{j}\HSSym{\to} \HSCon{Gen}\;\HSVar{j}\;\HSVar{a}\;\HSVar{a}\HSSpecial{)}\HSSym{\to} \HSVar{j}{}\<[43]%
\>[43]{}\HSSym{\to} \HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{t}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{listing}

  We define the following wrapper to allow generators to be an instance of \ensuremath{\HSCon{Functor}}, \ensuremath{\HSCon{Applicative}}, \ensuremath{\HSCon{Monad}} and \ensuremath{\HSCon{Alternative}}: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{newtype}\;\HSCon{G}\;\HSVar{i}\;\HSVar{t}\;\HSVar{a}\HSSym{\mathrel{=}}\HSCon{G}\;\HSSpecial{(}\HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{t}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  This allows us to use the functions associated with these typeclasses to define genrators. For example:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{bool}\HSSym{::}\HSCon{G}\;\HSSpecial{(}\HSSpecial{)}\;\HSCon{Bool}\;\HSCon{Bool}{}\<[E]%
\\
\>[B]{}\HSVar{bool}\HSSym{\mathrel{=}}\HSVar{pure}\;\HSCon{True}\HSSym{<∣>}\HSVar{pure}\;\HSCon{False}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{A singleton instance for descriptions}

  Since our goal is eventually to define a function \ensuremath{\HSVar{idesc\char95 gen}\HSSym{::}\HSCon{Sing}\;\HSVar{d}\HSSym{\to} \HSCon{G}\;\HSVar{i}\;\HSVar{a}\;\HSSpecial{(}\HSCon{Interpret}\;\HSVar{d}\HSSpecial{)}}, we require an appropriate singleton instance for the \ensuremath{\HSCon{IDesc}} type. We again start by defining this instance for \ensuremath{\HSCon{One}}, \ensuremath{\HSCon{Empty}}, \ensuremath{\HSCon{Var}} and \ensuremath{\HSSym{:*:}}, shown in listing \ref{lst:singidescdef}

\begin{listing}{Singleton instance for the \ensuremath{\HSCon{IDesc}} type}{lst:singidescdef}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{41}{@{}>{\hspre}c<{\hspost}@{}}%
\column{41E}{@{}l@{}}%
\column{45}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{data}\;\HSCon{SingIDesc}\;\HSSpecial{(}\HSVar{d}\HSSym{::}\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}\HSSpecial{)}\;\HSKeyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{SOne}{}\<[11]%
\>[11]{}\HSSym{::}{}\<[45]%
\>[45]{}\HSCon{SingIDesc}\;\HSCon{One}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{SEmpty}{}\<[11]%
\>[11]{}\HSSym{::}{}\<[45]%
\>[45]{}\HSCon{SingIDesc}\;\HSCon{Empty}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{SVar}{}\<[11]%
\>[11]{}\HSSym{::}\HSVar{forall}\;\HSSpecial{(}\HSVar{i'}\HSSym{::}\HSVar{i}\HSSpecial{)}\HSSym{\mathbin{\circ}}\HSVar{i}{}\<[41]%
\>[41]{}\HSSym{\to} {}\<[41E]%
\>[45]{}\HSCon{SingIDesc}\;\HSSpecial{(}\HSCon{Var}\;\HSVar{i'}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSSpecial{(}\HSSym{:*:\char126 }\HSSpecial{)}{}\<[11]%
\>[11]{}\HSSym{::}\HSCon{SingIDesc}\;\HSVar{l}\HSSym{\to} \HSCon{SingIDesc}\;\HSVar{r}\HSSym{\to} {}\<[45]%
\>[45]{}\HSCon{SingIDesc}\;\HSSpecial{(}\HSVar{l}\HSSym{:*:}\HSVar{r}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{listing}

  In order to be able to define a singleton instance for the generalized coproduct, we require a singleton instance of \ensuremath{\HSCon{SNat}}. We assume this instance, denoted \ensuremath{\HSCon{SNat2}} is in scope: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSSpecial{(}\HSSym{:+>\char126 }\HSSpecial{)}\HSSym{::}\HSCon{SNat2}\;\HSVar{n}\HSSym{\to} \HSCon{SVec}\;\HSVar{xs}\HSSym{\to} \HSCon{SingIDesc}\;\HSSpecial{(}\HSVar{n}\HSSym{:+>}\HSVar{xs}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  The singleton definition for the \ensuremath{\Sigma } constructor (listing \ref{lst:singsigmadef}) has a few subtleties. First, the type stored in its first element is required to be a member of the \ensuremath{\HSCon{Promote}} typeclass. This typeclass describes types which are an instance of \ensuremath{\HSCon{Singleton}}, and for which we know how to promote a value of type \ensuremath{\HSVar{a}} to a value of type \ensuremath{\HSCon{Sing}\;\HSVar{a}}. The \ensuremath{\HSCon{Promote}} class has one associated function \ensuremath{\HSVar{promote}\HSSym{::}\HSVar{a}\HSSym{\to} \HSCon{Promoted}\;\HSVar{a}\;\HSCon{Sing}}, where \ensuremath{\HSCon{Promoted}} is defined as follows: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{data}\;\HSCon{Promoted}\;\HSSpecial{(}\HSVar{a}\HSSym{::}\HSSym{*}\HSSpecial{)}\;\HSSpecial{(}\HSVar{f}\HSSym{::}\HSVar{a}\HSSym{\to} \HSSym{*}\HSSpecial{)}\HSSym{\mathrel{=}}\HSVar{forall}\;\HSSpecial{(}\HSVar{x}\HSSym{::}\HSVar{a}\HSSpecial{)}\HSSym{\mathbin{\circ}}\HSCon{Promoted}\;\HSSpecial{(}\HSVar{f}\;\HSVar{x}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  Storing singleton values, but hiding the the index. 

\begin{listing}{Singleton instance for the \ensuremath{\Sigma } constructor}{lst:singsigmadef}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSCon{SSigma}{}\<[9]%
\>[9]{}\HSSym{::}\HSCon{Promote}\;\HSVar{s}\HSSym{\Rightarrow} \HSCon{SingIDesc}\;\HSVar{d}{}\<[E]%
\\
\>[9]{}\HSSym{\to} \HSCon{G}\;\HSSpecial{(}\HSSpecial{)}\;\HSVar{s}\;\HSVar{s}{}\<[E]%
\\
\>[9]{}\HSSym{\to} \HSSpecial{(}\HSVar{forall}\;\HSVar{s'}\HSSym{\mathbin{\circ}}\HSCon{Sing}\;\HSVar{s'}\HSSym{\to} \HSCon{Interpret}\;\HSVar{d}\HSSym{:\char126 :}\HSCon{Interpret}\;\HSSpecial{(}\HSCon{Expand}\;\HSVar{d}\;\HSVar{s'}\HSSpecial{)}\HSSpecial{)}{}\<[E]%
\\
\>[9]{}\HSSym{\to} \HSCon{SingIDesc}\;\HSSpecial{(}\Sigma \;\HSSpecial{(}\HSCon{Proxy}\HSSym{::}\HSCon{Proxy}\;\HSVar{s}\HSSpecial{)}\;\HSVar{d}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{listing}

  The singleton instance for \ensuremath{\Sigma } also stores an explicit generator for values of type \ensuremath{\HSVar{s}}. We could have used a typeclass here, but as we will se when considering some examples, it is often more convenient to explicitly supply the generator to be used. Finally, we require a proof that the interpretation of the \emph{expansion} of the second argument is equal to the interpretation of the second argument, for all values of type \ensuremath{\HSVar{s}}. We require this proof in order unify the index types of the generator derived for a \ensuremath{\Sigma } and the generator derived from its second argument. We define the expansion operation a the type level using a mutually recursive type family, shown in listing \ref{lst:exptypefam}. 

\begin{listing}{Description expansion}{lst:exptypefam}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{33}{@{}>{\hspre}l<{\hspost}@{}}%
\column{35}{@{}>{\hspre}l<{\hspost}@{}}%
\column{47}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{type}\;\HSKeyword{family}\;\HSCon{VExpand}\;\HSSpecial{(}\HSVar{sn}\HSSym{::}\HSCon{SNat}\;\HSVar{n}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSSpecial{(}\HSVar{xs}\HSSym{::}\HSCon{Vec}\;\HSSpecial{(}\HSCon{IDesc}\;\HSVar{a}\;\HSSpecial{(}\HSVar{s}\HSSym{\to} \HSVar{i}\HSSpecial{)}\HSSpecial{)}\;\HSVar{n}\HSSpecial{)}\;\HSSpecial{(}\HSVar{x}\HSSym{::}\HSVar{s}\HSSpecial{)}\HSSym{::}\HSCon{Vec}\;\HSSpecial{(}\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}\HSSpecial{)}\;\HSVar{n}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{VExpand}\;\HSCon{SZero}\;{}\<[33]%
\>[33]{}\HSCon{VNil}\;\HSVar{s}{}\<[47]%
\>[47]{}\HSSym{\mathrel{=}}\HSCon{VNil}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{VExpand}\;\HSSpecial{(}\HSCon{SSuc}\;\HSVar{sn}\HSSpecial{)}\;\HSSpecial{(}\HSVar{x}\HSSym{:::}\HSVar{xs}\HSSpecial{)}\;\HSVar{s}{}\<[47]%
\>[47]{}\HSSym{\mathrel{=}}\HSCon{Expand}\;\HSVar{x}\;\HSVar{s}\HSSym{:::}\HSCon{VExpand}\;\HSVar{sn}\;\HSVar{xs}\;\HSVar{s}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\HSKeyword{type}\;\HSKeyword{family}\;\HSCon{Expand}\;\HSSpecial{(}\HSVar{d}\HSSym{::}\HSCon{IDesc}\;\HSVar{a}\;\HSSpecial{(}\HSVar{s}\HSSym{\to} \HSVar{i}\HSSpecial{)}\HSSpecial{)}\;\HSSpecial{(}\HSVar{x}\HSSym{::}\HSVar{s}\HSSpecial{)}\HSSym{::}\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Expand}\;\HSCon{One}\;{}\<[35]%
\>[35]{}\HSVar{s}\HSSym{\mathrel{=}}\HSCon{One}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Expand}\;\HSCon{Empty}\;{}\<[35]%
\>[35]{}\HSVar{s}\HSSym{\mathrel{=}}\HSCon{Empty}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Expand}\;\HSSpecial{(}\HSCon{Var}\;\HSVar{i}\HSSpecial{)}\;{}\<[35]%
\>[35]{}\HSVar{s}\HSSym{\mathrel{=}}\HSCon{Var}\;\HSSpecial{(}\HSVar{i}\;\HSVar{s}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Expand}\;\HSSpecial{(}\HSVar{dl}\HSSym{:*:}\HSVar{dr}\HSSpecial{)}\;{}\<[35]%
\>[35]{}\HSVar{s}\HSSym{\mathrel{=}}\HSSpecial{(}\HSCon{Expand}\;\HSVar{dl}\;\HSVar{s}\HSSpecial{)}\HSSym{:*:}\HSSpecial{(}\HSCon{Expand}\;\HSVar{dr}\;\HSVar{s}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Expand}\;\HSSpecial{(}\HSVar{sn}\HSSym{:+>}\HSVar{xs}\HSSpecial{)}\;{}\<[35]%
\>[35]{}\HSVar{s}\HSSym{\mathrel{=}}\HSVar{sn}\HSSym{:+>}\HSCon{VExpand}\;\HSVar{sn}\;\HSVar{xs}\;\HSVar{s}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{Expand}\;\HSSpecial{(}\Sigma \;\HSVar{p}\;\HSVar{d}\HSSpecial{)}\;{}\<[35]%
\>[35]{}\HSVar{s}\HSSym{\mathrel{=}}\Sigma \;\HSVar{p}\;\HSSpecial{(}\HSCon{Expand}\;\HSVar{d}\;\HSVar{s}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{listing}

  Similarly, we use two mutually recursive functions to describe expansion for singleton descriptions (listing \ref{lst:expdef})

\begin{listing}{Description expansion for singletons}{lst:expdef}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{33}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{vexpand}\HSSym{::}\HSSpecial{(}\HSCon{Singleton}\;\HSVar{s}\HSSpecial{)}\HSSym{\Rightarrow} \HSCon{Sing}\;\HSVar{sn}\HSSym{\to} \HSCon{Sing}\;\HSVar{xs}\HSSym{\to} \HSCon{Sing}\;\HSVar{s'}\HSSym{\to} \HSCon{SVec}\;\HSSpecial{(}\HSCon{VExpand}\;\HSVar{sn}\;\HSVar{xs}\;\HSVar{s'}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSVar{vexpand}\;\HSCon{SZero2}\;{}\<[20]%
\>[20]{}\HSCon{SVNil}\;{}\<[33]%
\>[33]{}\HSVar{s}\HSSym{\mathrel{=}}\HSCon{SVNil}{}\<[E]%
\\
\>[B]{}\HSVar{vexpand}\;\HSSpecial{(}\HSCon{SSuc2}\;\HSVar{sn}\HSSpecial{)}\;\HSSpecial{(}\HSVar{x}\HSSym{:::\char126 }\HSVar{xs}\HSSpecial{)}\;{}\<[33]%
\>[33]{}\HSVar{s}\HSSym{\mathrel{=}}\HSVar{expand}\;\HSVar{x}\;\HSVar{s}\HSSym{:::\char126 }\HSVar{vexpand}\;\HSVar{sn}\;\HSVar{xs}\;\HSVar{s}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\HSVar{expand}\HSSym{::}\HSSpecial{(}\HSCon{Singleton}\;\HSVar{s}\HSSpecial{)}\HSSym{\Rightarrow} \HSCon{Sing}\;\HSVar{d}\HSSym{\to} \HSCon{Sing}\;\HSVar{s'}\HSSym{\to} \HSCon{Sing}\;\HSSpecial{(}\HSCon{Expand}\;\HSVar{d}\;\HSVar{s'}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSVar{expand}\;\HSCon{SOne}\;{}\<[22]%
\>[22]{}\HSVar{sv}\HSSym{\mathrel{=}}\HSCon{SOne}{}\<[E]%
\\
\>[B]{}\HSVar{expand}\;\HSCon{SEmpty}\;{}\<[22]%
\>[22]{}\HSVar{sv}\HSSym{\mathrel{=}}\HSCon{SEmpty}{}\<[E]%
\\
\>[B]{}\HSVar{expand}\;\HSSpecial{(}\HSCon{SVar}\;\HSVar{ix}\HSSpecial{)}\;{}\<[22]%
\>[22]{}\HSVar{sv}\HSSym{\mathrel{=}}\HSCon{SVar}\;\HSSpecial{(}\HSVar{ix}\;\HSVar{sv}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSVar{expand}\;\HSSpecial{(}\HSVar{dl}\HSSym{:*:\char126 }\HSVar{dr}\HSSpecial{)}\;{}\<[22]%
\>[22]{}\HSVar{sv}\HSSym{\mathrel{=}}\HSVar{expand}\;\HSVar{dl}\;\HSVar{sv}\HSSym{:*:\char126 }\HSVar{expand}\;\HSVar{dr}\;\HSVar{sv}{}\<[E]%
\\
\>[B]{}\HSVar{expand}\;\HSSpecial{(}\HSVar{sn}\HSSym{:+>\char126 }\HSVar{xs}\HSSpecial{)}\;{}\<[22]%
\>[22]{}\HSVar{sv}\HSSym{\mathrel{=}}\HSVar{sn}\HSSym{:+>\char126 }\HSVar{vexpand}\;\HSVar{sn}\;\HSVar{xs}\;\HSVar{sv}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{listing}

\subsection{Deriving generators}

  We now have all necessary ingredients in place to define a function \ensuremath{\HSVar{idesc\char95 gen}} that returns a generator based on its input description. It has the following type signature: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{idesc\char95 gen}\HSSym{::}\HSVar{forall}\;\HSSpecial{(}\HSVar{d}\HSSym{::}\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}\HSSpecial{)}\HSSym{\mathbin{\circ}}\HSSpecial{(}\HSCon{Singleton}\;\HSVar{i}\HSSpecial{)}\HSSym{\Rightarrow} \HSCon{SingIDesc}\;\HSVar{d}\HSSym{\to} \HSCon{G}\;\HSVar{i}\;\HSVar{a}\;\HSSpecial{(}\HSCon{Interpret}\;\HSVar{d}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  The definitions for the unit type, empty type, recursive positions and product type follow naturally: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{idesc\char95 gen}\;\HSCon{SOne}{}\<[25]%
\>[25]{}\HSSym{\mathrel{=}}\HSVar{pure}\;\HSSpecial{(}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSVar{idesc\char95 gen}\;\HSCon{SEmpty}{}\<[25]%
\>[25]{}\HSSym{\mathrel{=}}\HSVar{empty}{}\<[E]%
\\
\>[B]{}\HSVar{idesc\char95 gen}\;\HSSpecial{(}\HSCon{SVar}\;\HSVar{v}\HSSpecial{)}{}\<[25]%
\>[25]{}\HSSym{\mathrel{=}}\HSCon{G}\;\HSSpecial{(}\mu \;\HSVar{v}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSVar{idesc\char95 gen}\;\HSSpecial{(}\HSVar{dl}\HSSym{:*:\char126 }\HSVar{dr}\HSSpecial{)}{}\<[25]%
\>[25]{}\HSSym{\mathrel{=}}\HSSpecial{(}\HSSpecial{,}\HSSpecial{)}\HSSym{<\$>}\HSVar{idesc\char95 gen}\;\HSVar{dl}\HSSym{<*>}\HSVar{idesc\char95 gen}\;\HSVar{dr}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  We define a generator for the generalized coproduct by (again) inducting over the vector length, returning a choice between the generator derived from the head of the vector and the generator derived from the tail of the vector.  

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{47}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{idesc\char95 gen}\;\HSSpecial{(}\HSCon{SZero2}\HSSym{:+>\char126 }\HSCon{SVNil}\HSSpecial{)}{}\<[47]%
\>[47]{}\HSSym{\mathrel{=}}\HSVar{empty}{}\<[E]%
\\
\>[B]{}\HSVar{idesc\char95 gen}\;\HSSpecial{(}\HSCon{SSuc2}\;\HSCon{SZero2}\HSSym{:+>\char126 }\HSSpecial{(}\HSVar{d}\HSSym{:::\char126 }\HSCon{SVNil}\HSSpecial{)}\HSSpecial{)}{}\<[47]%
\>[47]{}\HSSym{\mathrel{=}}\HSVar{idesc\char95 gen}\;\HSVar{d}{}\<[E]%
\\
\>[B]{}\HSVar{idesc\char95 gen}\;\HSSpecial{(}\HSCon{SSuc2}\;\HSSpecial{(}\HSCon{SSuc2}\;\HSVar{n}\HSSpecial{)}\HSSym{:+>\char126 }\HSSpecial{(}\HSVar{d}\HSSym{:::\char126 }\HSVar{ds}\HSSpecial{)}\HSSpecial{)}{}\<[47]%
\>[47]{}\HSSym{\mathrel{=}}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\HSCon{Left}{}\<[13]%
\>[13]{}\HSSym{<\$>}\HSVar{idesc\char95 gen}\;\HSVar{d}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSSym{<|>}\HSCon{Right}\HSSym{<\$>}\HSVar{idesc\char95 gen}\;\HSSpecial{(}\HSCon{SSuc2}\;\HSVar{n}\HSSym{:+>\char126 }\HSVar{ds}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  If we now turn our attention to the generator derived from the \ensuremath{\Sigma } combinator, it becomes clear why we need to define the expansion operator and the proof of equality between the interpretation of a description and the interpretation of its expansion.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{idesc\char95 gen}\;\HSSpecial{(}\HSCon{SSigma}\;\HSVar{desc}\;\HSVar{gen}\;\HSVar{eq}\HSSpecial{)}\HSSym{\mathrel{=}}\HSKeyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSVar{x}\HSSym{\leftarrow} \HSCon{G}\;\HSSpecial{(}\HSCon{Call}\;\HSSpecial{(}\HSSym{\lambda} \HSSpecial{(}\HSSpecial{)}\HSSym{\to} \HSVar{unG}\;\HSVar{gen}\HSSpecial{)}\;\HSSpecial{(}\HSSpecial{)}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSKeyword{let}\;\HSVar{px}\HSSym{\mathrel{=}}\HSVar{promote}\;\HSVar{x}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSKeyword{case}\;\HSVar{px}\;\HSKeyword{of}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\HSCon{Promoted}\;\HSVar{x'}\HSSym{\to} \HSKeyword{do}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\HSVar{p}\HSSym{\leftarrow} \HSVar{idesc\char95 gen}\;\HSSpecial{(}\HSVar{expand}\;\HSVar{desc}\;\HSVar{x'}\HSSpecial{)}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\HSVar{pure}\;\HSSpecial{(}\HSVar{x}\HSSpecial{,}\HSVar{eqConv}\;\HSSpecial{(}\HSVar{eq}\;\HSVar{x'}\HSSpecial{)}\;\HSVar{p}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  First, we obtain a suitable value for the first element by calling the supplied generator. Next, we promote this value \ensuremath{\HSVar{x}} to get a singleton value \ensuremath{\HSVar{x'}} of type \ensuremath{\HSCon{Sing}\;\HSVar{x}}. We apply the promoted value \ensuremath{\HSVar{x'}} to the expansion of the second argument of \ensuremath{\Sigma }, which returns a generator producing values which have the type \ensuremath{\HSCon{Interpret}\;\HSSpecial{(}\HSCon{Expand}\;\HSVar{desc}\;\HSVar{s}\HSSpecial{)}}. We use this generator to get a value \ensuremath{\HSVar{p}} of this type, which we can cast to a value of type \ensuremath{\HSCon{Interpret}\;\HSVar{desc}} using the stored equality proof. 

  With the definition of \ensuremath{\HSVar{idesc\char95 gen}} complete, we can define a function \ensuremath{\HSVar{genDesc}\HSSym{::}\HSVar{forall}\;\HSSpecial{(}\HSVar{d}\HSSym{::}\HSCon{IDesc}\;\HSVar{a}\;\HSVar{i}\HSSpecial{)}\HSSym{\to} \HSCon{Sing}\;\HSVar{d}\HSSym{\to} \HSCon{G}\;\HSVar{i}\;\HSVar{a}\;\HSVar{a}} that produces elements of the raw type represented by a description. Note that we need a conversion function \ensuremath{\HSVar{to}\HSSym{::}\HSCon{Interpret}\;\HSVar{d}\HSSym{\to} \HSVar{a}} to convert the values produced by \ensuremath{\HSVar{idesc\char95 gen}\;\HSVar{d}}. 

\section{Examples}

  We consider two small examples to see how we can use the approach described in this section to generate constrained test data. First we consider the type of finite sets (e.g. \ensuremath{\HSCon{Fin}}), and after that the recurring example of well-typed lambda terms. In order to be able to test the derived generators, we assume that a function \ensuremath{\HSVar{run}\HSSym{::}\HSSpecial{(}\HSVar{i}\HSSym{\to} \HSCon{Gen}\;\HSVar{i}\;\HSVar{a}\;\HSVar{a}\HSSpecial{)}\HSSym{\to} \HSVar{i}\HSSym{\to} \HSCon{Int}\HSSym{\to} \HSSpecial{\HSSym{[\mskip1.5mu} }\HSVar{a}\HSSpecial{\HSSym{\mskip1.5mu]}}} is in scope, interpreting abstract generators as an exhaustive enumeration up to a certain depth. 

\subsection{Finite sets}

  We assume the definition of \ensuremath{\HSCon{Fin}} given in listing \ref{}. If we erase the index of a value of type \ensuremath{\HSCon{Fin}\;\HSVar{n}}, we end up with a value of type \ensuremath{\HSCon{Nat}}, hence \ensuremath{\HSCon{Nat}} is the raw type of our description. The goal is then to derive a generator producing values of type \ensuremath{\HSCon{Nat}}, which we interpret as values of type \ensuremath{\HSCon{Fin}\;\HSVar{n}}, but with their indices erased. This means that if we choose \ensuremath{\HSVar{n}} as our index, the generator can only produce values that are \emph{less than} the chosen index \ensuremath{\HSVar{n}}. For example, index \ensuremath{\HSCon{Suc}\;\HSSpecial{(}\HSCon{Suc}\;\HSCon{Zero}\HSSpecial{)}} should only produce the values \ensuremath{\HSCon{Suc}\;\HSCon{Zero}} or \ensuremath{\HSCon{Zero}}, and using index \ensuremath{\HSCon{Zero}} should result in a generator producing no values at all. 

  We start by defining a type family that maps indices to descriptions: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{type}\;\HSKeyword{family}\;\HSCon{FinDesc}\;\HSSpecial{(}\HSVar{n}\HSSym{::}\HSCon{Nat}\HSSpecial{)}\HSSym{::}\HSCon{IDesc}\;\HSCon{Nat}\;\HSCon{Nat}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{FinDesc}\;\HSCon{Zero}{}\<[32]%
\>[32]{}\HSSym{\mathrel{=}}\HSCon{Empty}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{FinDesc}\;\HSSpecial{(}\HSCon{Suc}\;\HSVar{n}\HSSpecial{)}{}\<[32]%
\>[32]{}\HSSym{\mathrel{=}}\HSSpecial{(}\HSCon{SSuc}\;\HSSpecial{(}\HSCon{SSuc}\;\HSCon{SZero}\HSSpecial{)}\HSSpecial{)}\HSSym{:+>}\HSSpecial{(}\HSCon{One}\HSSym{:::}\HSCon{Var}\;\HSVar{n}\HSSym{:::}\HSCon{VNil}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  If the index is Zero, we return an empty description. Otherwise we have a choice between two constructors: \ensuremath{\HSCon{Suc}} and \ensuremath{\HSCon{Zero}}. Next, we need to a singleton value of this description: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{finSDesc}\HSSym{::}\HSCon{Sing}\;\HSVar{n}\HSSym{\to} \HSCon{SingIDesc}\;\HSSpecial{(}\HSCon{FinDesc}\;\HSVar{n}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSVar{finSDesc}\;\HSCon{SZero}{}\<[19]%
\>[19]{}\HSSym{\mathrel{=}}\HSCon{SEmpty}{}\<[E]%
\\
\>[B]{}\HSVar{finSDesc}\;\HSSpecial{(}\HSCon{SSuc}\;\HSVar{n}\HSSpecial{)}\HSSym{\mathrel{=}}\HSCon{SSuc2}\;\HSSpecial{(}\HSCon{SSuc2}\;\HSCon{SZero2}\HSSpecial{)}\HSSym{:+>\char126 }\HSSpecial{(}\HSCon{SOne}\HSSym{:::\char126 }\HSCon{SVar}\;\HSVar{n}\HSSym{:::\char126 }\HSCon{SVNil}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  In this case, the definition of \ensuremath{\HSVar{finSDesc}} is completely dictated by our definition of \ensuremath{\HSCon{FinDesc}}. Finally, we define a conversion function, mapping interpretations to values: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{toFin}\HSSym{::}\HSCon{Sing}\;\HSVar{n}\HSSym{\to} \HSCon{Interpret}\;\HSSpecial{(}\HSCon{FinDesc}\;\HSVar{n}\HSSpecial{)}\HSSym{\to} \HSCon{Nat}{}\<[E]%
\\
\>[B]{}\HSVar{toFin}\;\HSSpecial{(}\HSCon{SSuc}\;\HSVar{sn}\HSSpecial{)}\;\HSSpecial{(}\HSCon{Left}\;\HSSpecial{(}\HSSpecial{)}\HSSpecial{)}\HSSym{\mathrel{=}}\HSCon{Zero}{}\<[E]%
\\
\>[B]{}\HSVar{toFin}\;\HSSpecial{(}\HSCon{SSuc}\;\HSVar{sn}\HSSpecial{)}\;\HSSpecial{(}\HSCon{Right}\;\HSVar{n}\HSSpecial{)}\HSSym{\mathrel{=}}\HSCon{Suc}\;\HSVar{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  We are now ready to generate values using the description for \ensuremath{\HSCon{Fin}}. We do this simply by promoting the provided index, and calling \ensuremath{\HSVar{genDesc}}.  

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{genFin}\HSSym{::}\HSVar{forall}\;\HSSpecial{(}\HSVar{n}\HSSym{::}\HSCon{Nat}\HSSpecial{)}\HSSym{\mathbin{\circ}}\HSCon{Nat}\HSSym{\to} \HSCon{G}\;\HSCon{Nat}\;\HSCon{Nat}\;\HSCon{Nat}{}\<[E]%
\\
\>[B]{}\HSVar{genFin}\;\HSVar{n}\HSSym{\mathrel{=}}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSKeyword{case}\;\HSVar{promote}\;\HSVar{n}\;\HSKeyword{of}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\HSSpecial{(}\HSCon{Promoted}\;\HSVar{sn}\HSSpecial{)}\HSSym{\to} \HSVar{genDesc}\;\HSVar{sn}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  If we now run \ensuremath{\HSVar{genFin}}, we see that it indeed produces the expected output: 

\begin{tabbing}\ttfamily
~λ\char62{}~run~genFin~Zero~10\\
\ttfamily ~\char91{}\char93{}\\
\ttfamily ~λ\char62{}~run~genFin~\char40{}Suc~\char40{}Suc~\char40{}Suc~Zero\char41{}\char41{}\char41{}~10\\
\ttfamily ~\char91{}Zero\char44{}Suc~Zero\char44{}Suc~\char40{}Suc~Zero\char41{}\char93{}
\end{tabbing}

\subsection{Well-typed lambda terms}

  The process for generating well-typed lambda terms is exactly the same as for finite sets albeit slightly more involved due to the complexity of the datatype describing well-formed involved. We use the description shown in listing \ref{lst:slcdescinductive} as a basis, based on the representation of well-typed terms used in Phil Wadler and Wen Kokke's PLFA \cite{wadler2019plfa}.  

  We model types terms and contexts with the following datatypes:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{data}\;\HSCon{Type}\HSSym{\mathrel{=}}\HSCon{Type}\HSSym{:->}\HSCon{Type}\HSSym{\mid} \HSCon{T}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\HSKeyword{data}\;\HSCon{Term}\HSSym{\mathrel{=}}\HSCon{TVar}\;\HSCon{Nat}\HSSym{\mid} \HSCon{TAbs}\;\HSCon{Term}\HSSym{\mid} \HSCon{TApp}\;\HSCon{Term}\;\HSCon{Term}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\HSKeyword{type}\;\HSCon{Ctx}\HSSym{\mathrel{=}}\HSSpecial{\HSSym{[\mskip1.5mu} }\HSCon{Type}\HSSpecial{\HSSym{\mskip1.5mu]}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  We use the datatype \ensuremath{\HSCon{CtxPos}} to describe a position in a context: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{data}\;\HSCon{CtxPos}\HSSym{\mathrel{=}}\HSCon{Here}\HSSym{\mid} \HSCon{There}\;\HSCon{CtxPos}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  Next, we define a generator for context positions: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{genElem}\HSSym{::}\HSCon{Ctx}\HSSym{\to} \HSCon{Type}\HSSym{\to} \HSCon{G}\;\HSSpecial{(}\HSSpecial{)}\;\HSCon{CtxPos}\;\HSCon{CtxPos}{}\<[E]%
\\
\>[B]{}\HSVar{genElem}\;\HSSpecial{\HSSym{[\mskip1.5mu} }\HSSpecial{\HSSym{\mskip1.5mu]}}\;\HSSym{\anonymous} {}\<[19]%
\>[19]{}\HSSym{\mathrel{=}}\HSVar{empty}{}\<[E]%
\\
\>[B]{}\HSVar{genElem}\;\HSSpecial{(}\HSVar{t}\HSCon{\mathbin{:}}\HSVar{ts}\HSSpecial{)}\;\HSVar{t'}\HSSym{\mathrel{=}}\HSSpecial{(}\HSKeyword{if}\;\HSVar{t}\HSSym{\equiv} \HSVar{t'}\;\HSKeyword{then}\;\HSVar{pure}\;\HSCon{Here}\;\HSKeyword{else}\;\HSVar{empty}\HSSpecial{)}\HSSym{<|>}\HSSpecial{(}\HSCon{There}\HSSym{<\$>}\HSVar{genElem}\;\HSVar{ts}\;\HSVar{t'}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  Here, \ensuremath{\HSVar{genElem}} takes a context and a type, and returns all positions at which that type occurs in the context. Now that we have all the necessary prerequisites in place to generate well-typed terms, we start by defining a type family that captures an appropriate description, show in listing \ref{lst:wttermsdesc}. This is a direct translation of the description shown in chapter 7 \ref{lst:slcdescinductive}. Since we never need recursive indices at the type level, we use a type family \ensuremath{\HSCon{I}\;\HSSpecial{(}\HSVar{s}\HSSym{::}\HSSym{*}\HSSpecial{)}\HSSym{::}\HSVar{i}} as a placeholder for the recursive positions inside a \ensuremath{\Sigma }. 

\begin{listing}{Type level description of well typed terms}{lst:wttermsdesc}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSKeyword{type}\;\HSCon{VarDesc}\HSSym{\mathrel{=}}\Sigma \;\HSSpecial{(}\HSCon{Proxy}\HSSym{::}\HSCon{Proxy}\;\HSCon{CtxPos}\HSSpecial{)}\;\HSCon{One}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSCon{AppDesc}\HSSym{\mathrel{=}}\Sigma \;\HSSpecial{(}\HSCon{Proxy}\HSSym{::}\HSCon{Proxy}\;\HSCon{Type}\HSSpecial{)}\;\HSSpecial{(}\HSCon{Var}\;\HSCon{I}\HSSym{:*:}\HSCon{Var}\;\HSCon{I}\HSSpecial{)}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\HSKeyword{type}\;\HSKeyword{family}\;\HSCon{SLTCDesc}\;\HSSpecial{(}\HSVar{i}\HSSym{::}\HSSpecial{(}\HSCon{Ctx}\HSSpecial{,}\HSCon{Type}\HSSpecial{)}\HSSpecial{)}\HSSym{::}\HSCon{IDesc}\;\HSCon{Term}\;\HSSpecial{(}\HSCon{Ctx}\HSSpecial{,}\HSCon{Type}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{SLTCDesc}\;\HSSpecial{(}\HSSpecial{(}\HSSpecial{,}\HSSpecial{)}\;\Gamma \;\HSCon{T}\HSSpecial{)}\HSSym{\mathrel{=}}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{SSuc}\;\HSSpecial{(}\HSCon{SSuc}\;\HSCon{SZero}\HSSpecial{)}\HSSym{:+>}\HSSpecial{(}\HSCon{VarDesc}\HSSym{:::}\HSCon{AppDesc}\HSSym{:::}\HSCon{VNil}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSKeyword{type}\;\HSKeyword{instance}\;\HSCon{SLTCDesc}\;\HSSpecial{(}\HSSpecial{(}\HSSpecial{,}\HSSpecial{)}\;\Gamma \;\HSSpecial{(}\HSVar{t1}\HSSym{:->}\HSVar{t2}\HSSpecial{)}\HSSpecial{)}\HSSym{\mathrel{=}}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSCon{SSuc}\;\HSSpecial{(}\HSCon{SSuc}\;\HSSpecial{(}\HSCon{SSuc}\;\HSCon{SZero}\HSSpecial{)}\HSSpecial{)}\HSSym{:+>}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\HSSpecial{(}\HSCon{VarDesc}\HSSym{:::}\HSCon{Var}\;\HSSpecial{(}\HSSpecial{(}\HSSpecial{,}\HSSpecial{)}\;\HSSpecial{(}\HSVar{t1}\HSCon{\mathbin{:}}\Gamma \HSSpecial{)}\;\HSVar{t2}\HSSpecial{)}\HSSym{:::}\HSCon{AppDesc}\HSSym{:::}\HSCon{VNil}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{listing}

  Next we define a singleton value that inhabits this description (listing \ref{lst:wtsingdesc}). Its structure is again dictated completely by the type family \ensuremath{\HSCon{SLTCDesc}}. It now becomes clear why we chose to have the programmer explicitly supply a generator to a \ensuremath{\Sigma }, since we can conveniently apply the index context and type to \ensuremath{\HSVar{genElem}} to obtain a generator that produces the required context positions. 

\begin{listing}{Singleton description of well typed terms}{lst:wtsingdesc}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}c<{\hspost}@{}}%
\column{3E}{@{}l@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{sltcDesc}\HSSym{::}\HSCon{Sing}\;\HSVar{i}\HSSym{\to} \HSCon{Sing}\;\HSSpecial{(}\HSCon{SLTCDesc}\;\HSVar{i}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSVar{sltcDesc}\;\HSSpecial{(}\HSCon{SPair}\;\Gamma \;\HSCon{ST}\HSSpecial{)}\HSSym{\mathrel{=}}\HSSpecial{(}\HSCon{SSuc2}\;\HSSpecial{(}\HSCon{SSuc2}\;\HSCon{SZero2}\HSSpecial{)}\HSSpecial{)}\HSSym{:+>\char126 }{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSSpecial{(}{}\<[3E]%
\>[9]{}\HSCon{SSigma}\;\HSCon{SOne}\;\HSSpecial{(}\HSVar{genElem}\;\Gamma \;\HSCon{T}\HSSpecial{)}\;\HSSpecial{(}\HSSym{\char92 \char95 }\HSSym{\to} \HSCon{Refl}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSSym{:::\char126 }{}\<[3E]%
\>[9]{}\HSCon{SSigma}\;{}\<[17]%
\>[17]{}\HSSpecial{(}\HSCon{SVar}\;\HSSpecial{(}\HSSym{\lambda} \sigma \HSSym{\to} \HSSpecial{(}\Gamma \HSSpecial{,}\sigma \HSSym{:->}\HSCon{T}\HSSpecial{)}\HSSpecial{)}\HSSym{:*:\char126 }\HSCon{SVar}\;\HSSpecial{(}\Gamma \HSSpecial{,}\HSSpecial{)}\HSSpecial{)}\;{}\<[E]%
\\
\>[17]{}\HSVar{genType}\;\HSSpecial{(}\HSSym{\char92 \char95 }\HSSym{\to} \HSCon{Refl}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSSym{:::\char126 }{}\<[3E]%
\>[9]{}\HSCon{SVNil}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSVar{sltcDesc}\;\HSSpecial{(}\HSCon{SPair}\;\Gamma \;\HSSpecial{(}\HSVar{t1}\HSSym{:->\$}\HSVar{t2}\HSSpecial{)}\HSSpecial{)}\HSSym{\mathrel{=}}\HSSpecial{(}\HSCon{SSuc2}\;\HSSpecial{(}\HSCon{SSuc2}\;\HSSpecial{(}\HSCon{SSuc2}\;\HSCon{SZero2}\HSSpecial{)}\HSSpecial{)}\HSSpecial{)}\HSSym{:+>\char126 }{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSSpecial{(}{}\<[3E]%
\>[9]{}\HSCon{SSigma}\;\HSCon{SOne}\;\HSSpecial{(}\HSVar{genElem}\;\HSSpecial{(}\Gamma \HSSpecial{)}\;\HSSpecial{(}\HSVar{t1}\HSSym{:->}\HSVar{t2}\HSSpecial{)}\HSSpecial{)}\;\HSSpecial{(}\HSSym{\char92 \char95 }\HSSym{\to} \HSCon{Refl}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSSym{:::\char126 }{}\<[3E]%
\>[9]{}\HSCon{SVar}\;\HSSpecial{(}\HSVar{t1}\HSCon{\mathbin{:}}\Gamma \HSSpecial{,}\HSVar{t2}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSSym{:::\char126 }{}\<[3E]%
\>[9]{}\HSCon{SSigma}\;{}\<[17]%
\>[17]{}\HSSpecial{(}\HSCon{SVar}\;\HSSpecial{(}\HSSym{\lambda} \sigma \HSSym{\to} \HSSpecial{(}\Gamma \HSSpecial{,}\sigma \HSSym{:->}\HSSpecial{(}\HSVar{t1}\HSSym{:->}\HSVar{t2}\HSSpecial{)}\HSSpecial{)}\HSSpecial{)}\HSSym{:*:\char126 }\HSCon{SVar}\;\HSSpecial{(}\Gamma \HSSpecial{,}\HSSpecial{)}\HSSpecial{)}\;{}\<[E]%
\\
\>[9]{}\hsindent{7}{}\<[16]%
\>[16]{}\HSVar{genType}\;\HSSpecial{(}\HSSym{\char92 \char95 }\HSSym{\to} \HSCon{Refl}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSSym{:::\char126 }{}\<[3E]%
\>[9]{}\HSCon{SVNil}\HSSpecial{)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{listing}

  We now only have to define a convertion function that takes generated values and produces raw terms: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{toTerm}\HSSym{::}\HSCon{Sing}\;\HSVar{i}\HSSym{\to} \HSCon{Interpret}\;\HSSpecial{(}\HSCon{SLTCDesc}\;\HSVar{i}\HSSpecial{)}\HSSym{\to} \HSCon{Term}{}\<[E]%
\\
\>[B]{}\HSVar{toTerm}\;\HSSpecial{(}\HSCon{SPair}\;\HSSym{\anonymous} \;\HSCon{ST}\HSSpecial{)}\;\HSSpecial{(}\HSCon{Left}\;\HSSpecial{(}\HSVar{n}\HSSpecial{,}\HSSpecial{(}\HSSpecial{)}\HSSpecial{)}\HSSpecial{)}\HSSym{\mathrel{=}}\HSCon{TVar}\;\HSSpecial{(}\HSVar{toNat}\;\HSVar{n}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSVar{toTerm}\;\HSSpecial{(}\HSCon{SPair}\;\HSSym{\anonymous} \;\HSCon{ST}\HSSpecial{)}\;\HSSpecial{(}\HSCon{Right}\;\HSSpecial{(}\HSSym{\anonymous} \HSSpecial{,}\HSSpecial{(}\HSVar{t1}\HSSpecial{,}\HSVar{t2}\HSSpecial{)}\HSSpecial{)}\HSSpecial{)}\HSSym{\mathrel{=}}\HSCon{TApp}\;\HSVar{t1}\;\HSVar{t2}{}\<[E]%
\\
\>[B]{}\HSVar{toTerm}\;\HSSpecial{(}\HSCon{SPair}\;\HSSym{\anonymous} \;\HSSpecial{(}\HSSym{\anonymous} \HSSym{:->\$}\HSSym{\anonymous} \HSSpecial{)}\HSSpecial{)}\;\HSSpecial{(}\HSCon{Left}\;\HSSpecial{(}\HSVar{n}\HSSpecial{,}\HSSpecial{(}\HSSpecial{)}\HSSpecial{)}\HSSpecial{)}\HSSym{\mathrel{=}}\HSCon{TVar}\;\HSSpecial{(}\HSVar{toNat}\;\HSVar{n}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSVar{toTerm}\;\HSSpecial{(}\HSCon{SPair}\;\HSSym{\anonymous} \;\HSSpecial{(}\HSSym{\anonymous} \HSSym{:->\$}\HSSym{\anonymous} \HSSpecial{)}\HSSpecial{)}\;\HSSpecial{(}\HSCon{Right}\;\HSSpecial{(}\HSCon{Left}\;\HSVar{y}\HSSpecial{)}\HSSpecial{)}\HSSym{\mathrel{=}}\HSCon{TAbs}\;\HSVar{y}{}\<[E]%
\\
\>[B]{}\HSVar{toTerm}\;\HSSpecial{(}\HSCon{SPair}\;\HSSym{\anonymous} \;\HSSpecial{(}\HSSym{\anonymous} \HSSym{:->\$}\HSSym{\anonymous} \HSSpecial{)}\HSSpecial{)}\;\HSSpecial{(}\HSCon{Right}\;\HSSpecial{(}\HSCon{Right}\;\HSSpecial{(}\HSSym{\anonymous} \HSSpecial{,}\HSSpecial{(}\HSVar{t1}\HSSpecial{,}\HSVar{t2}\HSSpecial{)}\HSSpecial{)}\HSSpecial{)}\HSSpecial{)}\HSSym{\mathrel{=}}\HSCon{TApp}\;\HSVar{t1}\;\HSVar{t2}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  We now have everything needed in pace to start generating well-typed terms. We do this again by promoting the supplied index, and calling \ensuremath{\HSVar{genDesc}} with this value: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{termGen}\HSSym{::}\HSSpecial{(}\HSCon{Ctx}\HSSpecial{,}\HSCon{Type}\HSSpecial{)}\HSSym{\to} \HSCon{G}\;\HSSpecial{(}\HSCon{Ctx}\HSSpecial{,}\HSCon{Type}\HSSpecial{)}\;\HSCon{Term}\;\HSCon{Term}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\HSVar{termGen}\;\HSVar{i}\HSSym{\mathrel{=}}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\HSKeyword{case}\;\HSVar{promote}\;\HSVar{i}\;\HSKeyword{of}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\HSSpecial{(}\HSCon{Promoted}\;\HSVar{i'}\HSSpecial{)}\HSSym{\to} \HSVar{genDesc}\;\HSVar{i'}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

  We can now use \ensuremath{\HSVar{run}\;\HSVar{termGen}} to produce well-typed given a context and a goal type: 

\begin{tabbing}\ttfamily
~λ\char62{}~run~termGen~\char40{}\char91{}T~\char44{}~T~\char58{}\char45{}\char62{}~T\char93{}~\char44{}~T\char41{}~3\\
\ttfamily ~\char91{}TVar~Zero\char44{}TApp~\char40{}TVar~\char46{}\char46{}\char46{}~\char46{}\char46{}\char46{}~\char46{}\char46{}\char46{}~\char40{}TVar~\char40{}Suc~\char40{}Suc~\char40{}Suc~Zero\char41{}\char41{}\char41{}\char41{}\char41{}\char41{}\char93{}
\end{tabbing}

  To assert that the produced values are indeed type correct, we define a function \ensuremath{\HSVar{check}\HSSym{::}\HSCon{Ctx}\HSSym{\to} \HSCon{Type}\HSSym{\to} \HSCon{Term}\HSSym{\to} \HSCon{Bool}} that checks whether a raw term has a certain type under certain context. 

\begin{tabbing}\ttfamily
~λ\char62{}~all~\char40{}check~\char91{}T~\char44{}~T~\char58{}\char45{}\char62{}~T\char93{}~T\char41{}~\char36{}~run~termGen~\char40{}\char91{}T~\char44{}~T~\char58{}\char45{}\char62{}~T\char93{}~\char44{}~T\char41{}~3\\
\ttfamily ~True
\end{tabbing}

\chapter{Discussion}
This chapter discusses some of the work related to the work presented in this thesis, together with a discussion of the results and a brief overview of possible avenues for further work. 

\section{Related Work}

  Property based testing, and the problem of obtaining suitable test data has been extensively studied in the literature. Here, we briefly discuss some of it. 

\subsection{Libraries for property based testing}

  There are many existing libraries that aim to aid a user with conducting property based testing for their programs. They differ in various aspects, including the type used for generators, whether they use generic programming to automatically derive generators for user-defined types, and other features such as the schrinking of counterexamples and the ability to concurrently run tests. 

\subsubsection{QuickCheck}

  Published in 2000 by Claessen \& Hughes \cite{claessen2011quickcheck}, QuickCheck implements property based testing for Haskell. Test values are generated by sampling randomly from the domain of test values. QuickCheck supplies the typeclass \texttt{Arbitrary}, whose instances are those types for which random values can be generated. A property of type \ensuremath{\HSVar{a}\HSSym{\to} \HSCon{Bool}} can be tested if \ensuremath{\HSVar{a}} is an instance of \texttt{Arbitrary}. Instances for most common Haskell types are supplied by the library. If a property fails on a testcase, QuickCheck supplies a counterexample. 

  Perhaps somewhat surprising is that QuickCheck is also able randomly generate values for function types by modifying the seed of the random generator (which is used to generate the function's output) based on it's input. 

\subsubsection{SmallCheck} 

  Contrary to QuickCheck, SmallCheck \cite{runciman2008smallcheck} takes an \textit
  {enumerative} approach to the generation of test data. While the approach to 
  formulation and testing of properties is largely similar to QuickCheck's, test 
  values are not generated at random, but rather exhaustively enumerated up to a 
  certain \textit{depth}. Zero-arity constructors have depth $0$, while the depth of 
  any positive arity constructor is one greather than the maximum depth of its 
  arguments. The motivation for this is the \textit{small scope hypothesis}: if a 
  program is incorrect, it will almost allways fail on some small input \cite
  {andoni2003evaluating}. 

  In addition to SmallCheck, there is also \textit{Lazy} SmallCheck. In many cases, 
  the value of a property is determined only by part of the input. Additionally, 
  Haskell's lazy semantics allow for functions to be defined on partial inputs. The 
  prime example of this is a property \texttt{sorted :: Ord a => [a] -> Bool} that 
  returns \texttt{false} when presented with \texttt{1:0:$\bot$}. It is not necessary 
  to evaluate $\bot$ to determine that the input list is not ordered. 

  Partial values represent an entire class of values. That is, \texttt{1:0:$\bot$} can 
  be viewed as a representation of the set of lists that have prefix \texttt{[1, 0]}. 
  By checking properties on partial values, it is possible to falsify a property for 
  an entire class of values in one go, in some cases greatly reducing the amount of 
  testcases needed. 

\subsubsection{LeanCheck} 

  Where SmallCheck uses a value's \textit{depth} to bound the number of test values, 
  LeanCheck uses a value's \textit{size} \cite{matela2017tools}, where size is defined 
  as the number of construction applications of positive arity. Both SmallCheck and 
  LeanCheck contain functionality to enumerate functions similar to QuickCheck's 
  \texttt{Coarbitrary}. 

\subsubsection{Feat}

  A downside to both SmallCheck and LeanCheck is that they do not provide an efficient 
  way to generate or sample large test values. QuickCheck has no problem with either, 
  but QuickCheck generators are often more tedious to write compared to their 
  SmallCheck counterpart. Feat \cite{duregaard2013feat} aims to fill this gap by 
  providing a way to efficiently enumerate algebraic types, employing memoization 
  techniques to efficiently find the $n^{th}$ element of an enumeration. 

\subsubsection{Hedgehog}

  Hedgehog \cite{hedgehog} is a framework similar to QuickCheck, that aims to be a 
  more modern alternative. It includes support for monadic effects in generators and 
  concurrent checking of properties. Additionally it supports automatic schrinking for many datatypes. Unlike QuickCheck and SmallCheck, HedgeHog does not support (partial) automatic derivation of generators, but rather chooses to supply a comprehensive set of combinators, which the user can then use to assemble generators.

\subsubsection{QuickChick} 

  QuickChick is a QuickCheck clone for the proof assistant Coq \cite
  {denes2014quickchick}. The fact that Coq is a proof assistant enables the user to 
  reason about the testing framework itself \cite{paraskevopoulou2015foundational}. 
  This allows one, for example, to prove that generators adhere to some distribution. 

\subsubsection{QuickSpec}

  A surprising application of property based testing is the automatic generation of 
  program specifications, proposed by Claessen et al. \cite{claessen2010quickspec} 
  with the tool \textit{QuickSpec}. QuickSpec automatically generates a set of 
  candidate formal specifications given a list of pure functions, specifically in the 
  form of algebraic equations. Random property based testing is then used to falsify 
  specifications. In the end, the user is presented with a set of equations for which 
  no counterexample was found.  

\subsection{Type universes}

  !! TODO: write a short introduction to this part

\subsubsection{Indexed Functors}

  Löh and Magalhães propose in their paper \emph{Generic Programming with Indexed 
  Functors} \cite{loh2011generic} a type universe for generic programming in Agda, 
  that is able to handle a large class of indexed datatypes. Their universe takes the 
  universe of regular types as a basis. 
  
  The semantics of the universe, however, is not a functor \ensuremath{\HSCon{Set}\HSSym{→}\HSCon{Set}}, but rather an 
  \emph{indexed} functor \ensuremath{\HSSpecial{(}\HSCon{I}\HSSym{→}\HSCon{Set}\HSSpecial{)}\HSSym{→}\HSCon{O}\HSSym{→}\HSCon{Set}}. Additionally, they add some 
  combinators, such as first order constructors to encode isomorphisms and fixpoints 
  as part of their universe. 

\subsubsection{Combinatorial species}

  Combinatorial species \cite{yorgey2010species} were 
  originally developed as a mathematical framework, but can also be used as an 
  alternative way of looking at datatypes. A species can, in terms of functional 
  programming, be thought of as a type constructor with one polymorphic argument. 
  Haskell’s ADTs (or regular types in general) can be described by definining familiar 
  combinators for species, such as sum and product.

\subsubsection{Mutually recursive sums of product}

  On of the more simple representations is the so called \textit{Sum of Products} view 
  \cite{de2014true}, where datatypes are respresented as a choice between an arbitrary 
  amount of constructors, each of which can have any arity. This view corresponds to 
  how datatypes are defined in Haskell, and is closely related to the universe of 
  regular types. As we will see (for example in section \ref{patternfunctors}), other 
  universes too employ sum and product combinators to describe the structure of 
  datatypes, though they do not necessarily enforce the representation to be in 
  disjunctive normal form. Sum of Products, in its simplest form, cannot represent 
  mutually recursive families of datatypes. An extension that allows this has been 
  developed in \cite{miraldo2018sums}, and is available as a Haskell library through 
  \emph{Hackage}.  

\subsection{Techniques for generating constrained test data}

  Some work in the direction of generating constrained test data has already be done. For example, an approach to generation of constrained test data for Coq's QuickChick was proposed by Lampropoulos et al. \cite{lampropoulos2017generating} in their 2017 paper \textit{Generating Good Generators for Inductive Relations}. They observe a common pattern where the required test data is of a simple type, but constrained by some precondition. The precondition is then given by some inductive dependent relation indexed by said simple type. The \ensuremath{\HSCon{Sorted}} datatype shown in section \ref{sec:introduction} is a good example of this

  They derive generators for such datatypes by abstracting over dependent inductive relations indexed by simple types. For every constructor, the resulting type uses a set of expressions as indices, that may depend on the constructor's arguments and universally quantified variables. These expressions induce a set of unification constraints that apply when using that particular constructor. These unification constraints are then used when constructing generators to ensure that only values for which the dependent inductive relation is inhabited are generated. 

   Claessen and Duregaard \cite{claessen2015generating} adapt the techniques described by Duregaard \cite{duregaard2013feat} to allow efficient generation of constrained data. They use a variation on rejection sampling, where the space of values is gradually refined by rejecting classes of values through partial evaluation (similar to Lazy SmallCheck \cite{runciman2008smallcheck}) until a value satisfying the imposed constrained is found. 

\subsection{Generating well-typed lambda terms}

  A problem often considered in literature is the generation of (well-typed) lambda 
  terms \cite{palka2011testing, grygiel2013counting, claessen2015generating}. Good 
  generation of arbitrary program terms is especially interesting in the context of 
  testing compiler infrastructure, and lambda terms provide a natural first step 
  towards that goal. 

  An alternative approach centered around the semantics of the simply typed lambda 
  calculus is described by Pa{\l}ka et al. \cite{palka2011testing}. Contrary to the 
  work done by Claessen and Duregaard \cite{claessen2015generating}, where 
  typechecking is viewed as a black box, they utilize definition of the typing rules 
  to devise an algorithm for generation of random lambda terms. The basic approach is 
  to take some input type, and randomly select an inference rule from the set of rules 
  that could have been applied to arrive at the goal type. Obviously, such a procedure 
  does not guarantee termination, as repeated application of the function application 
  rule will lead to an arbitrarily large goal type. As such, the algorithm requires a 
  maximum search depth and backtracking in order to guarantee that a suitable term 
  will eventually be generated, though it is not guaranteed that such a term exists if 
  a bound on term size is enforced \cite{moczurad2000statistical}. 

  Wang \cite{wang2005generating} considers the problem of generating closed untyped 
  lambda terms. Furthermore, Claessen and Duregaard \cite{claessen2015generating} specifically apply their work to the problem of generating well-typed lambda terms. 

\section{Conclusion}

  !! TODO: introduce this section

\subsection{Summary of Results}

  In this thesis, we have explored various approaches to the generation of test data using datatype generic programming, with the ultimate goal being to be able to synthesize well-formed program terms. Based on the observation that constrained test data can often be described as an indexed family, we approached this problem by looking at how to generate values of indexed families. We have looked at three distinct type universes, starting with the universe of Regular types, which is able to describe a set of algebraic datatypes roughly equal to the algebraic datatypes in Haskell 98 \cite{jones2003haskell}. We described this universe in Agda, and showed how a generator can be derived from a code in this universe. Although the exact generator type is kept abstract in this derivation, we have described an example instantiation where generators are functions of type \ensuremath{\HSCon{Int}\HSSym{\to} \HSCon{List}\;\HSVar{a}}, similar to SmallCheck's \ensuremath{\HSCon{Series}} \cite{runciman2008smallcheck}. For this particular generator type, we have proved that the generator derived from a code is \emph{complete}. That is, every value of the type described by the input code will eventually end up in the enumeration. 

  Next, we looked at two more complicated type universes that are able to describe (some) indexed datatypes: \emph{Indexed Containers} \cite{altenkirch2015indexed} and \emph{Indexed Descriptions} \cite{dagand2013cosmology}. For both universes, we described how a generic generator may be constructed from codes in these universes. For the universe of indexed descriptions, we also proved that the enumerative instantiation of the generator type satisfied our completeness property. For indexed containers, we were unfortuantely not able to complete this proof. Attempts to construct a proof using the same structure as used to construct the completeness proofs for regular types and indexed descriptions failed, as this approach would require induction over function types. 

  Having constructed a mechanism that allows generation for arbitrary indexed families in Agda, we implemented the generic generator for indexed descriptions in Haskell. Although in order to enforce correctness of the generated data in Haskell's type system we needed to impose some restrictions on the descriptions that could be used, we were still able to describe all the example datatypes. We used this implementation to generate some example constrained test data, including well-typed lambda terms. The final result is a Haskell library that is able to generate constrained test data, given that the user provides a description of an indexed family that describes the desired test data. 
  
\subsection{Remaing Problems}

  Although theoretically our one could use our library to generate values of arbitrary indexed families, there are some caveats. First, finding a description that accurately describes an indexed family is all but trivial. Often, there exist multiple descriptions that all describe the same datatype. These different descriptions are all mapped to distinct generators, which may not necessarily exhibit the same behavior in terms of computational efficiency, or the order in which elements are generated. The fact that Haskell's type system in no way enforces the semantics of the input description to be actually isomorphic to the datatype it describes leaves room for mistakes when defining descriptions and the conversion between their semantics and the desired datatype. Furthermore, it is hard to say how well this approach scales when we require more complex test data, especially since this would require the programmer to come up with increasingly complex descriptions. Although our Agda formalization allows us to be reasonably confident that the generators we derive indeed produce values of the intended datatype, we have no knowledge about how efficient they are at doing this, and to what extent a generator's efficiency depends on the structure of the derived generator. 

\subsection{Instantiation of the abstract generator type}

  !! Write a bit here about codata and sized types + explain why we abandoned this approach in the first place ... 

\section{Future Work}

  As highlighted in the previous section, there is plenty of room for improvement upon the current state of the work. Hence, there are many possible paths of future work. In this section we will discuss a few of the possibilities. 

\subsubsection{Generator optimizations}

  As of yet, no work has been done to make generators more efficient. In practice, this means that the derived generators are likely to be too slow to generate usable data for most practical applications. One of the more promising approaches to fix this is by memoization. It is likely that a generator solves the same subproblem many times, so it could greatly benefit in terms of efficiency by reusing previous solutions. For example, when generating a well-typed lambda term, the generator might encounter the same combination of goal context and type multiple times, meaning that it solves the same subproblem more often than it needs to. We might find inspiration in the work done by Claessen and Dureg{\aa}rd \cite{duregaard2013feat}, who devised a memoization strategy that allows for efficient indexing of the enumeration of algebraic datatypes. 

\subsubsection{Generating mutually recursive families}

  As of yet, the library we have developed cannot be used to generate inhabitants of mutually recursive datatypes. This is a severe limitation, as many abstract syntax datatypes utilize mutual recursion. Type universes that are able to represent mutually recursive types exist \cite{miraldo2018sums , yakushev2009generic}, however they are not necessarily able to represent arbitrary indexed families. Bringert and Ranta \cite{bringert2006pattern} propose a pattern for converting mutually recursive types to a GADT, indexed with a tag that marks which datatype of the mutually recursive family a recursive position refers to. Yakushev et al. \cite{yakushev2009generic} use this technique for their approach. Our Haskell library is expressive enough to generate values for these GADT's, so this appears to be a promising approach to generation of mutualy recursive indexed families. 

\subsubsection{Integration with existing testing frameworks}

  We have provided a sample instantiation of the abstract generator type as a bounded enumeration. However, theoretically it is possible to transform the abstract generator type to any desired generator type, as long as we are able to come up with a suitable mapping. This allows our library to be potentially integrated with external testing libaries by defining a mapping between the abstract generator type, and the type of generators used by a particular library. For SmallCheck, this is simple enough, as their generator type is almost exactly equal to our example instantiation. However, when transforming abstract generators to sampling generators (such as used in QuickCheck and Hedgehog), this mapping is not at all trivial. Most notably, it is not immediately clear how we should deal with generators that produce no elements, and recursive positions. Especially deriving \emph{sized} generators for the QuickCheck library is challenging without including additional information in the abstract generator type. 

\subsubsection{Property based testing for GADT's}

  Most testing frameworks for Haskell currently only include functionality to generate values of regular algebraic datatypes. If we were to test a function that has a GADT as its input type, we are only left with the possibility of defining a custom generator for the type. Since the universe of indexed descriptions is potentially expressive enough to describe any GADT, we could leverage the work from this thesis to extend existing testing libraries with the possibility to automatically derive generators for GADT's. 

\subsubsection{Increasing usability and practicality of the Haskell Library}

  Currently, the provided library that implements generic generators for indexed descriptions is very basic, and requires the user to supply both a type family describing the datatype, as well as a singleton value. Additionally, they need to write a conversion function that converts the generated values to a non-indexed type. In terms of practicality and usability there is much to be gained by further automating this process. Possibilities include the definition of smart constructors to abstract over common patterns, and using template Haskell \cite{sheard2002template} to (partially) automate the definition of the singleton description from the type level description. 

\subsubsection{Generation of function types}

  As of yet, we only briefly touched upon the subject of generating function types when deriving generators for indexed containers. However, the ability to generate functions may come in useful, for example when representing programs using \emph{Higher Order Abstract Syntax} (HOAS) \cite{pfenning1988higher}. This would require the co-enumerative generators described in section \ref{} to be extended to be able to derive generators producing function types from indexed descriptions. 

\subsubsection{Generating well-formed programs in a realistic programming language}

  The examples presented in this thesis are mostly relatively simple indexed families. In order to further investigate the practical applicability of our work, we think that it is essential to study how our approach applies to a more complex example. Prime candidates for this purpose are more complex variations on the simply typed lambda calculus, such as \emph{system F}, which often serve as the compilation target of higher-level languages (such as Haskell)

%% \appendix
%% \chapter{Datatype Definitions}
%% %include src/appA/body.lhs

\backmatter
\listoffigures
%% \listoftables

\bibliographystyle{acm}
\bibliography{references}

\end{document}


