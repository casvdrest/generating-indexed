\documentclass[11pt]{article}

%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
%
\ReadOnlyOnce{agda.fmt}%


\RequirePackage[T1]{fontenc}
\RequirePackage[utf8x]{inputenc}
\RequirePackage{ucs}
\RequirePackage{amsfonts}

\providecommand\mathbbm{\mathbb}

% TODO: Define more of these ...
\DeclareUnicodeCharacter{737}{\textsuperscript{l}}
\DeclareUnicodeCharacter{8718}{\ensuremath{\blacksquare}}
\DeclareUnicodeCharacter{8759}{::}
\DeclareUnicodeCharacter{9669}{\ensuremath{\triangleleft}}
\DeclareUnicodeCharacter{8799}{\ensuremath{\stackrel{\scriptscriptstyle ?}{=}}}
\DeclareUnicodeCharacter{10214}{\ensuremath{\llbracket}}
\DeclareUnicodeCharacter{10215}{\ensuremath{\rrbracket}}

% TODO: This is in general not a good idea.
\providecommand\textepsilon{$\epsilon$}
\providecommand\textmu{$\mu$}


%Actually, varsyms should not occur in Agda output.

% TODO: Make this configurable. IMHO, italics doesn't work well
% for Agda code.

\renewcommand\Varid[1]{\mathord{\textsf{#1}}}
\let\Conid\Varid
\newcommand\Keyword[1]{\textsf{\textbf{#1}}}
\EndFmtInput

%

\usepackage[top=4cm,bottom=4cm,left=3cm,right=3cm]{geometry} 
\usepackage{fancyhdr}
\pagestyle{fancy}

\usepackage{textcomp}

\DeclareUnicodeCharacter{10218}{$\langle\langle$}
\DeclareUnicodeCharacter{10219}{$\rangle\rangle$}
\DeclareUnicodeCharacter{7522}{\textsubscript{i}}
\DeclareUnicodeCharacter{10631}{$\llparenthesis$}
\DeclareUnicodeCharacter{10632}{$\rrparenthesis$}

\renewcommand{\figurename}{Listing}
\usepackage[font=small,labelfont=bf]{caption}

\usepackage{cite}

\usepackage[T1]{fontenc}
\rhead{\leftmark}
\cfoot{\textsc{Utrecht University}}
\rfoot{\thepage}
% Quotes
\usepackage{epigraph}

\usepackage{geometry}

\usepackage{textgreek}

\usepackage{multicol}

% Math
\usepackage{amssymb}
\usepackage[inference, ligature]{semantic}
% Tables
\usepackage{amsmath}

% Colors
\usepackage{xcolor, color, colortbl}
\colorlet{gray}{gray!70}
\colorlet{green}{green!50}
\definecolor{darkblue}{HTML}{1D577A}
\definecolor{rred}{HTML}{C03425}
\definecolor{darkgreen}{HTML}{8BB523}
\definecolor{ppurple}{HTML}{6B1B7F}
\definecolor{pblack}{HTML}{000000}
\definecolor{darkyellow}{HTML}{C0B225}

% Links
\usepackage{hyperref}
\definecolor{linkcolour}{rgb}{0,0.2,0.6}
\hypersetup{colorlinks,breaklinks,urlcolor=linkcolour,linkcolor=linkcolour,citecolor=blue}

% Geometry
%\usepackage{titling}
%\setlength{\droptitle}{-7em}

\title{Program Term Generation Through Enumeration of Indexed datatypes (Thesis Proposal)}
\author{Cas van der Rest}
\date{\today}

\begin{document}

\maketitle

\tableofcontents 

\newpage

\section{Introduction}

A common way of asserting a program's correctness is by defining properties that should universally hold, and asserting these properties over a range of random inputs. This technique is commonly referred to as \textit{property based testing}, and generally consists of a two-step process. Defining properties that universially hold on all inputs, and defining \textit{generators} that sample random values from the space of possible inputs. \textit{QuickCheck} \cite{claessen2011quickcheck} is likely the most well known tool for performing property based tests on haskell programs. 

Although coming up with a set of properties that propertly captures a program's behavious might initially seem to be the most involved part of the process, defining suitable generators for complex input data is actually quite difficult as well. Questions such as how to handle datatypes that are inhabited by an infinite numer of values arise, or how to deal with constrained input data. The answers to these questions are reasonably well understood for \textit{Algebraic datatypes (ADT's)}, but no general solution exists when more complex input data is required. In particular, little is known about enumerating and generating inhabitants of \textit{Indexed datatypes}. 

The latter may be of interest when considering property based testing in the context of languages with a more elaborate type system than Haskell's, such as \textit{Agda} or \textit{Idris}. Since the techniques used in existing tools such as QuickCheck and SmallCheck for the most part only apply to regular datatypes, meaning that there is no canonical way of generating inhabitants for a large class of datatypes in these languages. 

Besides the obvious applications to property based testing in the context of dependently typed languages, a broader understanding of how we can generate inhabitants of indexed datatypes may prove useful in other areas as well. Since we can often capture a programming language's semantics as an indexed datatype, efficient generation of inhabitants of such a datatype may prove useful for testing compiler infrastructure. 

\subsection{Problem Statement}

\subsection{Research Questions and Contributions}

What is the problem? Illustrate with an example. \cite{runciman2008smallcheck, altenkirch2003generic}

What is/are your research questions/contributions? \cite{claessen2011quickcheck}

\section{Background}

What is the existing technology and literature that I'll be
studying/using in my research \cite{denes2014quickchick, yorgey2010species, loh2011generic, norell2008dependently}

\subsection{Dependently Typed Programming \& Agda}

\subsubsection{Dependent Type Theory}

Dependent type theory extends a type theory with the possiblity of defining types that depend on values. In addition to familiar constructs, such as the unit type ($\top$) and the empty type $\bot$, one can use so-called $\Pi$-types and $\Sigma$-types. $\Pi$-types capture the idea of dependent function types, that is, \textit{functions} whose output type may depent on the values of its input. Given some type $A$ and a family $P$ of types indexed by values of type $A$ (i.e. $P$ has type $A \rightarrow Type$), $\Pi$-types have the following definition: 

\begin{equation*}
\Pi_{(x : A)} P(x) \quad \equiv \quad (x : A) \rightarrow P(x) 
\end{equation*}

In a similar spirit, $\Sigma$-types are ordered \textit{pairs} of which the type of the second value may depend on te first value of the pair. 

\begin{equation*}
\Sigma_{(x : A)} P(x) \quad \equiv \quad (x : A) \times P(x) 
\end{equation*}

The Curry-Howard equivalence extends to $\Pi$- and $\Sigma$-types as well: they can be used to model universal and existential quantification. 

\subsubsection{Codata}

Agda requires all functions to be total. This means that they are required to yield a result on all inputs in a \textit{finite} amount of time. This means that we cannot work with infinite structures in the same way as in Haskell. For example, the following is perfectly fine in Haskell: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{infinity}\;\Conid{::}\;\Conid{Nat}{}\<[E]%
\\
\>[B]{}\Varid{infinity}\;\mathrel{=}\;\Conid{Suc}\;\Varid{infinity}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{29}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{isSmaller}\;\Conid{::}\;\Conid{Nat}\;\to \;\Conid{Nat}\;\to \;\Conid{Bool}{}\<[E]%
\\
\>[B]{}\Varid{isSmaller}\;(\Conid{Suc}\;\Varid{n})\;{}\<[20]%
\>[20]{}\Conid{Zero}\;{}\<[29]%
\>[29]{}\mathrel{=}\;\Conid{False}{}\<[E]%
\\
\>[B]{}\Varid{isSmaller}\;\Conid{Zero}\;{}\<[20]%
\>[20]{}(\Conid{Suc}\;\Varid{n})\;{}\<[32]%
\>[32]{}\mathrel{=}\;\Conid{True}{}\<[E]%
\\
\>[B]{}\Varid{isSmaller}\;(\Conid{Suc}\;\Varid{n})\;{}\<[20]%
\>[20]{}(\Conid{Suc}\;\Varid{m})\;{}\<[29]%
\>[29]{}\mathrel{=}\;\Varid{isSmaller}\;\Varid{n}\;\Varid{m}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks



\subsection{Property Based Testing}

\subsubsection{Existing Libraries}

\subsubsection{Generating Test Data}

\subsection{Generic Programming \& Type Universes}

If we desire to abstract over the structure of datatypes, we need a suitable type universe to do so. Many such universes have been developed and studied; this section discusses a few of them. 

\subsubsection{Regular Datatypes}

The term \textit{regular datatypes} is often used to refer to the class of datatypes that can be assembled using any combination of products, coproducts, unary constructors, constants (a position that is inhabited by a value of another type) and recursive positions. Roughly, this class consists of ADT's in haskell, though mutual recursion is not accounted for. 

Any value that lives in the induced by these combinators describes a regular datatype, and is generally referred to as a \textit{pattern functor}. We can define a datatype in agda that captures these values: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{Reg}\;\mathbin{:}\;\Conid{Set}\;\Varid{→}\;{}\<[19]%
\>[19]{}\Conid{Set}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Conid{U}\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Conid{Reg}\;\Varid{⊥}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Conid{K}\;{}\<[10]%
\>[10]{}\mathbin{:}\;(\Varid{a}\;\mathbin{:}\;\Conid{Set})\;\Varid{→}\;\Conid{Reg}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{\char95 ⊕\char95 }\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\Varid{→}\;\Conid{Reg}\;\Varid{a}\;\Varid{→}\;\Conid{Reg}\;\Varid{a}\;\Varid{→}\;\Conid{Reg}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{\char95 ⊗\char95 }\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\Varid{→}\;\Conid{Reg}\;\Varid{a}\;\Varid{→}\;\Conid{Reg}\;\Varid{a}\;\Varid{→}\;\Conid{Reg}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Conid{I}\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Conid{Reg}\;\Varid{⊥}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Pattern functors, i.e. values of the $Reg$ datatype, can be interpreted as types. Inhabitants of the interpretation of a pattern functor correspond to the inhabitants of the type that is represented by said pattern functor. We use the following interpretation function: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{⟦\char95 ⟧}\;\mathbin{:}\;\Conid{Reg}\;\Varid{→}\;\Conid{Set}\;\Varid{→}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Varid{⟦}\;\Conid{U}\;{}\<[16]%
\>[16]{}\Varid{⟧}\;\Varid{r}\;\mathrel{=}\;\Varid{⊤}{}\<[E]%
\\
\>[B]{}\Varid{⟦}\;\Conid{K}\;\Varid{a}\;{}\<[16]%
\>[16]{}\Varid{⟧}\;\Varid{r}\;\mathrel{=}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{⟦}\;\Varid{reg₁}\;\Varid{⊕}\;\Varid{reg₂}\;{}\<[16]%
\>[16]{}\Varid{⟧}\;\Varid{r}\;\mathrel{=}\;\Varid{⟦}\;\Varid{reg₁}\;\Varid{⟧}\;\Varid{r}\;\Varid{⊎}\;\Varid{⟦}\;\Varid{reg₂}\;\Varid{⟧}\;\Varid{r}{}\<[E]%
\\
\>[B]{}\Varid{⟦}\;\Varid{reg₁}\;\Varid{⊗}\;\Varid{reg₂}\;{}\<[16]%
\>[16]{}\Varid{⟧}\;\Varid{r}\;\mathrel{=}\;\Varid{⟦}\;\Varid{reg₁}\;\Varid{⟧}\;\Varid{r}\;\Varid{×}\;\Varid{⟦}\;\Varid{reg₂}\;\Varid{⟧}\;\Varid{r}{}\<[E]%
\\
\>[B]{}\Varid{⟦}\;\Conid{I}\;{}\<[16]%
\>[16]{}\Varid{⟧}\;\Varid{r}\;\mathrel{=}\;\Varid{r}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Notice that recursive positions are left explicit. This means that we require an appropriate fixed-point combinator to find a pattern functor's representation in \textbf{Set}. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Varid{μ}\;(\Varid{f}\;\mathbin{:}\;\Conid{Reg})\;\mathbin{:}\;\Conid{Set}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{`μ}\;\mathbin{:}\;\Varid{⟦}\;\Varid{f}\;\Varid{⟧}\;(\Varid{μ}\;\Varid{f})\;\Varid{→}\;\Varid{μ}\;\Varid{f}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\paragraph{Example} Consider the pattern functor corresponding to the definition of $List$: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{List'}\;\mathbin{:}\;\Conid{Set}\;\Varid{→}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Conid{List'}\;\Varid{a}\;\mathrel{=}\;\Varid{μ}\;(\Conid{U}\;\Varid{⊕}\;(\Conid{K}\;\Varid{a}\;\Varid{⊗}\;\Conid{I})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Notice that this pattern functor denotes a choice between a unary constructor ($[]]$), and a constructor that takes a constant of type $a$ and a recursive positions as arguments ($::$). We can define conversion functions between the standard $List$ type, and the interpretation of our pattern functor: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{fromList}\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\Varid{→}\;\Conid{List}\;\Varid{a}\;\Varid{→}\;\Conid{List'}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{fromList}\;\Varid{[]}\;\mathrel{=}\;\Varid{`μ}\;(\Varid{inj₁}\;\Varid{tt}){}\<[E]%
\\
\>[B]{}\Varid{fromList}\;(\Varid{x}\;\Varid{∷}\;\Varid{xs})\;\mathrel{=}\;\Varid{`μ}\;(\Varid{inj₂}\;(\Varid{x}\;\Varid{,}\;\Varid{fromList}\;\Varid{xs})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{toList}\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\Varid{→}\;\Conid{List'}\;\Varid{a}\;\Varid{→}\;\Conid{List}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{toList}\;(\Varid{`μ}\;(\Varid{inj₁}\;\Varid{tt}))\;\mathrel{=}\;\Varid{[]}{}\<[E]%
\\
\>[B]{}\Varid{toList}\;(\Varid{`μ}\;(\Varid{inj₂}\;(\Varid{fst}\;\Varid{,}\;\Varid{snd})))\;\mathrel{=}\;\Varid{fst}\;\Varid{∷}\;\Varid{toList}\;\Varid{snd}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

With these definitions, it is now trivial to show that there is indeed an isomorphism between the two: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{isoList₁}\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{xs}\;\mathbin{:}\;\Conid{List}\;\Varid{a}\mskip1.5mu\}\;\Varid{→}\;\Varid{toList}\;(\Varid{fromList}\;\Varid{xs})\;\Varid{≡}\;\Varid{xs}{}\<[E]%
\\
\>[B]{}\Varid{isoList₁}\;\{\mskip1.5mu \Varid{xs}\;\mathrel{=}\;\Varid{[]}\mskip1.5mu\}\;\mathrel{=}\;\Varid{refl}{}\<[E]%
\\
\>[B]{}\Varid{isoList₁}\;\{\mskip1.5mu \Varid{xs}\;\mathrel{=}\;\Varid{x}\;\Varid{∷}\;\Varid{xs}\mskip1.5mu\}\;\mathrel{=}\;\Varid{cong}\;(\Varid{\char95 ∷\char95 }\;\Varid{x})\;\Varid{isoList₁}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{isoList₂}\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{xs}\;\mathbin{:}\;\Conid{List'}\;\Varid{a}\mskip1.5mu\}\;\Varid{→}\;\Varid{fromList}\;(\Varid{toList}\;\Varid{xs})\;\Varid{≡}\;\Varid{xs}{}\<[E]%
\\
\>[B]{}\Varid{isoList₂}\;\{\mskip1.5mu \Varid{xs}\;\mathrel{=}\;\Varid{`μ}\;(\Varid{inj₁}\;\Varid{x})\mskip1.5mu\}\;\mathrel{=}\;\Varid{refl}{}\<[E]%
\\
\>[B]{}\Varid{isoList₂}\;\{\mskip1.5mu \Varid{xs}\;\mathrel{=}\;\Varid{`μ}\;(\Varid{inj₂}\;(\Varid{fst}\;\Varid{,}\;\Varid{snd}))\mskip1.5mu\}\;\mathrel{=}\;\Varid{cong}\;(\Varid{`μ}\;\Varid{∘}\;\Varid{inj₂}\;\Varid{∘}\;\Varid{\char95 ,\char95 }\;\Varid{fst})\;\Varid{isoList₂}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Using such isomorphisms, we can automatically derive functionality for datatypes that can be captured using pattern functors. We will see an example of this in section \ref{preliminary}, where we will derive enumeration of inhabitants for arbitrary pattern functors. 

\subsubsection{Ornaments}

\textit{Ornaments} \cite{dagand2017essence} provide a type universe in which we can describe the structure of indexed datatypes in a very index-centric way. Indexed datatypes are described by \textit{Signatures}, consisting of three elements:

\begin{itemize}
\item 
A function $Op : I \rightarrow Set$, that relates indices to operations/constructors

\item 
A function $Ar : Op\ i \rightarrow Set$, that describes the arity (with respect to recursive positions) for an operation 

\item 
A typing discipline $Ty : Ar\ op \rightarrow I$, that describes indices for recursive positions. 

\end{itemize}

When combined into a single structure, we say that $\Sigma_D$ gives the signature of some indexed datatype $D : I \rightarrow Set$:  

\begin{equation*}
\Sigma_D(I)=
\begin{cases}
Op : I \rightarrow Set \\
Ar : Op\ i \rightarrow Set \\
Ty : Ar\ op \rightarrow I
\end{cases}
\end{equation*}

\paragraph{Example} Let us consider the signature for the $Vec$ type, given by $\Sigma_{Vec}(\mathbb{N})$. Recall the definition of the $Vec$ datatype in listing \ref{vecdef}. It has the following relation between index and operations: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{Op-vec}\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\Varid{→}\;\Conid{ℕ}\;\Varid{→}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Conid{Op-vec}\;\Varid{zero}\;\mathrel{=}\;\Varid{⊤}{}\<[E]%
\\
\>[B]{}\Conid{Op-vec}\;\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;(\Varid{suc}\;\Varid{n})\;\mathrel{=}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

If the index is $zero$, we have only the unary constructor $[]$ at our disposal, hence \texttt{Op-vec zero = top}. If the index is $suc\ n$, the number of possible constructions for $Vec$ corresponds to the set of inhabitants of its element type, hence we say that \texttt{Op-vec (suc n) = a}. 

The $[]$ constructor has no recursive argument, so its arity is $\bot$. Similarly, $cons\ a$ takes one recursive argument, so its arity is $\top$:  

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{Ar-vec}\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\Varid{→}\;(\Varid{n}\;\mathbin{:}\;\Conid{ℕ})\;\Varid{→}\;\Conid{Op-vec}\;\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;\Varid{n}\;\Varid{→}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Conid{Ar-vec}\;\Varid{zero}\;\Varid{tt}\;\mathrel{=}\;\Varid{⊥}{}\<[E]%
\\
\>[B]{}\Conid{Ar-vec}\;(\Varid{suc}\;\Varid{n})\;\Varid{op}\;\mathrel{=}\;\Varid{⊤}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The definition of $::$ dictates that if the index is equal to $suc\ n$, the index of the recursive argument needs to be $n$. We interpret this as follows: if a vector has length (suc n), its tail has length n. This induces the following typing discipline for $Vec$: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{Ty-vec}\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\Varid{→}\;(\Varid{n}\;\mathbin{:}\;\Conid{ℕ})\;\Varid{→}\;(\Varid{op}\;\mathbin{:}\;\Conid{Op-vec}\;\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;\Varid{n})\;\Varid{→}\;\Conid{Ar-vec}\;\Varid{n}\;\Varid{op}\;\Varid{→}\;\Conid{ℕ}{}\<[E]%
\\
\>[B]{}\Conid{Ty-vec}\;\Varid{zero}\;\Varid{a}\;(){}\<[E]%
\\
\>[B]{}\Conid{Ty-vec}\;(\Varid{suc}\;\Varid{n})\;\Varid{a}\;\Varid{tt}\;\mathrel{=}\;\Varid{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This defines the signature for $Vec$: $\Sigma_{Vec} \triangleq \texttt{Op-vec} \triangleleft^\texttt{Ty-vec} \texttt{Ar-vec}$. 

\begin{figure}[h] \hrulefill
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{Vec}\;\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;(\Conid{A}\;\mathbin{:}\;\Conid{Set}\;\Varid{a})\;\mathbin{:}\;\Conid{ℕ}\;\Varid{→}\;\Conid{Set}\;\Varid{a}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{[]}\;{}\<[7]%
\>[7]{}\mathbin{:}\;\Conid{Vec}\;\Conid{A}\;\Varid{zero}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{\char95 ∷\char95 }\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{n}\mskip1.5mu\}\;(\Varid{x}\;\mathbin{:}\;\Conid{A})\;(\Varid{xs}\;\mathbin{:}\;\Conid{Vec}\;\Conid{A}\;\Varid{n})\;\Varid{→}\;\Conid{Vec}\;\Conid{A}\;(\Varid{suc}\;\Varid{n}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\hrulefill
\caption{Definition of $Vec$}\label{vecdef}
\end{figure}

We can define signatures for non-indexed datatypes as well by choosing a trivial index, e.g. $I = \top$. This gives $\Sigma_{\mathbb{N}} \triangleq \texttt{Op-nat} \triangleleft^\texttt{Ty-nat} \texttt{Ar-nat}$ with the definitions given in listing \ref{signat-def}: 

\begin{figure} \hrulefill
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{Op-nat}\;\mathbin{:}\;\Varid{⊤}\;\Varid{→}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Conid{Op-nat}\;\Varid{tt}\;\mathrel{=}\;\Varid{⊤}\;\Varid{⊎}\;\Varid{⊤}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{Ar-nat}\;\mathbin{:}\;\Conid{Op-nat}\;\Varid{tt}\;\Varid{→}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Conid{Ar-nat}\;(\Varid{inj₁}\;\Varid{x})\;\mathrel{=}\;\Varid{⊥}{}\<[E]%
\\
\>[B]{}\Conid{Ar-nat}\;(\Varid{inj₂}\;\Varid{y})\;\mathrel{=}\;\Varid{⊤}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{Ty-nat}\;\mathbin{:}\;(\Varid{op}\;\mathbin{:}\;\Conid{Op-nat}\;\Varid{tt})\;\Varid{→}\;\Conid{Ar-nat}\;\Varid{op}\;\Varid{→}\;\Varid{⊤}{}\<[E]%
\\
\>[B]{}\Conid{Ty-nat}\;(\Varid{inj₁}\;\Varid{x})\;(){}\<[E]%
\\
\>[B]{}\Conid{Ty-nat}\;(\Varid{inj₂}\;\Varid{y})\;\Varid{tt}\;\mathrel{=}\;\Varid{tt}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\hrulefill
\caption{Signature definition for $\mathbb{N}$}\label{signat-def}
\end{figure}

\subsubsection{Functorial Species}

\subsubsection{Indexed Functors}

\subsection{Blockchain Semantics}

\subsubsection{BitML}

\subsubsection{UTXO \& Extended UTXO}

\begin{itemize}

\item
Libraries for property based testing (QuickCheck, (Lazy) SmallCheck, QuickChick, QuickSpec)

\item 
Type universes (ADT's, Ornaments) \cite{ko2016programming, dagand2017essence}

\item 
Generic programming techniques. (pattern functors, indexed functors, functorial species)

\item 
Techniques to generate complex or constrained data (Generating constrained random data with uniform distribution, Generators for inductive relations)

\item 
Techniques to speed up generation of data (Memoization, FEAT)

\item 
Formal specification of blockchain (bitml, (extended) UTxO ledger) \cite{zahnentferner2018chimeric, zahnentferner2018abstract}

\item 
Representing potentially infinite data in Agda (Colists, coinduction, sized types)

\end{itemize}

Below is a bit of Agda code: 

\begin{figure}[h] \hrulefill
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{26}{@{}>{\hspre}l<{\hspost}@{}}%
\column{39}{@{}>{\hspre}l<{\hspost}@{}}%
\column{42}{@{}>{\hspre}l<{\hspost}@{}}%
\column{45}{@{}>{\hspre}l<{\hspost}@{}}%
\column{64}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{Γ-match}\;\mathbin{:}\;(\Varid{τ}\;\mathbin{:}\;\Conid{Ty})\;\Varid{→}\;\Varid{⟪}\;\Varid{ωᵢ}\;(\Varid{λ}\;\Conid{Γ}\;\Varid{→}\;\Conid{Σ[}\;\Varid{α}\;\Varid{∈}\;\Conid{Id}\;\mskip1.5mu]\;\Conid{Γ}\;[\mskip1.5mu \;\Varid{α}\;\Varid{↦}\;\Varid{τ}\;\mskip1.5mu])\;\Varid{⟫}{}\<[E]%
\\
\>[B]{}\Conid{Γ-match}\;\Varid{τ}\;\Varid{μ}\;\Varid{∅}\;\mathrel{=}\;\Varid{uninhabited}{}\<[E]%
\\
\>[B]{}\Conid{Γ-match}\;\Varid{τ}\;\Varid{μ}\;(\Varid{α}\;\Varid{↦}\;\Varid{σ}\;\Varid{∷}\;\Conid{Γ})\;\Keyword{with}\;\Varid{τ}\;\Varid{≟}\;\Varid{σ}{}\<[E]%
\\
\>[B]{}\Conid{Γ-match}\;\Varid{τ}\;\Varid{μ}\;(\Varid{α}\;\Varid{↦}\;\Varid{τ}\;\Varid{∷}\;\Conid{Γ})\;{}\<[26]%
\>[26]{}\mid \;\Varid{yes}\;\Varid{refl}\;{}\<[39]%
\>[39]{}\mathrel{=}\;{}\<[42]%
\>[42]{}\Varid{⦇}\;{}\<[45]%
\>[45]{}(\Varid{α}\;\Varid{,}\;\Conid{TOP})\;{}\<[64]%
\>[64]{}\Varid{⦈}\;{}\<[E]%
\\
\>[39]{}\Varid{∥}\;{}\<[42]%
\>[42]{}\Varid{⦇}\;{}\<[45]%
\>[45]{}(\Conid{Σ-map}\;\Conid{POP})\;(\Varid{μ}\;\Conid{Γ})\;{}\<[64]%
\>[64]{}\Varid{⦈}{}\<[E]%
\\
\>[B]{}\Conid{Γ-match}\;\Varid{τ}\;\Varid{μ}\;(\Varid{α}\;\Varid{↦}\;\Varid{σ}\;\Varid{∷}\;\Conid{Γ})\;{}\<[26]%
\>[26]{}\mid \;\Varid{no}\;\Varid{¬p}\;{}\<[39]%
\>[39]{}\mathrel{=}\;{}\<[42]%
\>[42]{}\Varid{⦇}\;{}\<[45]%
\>[45]{}(\Conid{Σ-map}\;\Conid{POP})\;(\Varid{μ}\;\Conid{Γ})\;{}\<[64]%
\>[64]{}\Varid{⦈}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\hrulefill
\caption{Definition of \textGamma-match}
\end{figure}

\begin{figure}[h] \hrulefill
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{Env}\;\mathbin{:}\;\Conid{Set}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{∅}\;{}\<[9]%
\>[9]{}\mathbin{:}\;\Conid{Env}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{\char95 ↦\char95 ∷\char95 }\;\mathbin{:}\;\Conid{Id}\;\Varid{→}\;\Conid{Ty}\;\Varid{→}\;\Conid{Env}\;\Varid{→}\;\Conid{Env}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Varid{\char95 [\char95 ↦\char95 ]}\;\mathbin{:}\;\Conid{Env}\;\Varid{→}\;\Conid{Id}\;\Varid{→}\;\Conid{Ty}\;\Varid{→}\;\Conid{Set}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{TOP}\;{}\<[8]%
\>[8]{}\mathbin{:}\;{}\<[11]%
\>[11]{}\Varid{∀}\;{}\<[14]%
\>[14]{}\{\mskip1.5mu \Conid{Γ}\;\Varid{α}\;\Varid{τ}\mskip1.5mu\}\;{}\<[E]%
\\
\>[11]{}\Varid{→}\;{}\<[14]%
\>[14]{}(\Varid{α}\;\Varid{↦}\;\Varid{τ}\;\Varid{∷}\;\Conid{Γ})\;[\mskip1.5mu \;\Varid{α}\;\Varid{↦}\;\Varid{τ}\;\mskip1.5mu]{}\<[E]%
\\
\>[B]{}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{POP}\;{}\<[8]%
\>[8]{}\mathbin{:}\;{}\<[11]%
\>[11]{}\Varid{∀}\;{}\<[14]%
\>[14]{}\{\mskip1.5mu \Conid{Γ}\;\Varid{α}\;\Varid{β}\;\Varid{τ}\;\Varid{σ}\mskip1.5mu\}\;\Varid{→}\;\Conid{Γ}\;[\mskip1.5mu \;\Varid{α}\;\Varid{↦}\;\Varid{τ}\;\mskip1.5mu]\;{}\<[E]%
\\
\>[11]{}\Varid{→}\;{}\<[14]%
\>[14]{}(\Varid{β}\;\Varid{↦}\;\Varid{σ}\;\Varid{∷}\;\Conid{Γ})\;[\mskip1.5mu \;\Varid{α}\;\Varid{↦}\;\Varid{τ}\;\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\hrulefill
\caption{Envirionment definition and membership in \textit{Agda}}
\end{figure}

\begin{figure}[h] 
\hrulefill

\begin{equation*}
  TOP\ \frac{}{(\textalpha \mapsto \texttau : \Gamma) [\textalpha \mapsto \texttau]} 
\quad\quad\quad 
  POP\ \frac{\Gamma[\textalpha \mapsto \texttau]}{(\textbeta \mapsto \textsigma : \Gamma) [ \textalpha \mapsto \texttau ] }
\end{equation*}

\begin{equation*}
  VAR\ \frac{\Gamma[\textalpha \mapsto \tau]}{\Gamma \vdash \textalpha : \tau}
\quad\quad\quad
  ABS\ \frac{\Gamma , \textalpha \mapsto \sigma \vdash t : \tau}{\Gamma \vdash \lambda \textalpha \rightarrow t : \sigma \rightarrow \tau}
\end{equation*}

\begin{equation*}
  APP\ \frac{\Gamma \vdash f : \sigma \rightarrow \tau \quad \Gamma \vdash x : \sigma}{\Gamma \vdash f x : \tau}
\quad\quad\quad 
  LET\ \frac{\Gamma \vdash e : \sigma \quad \Gamma , \textalpha \mapsto \sigma \vdash t : \tau}
            {\Gamma \vdash \texttt{ let } \textalpha := e \texttt{ in } t : \tau }
\end{equation*}

\hrulefill
\caption{Semantics of the \textit{Simply Typed Lambda Calculus}}
\end{figure}


\section{Preliminary results}\label{preliminary}

What examples can you handle already? \cite{lampropoulos2017generating}

What prototype have I built? \cite{duregaard2013feat, claessen2010quickspec}

How can I generalize these results? What problems have I identified or
do I expect? \cite{yakushev2009generic}

\section{Timetable and planning}

What will I do with the remainder of my thesis? \cite{claessen2015generating}

Give an approximate estimation/timetable for what you will do and when you will be done.

\newpage
\bibliography{references}{}
\bibliographystyle{plain}

\end{document}paramter
