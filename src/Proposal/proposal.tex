\documentclass[11pt]{article}

%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
%
\ReadOnlyOnce{agda.fmt}%


\RequirePackage[T1]{fontenc}
\RequirePackage[utf8x]{inputenc}
\RequirePackage{ucs}
\RequirePackage{amsfonts}

\providecommand\mathbbm{\mathbb}

% TODO: Define more of these ...
\DeclareUnicodeCharacter{737}{\textsuperscript{l}}
\DeclareUnicodeCharacter{8718}{\ensuremath{\blacksquare}}
\DeclareUnicodeCharacter{8759}{::}
\DeclareUnicodeCharacter{9669}{\ensuremath{\triangleleft}}
\DeclareUnicodeCharacter{8799}{\ensuremath{\stackrel{\scriptscriptstyle ?}{=}}}
\DeclareUnicodeCharacter{10214}{\ensuremath{\llbracket}}
\DeclareUnicodeCharacter{10215}{\ensuremath{\rrbracket}}

% TODO: This is in general not a good idea.
\providecommand\textepsilon{$\epsilon$}
\providecommand\textmu{$\mu$}


%Actually, varsyms should not occur in Agda output.

% TODO: Make this configurable. IMHO, italics doesn't work well
% for Agda code.

\renewcommand\Varid[1]{\mathord{\textsf{#1}}}
\let\Conid\Varid
\newcommand\Keyword[1]{\textsf{\textbf{#1}}}
\EndFmtInput

%

\usepackage[top=4cm,bottom=4cm,left=3cm,right=3cm]{geometry} 
\usepackage{fancyhdr}
\pagestyle{fancy}

\usepackage{textcomp}

\DeclareUnicodeCharacter{10218}{$\langle\langle$}
\DeclareUnicodeCharacter{10219}{$\rangle\rangle$}
\DeclareUnicodeCharacter{7522}{\textsubscript{i}}
\DeclareUnicodeCharacter{10631}{$\llparenthesis$}
\DeclareUnicodeCharacter{10632}{$\rrparenthesis$}

\renewcommand{\figurename}{Listing}
\usepackage[font=small,labelfont=bf]{caption}

\usepackage{cite}

\usepackage[T1]{fontenc}
\rhead{\leftmark}
\cfoot{\textsc{Utrecht University}}
\rfoot{\thepage}
% Quotes
\usepackage{epigraph}

\usepackage{geometry}

\usepackage{textgreek}

\usepackage{multicol}

% Math
\usepackage{amssymb}
\usepackage[inference, ligature]{semantic}
% Tables
\usepackage{amsmath}

% Colors
\usepackage{xcolor, color, colortbl}
\colorlet{gray}{gray!70}
\colorlet{green}{green!50}
\definecolor{darkblue}{HTML}{1D577A}
\definecolor{rred}{HTML}{C03425}
\definecolor{darkgreen}{HTML}{8BB523}
\definecolor{ppurple}{HTML}{6B1B7F}
\definecolor{pblack}{HTML}{000000}
\definecolor{darkyellow}{HTML}{C0B225}

% Links
\usepackage{hyperref}
\definecolor{linkcolour}{rgb}{0,0.2,0.6}
\hypersetup{colorlinks,breaklinks,urlcolor=linkcolour,linkcolor=linkcolour,citecolor=blue}

% Geometry
%\usepackage{titling}
%\setlength{\droptitle}{-7em}

\title{Program Term Generation Through Enumeration of Indexed datatypes (Thesis Proposal)}
\author{Cas van der Rest}
\date{\today}

\begin{document}

\maketitle

\tableofcontents 

\newpage

\section{Introduction}

A common way of asserting a program's correctness is by defining properties that should universally hold, and asserting these properties over a range of random inputs. This technique is commonly referred to as \textit{property based testing}, and generally consists of a two-step process. Defining properties that universially hold on all inputs, and defining \textit{generators} that sample random values from the space of possible inputs. \textit{QuickCheck} \cite{claessen2011quickcheck} is likely the most well known tool for performing property based tests on haskell programs. 

Although coming up with a set of properties that propertly captures a program's behavious might initially seem to be the most involved part of the process, defining suitable generators for complex input data is actually quite difficult as well. Questions such as how to handle datatypes that are inhabited by an infinite numer of values arise, or how to deal with constrained input data. The answers to these questions are reasonably well understood for \textit{Algebraic datatypes (ADT's)}, but no general solution exists when more complex input data is required. In particular, little is known about enumerating and generating inhabitants of \textit{Indexed datatypes}. 

The latter may be of interest when considering property based testing in the context of languages with a more elaborate type system than Haskell's, such as \textit{Agda} or \textit{Idris}. Since the techniques used in existing tools such as QuickCheck and SmallCheck for the most part only apply to regular datatypes, meaning that there is no canonical way of generating inhabitants for a large class of datatypes in these languages. 

Besides the obvious applications to property based testing in the context of dependently typed languages, a broader understanding of how we can generate inhabitants of indexed datatypes may prove useful in other areas as well. Since we can often capture a programming language's semantics as an indexed datatype, efficient generation of inhabitants of such a datatype may prove useful for testing compiler infrastructure. 

\subsection{Problem Statement}

\subsection{Research Questions and Contributions}

What is the problem? Illustrate with an example. \cite{runciman2008smallcheck, altenkirch2003generic}

What is/are your research questions/contributions? \cite{claessen2011quickcheck}

\section{Background}

What is the existing technology and literature that I'll be
studying/using in my research \cite{denes2014quickchick, yorgey2010species, loh2011generic, norell2008dependently}

\subsection{Dependently Typed Programming \& Agda}

\subsubsection{Dependent Type Theory}

Dependent type theory extends a type theory with the possiblity of defining types that depend on values. In addition to familiar constructs, such as the unit type ($\top$) and the empty type $\bot$, one can use so-called $\Pi$-types and $\Sigma$-types. $\Pi$-types capture the idea of dependent function types, that is, \textit{functions} whose output type may depent on the values of its input. Given some type $A$ and a family $P$ of types indexed by values of type $A$ (i.e. $P$ has type $A \rightarrow Type$), $\Pi$-types have the following definition: 

\begin{equation*}
\Pi_{(x : A)} P(x) \quad \equiv \quad (x : A) \rightarrow P(x) 
\end{equation*}

In a similar spirit, $\Sigma$-types are ordered \textit{pairs} of which the type of the second value may depend on te first value of the pair. 

\begin{equation*}
\Sigma_{(x : A)} P(x) \quad \equiv \quad (x : A) \times P(x) 
\end{equation*}

The Curry-Howard equivalence extends to $\Pi$- and $\Sigma$-types as well: they can be used to model universal and existential quantification. 

\subsubsection{Codata and Sized Types}

Agda requires all functions to be total, where total means that they should be defined on any possible input, and give a result in a finite amount of time. The latter means that Agda is equipped with a termination checker that tries to prove that functions terminate. It is implied by undecidability of the halting problem that such a checker cannot be both sound and complete. Agda's termination checker is sound, meaning that there are functions that terminate which get rejected. This means that we cannot represent infinite structures in the same way as in haskell. For example, we might use the following definition in Haskell: \texttt{nats = 0 : map (+1) nats}. A similar definition in Agda will get rejected by the termination checker. 

\subsection{Property Based Testing}

\subsubsection{Existing Libraries}

\subsubsection{Generating Test Data}

\subsection{Generic Programming \& Type Universes}

If we desire to abstract over the structure of datatypes, we need a suitable type universe to do so. Many such universes have been developed and studied; this section discusses a few of them. 

\subsubsection{Regular Datatypes}\label{patternfunctors}

The term \textit{regular datatypes} is often used to refer to the class of datatypes that can be assembled using any combination of products, coproducts, unary constructors, constants (a position that is inhabited by a value of another type) and recursive positions. 

Any value that lives in universe induced by these combinators describes a regular datatype, and is generally referred to as a \textit{pattern functor}. We can define a datatype in agda that captures these values: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{Reg}\;\mathbin{:}\;\Conid{Set}\;\Varid{→}\;{}\<[19]%
\>[19]{}\Conid{Set}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Conid{U}\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Conid{Reg}\;\Varid{⊥}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Conid{K}\;{}\<[10]%
\>[10]{}\mathbin{:}\;(\Varid{a}\;\mathbin{:}\;\Conid{Set})\;\Varid{→}\;\Conid{Reg}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{\char95 ⊕\char95 }\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\Varid{→}\;\Conid{Reg}\;\Varid{a}\;\Varid{→}\;\Conid{Reg}\;\Varid{a}\;\Varid{→}\;\Conid{Reg}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{\char95 ⊗\char95 }\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\Varid{→}\;\Conid{Reg}\;\Varid{a}\;\Varid{→}\;\Conid{Reg}\;\Varid{a}\;\Varid{→}\;\Conid{Reg}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Conid{I}\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Conid{Reg}\;\Varid{⊥}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Pattern functors can be interpreted as types in such a way that inhabitants of the interpreted type correspond to inhabitants of the type that is represented by the functor.  

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{⟦\char95 ⟧}\;\mathbin{:}\;\Conid{Reg}\;\Varid{→}\;\Conid{Set}\;\Varid{→}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Varid{⟦}\;\Conid{U}\;{}\<[16]%
\>[16]{}\Varid{⟧}\;\Varid{r}\;\mathrel{=}\;\Varid{⊤}{}\<[E]%
\\
\>[B]{}\Varid{⟦}\;\Conid{K}\;\Varid{a}\;{}\<[16]%
\>[16]{}\Varid{⟧}\;\Varid{r}\;\mathrel{=}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{⟦}\;\Varid{reg₁}\;\Varid{⊕}\;\Varid{reg₂}\;{}\<[16]%
\>[16]{}\Varid{⟧}\;\Varid{r}\;\mathrel{=}\;\Varid{⟦}\;\Varid{reg₁}\;\Varid{⟧}\;\Varid{r}\;\Varid{⊎}\;\Varid{⟦}\;\Varid{reg₂}\;\Varid{⟧}\;\Varid{r}{}\<[E]%
\\
\>[B]{}\Varid{⟦}\;\Varid{reg₁}\;\Varid{⊗}\;\Varid{reg₂}\;{}\<[16]%
\>[16]{}\Varid{⟧}\;\Varid{r}\;\mathrel{=}\;\Varid{⟦}\;\Varid{reg₁}\;\Varid{⟧}\;\Varid{r}\;\Varid{×}\;\Varid{⟦}\;\Varid{reg₂}\;\Varid{⟧}\;\Varid{r}{}\<[E]%
\\
\>[B]{}\Varid{⟦}\;\Conid{I}\;{}\<[16]%
\>[16]{}\Varid{⟧}\;\Varid{r}\;\mathrel{=}\;\Varid{r}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Notice that recursive positions are left explicit. This means that we require an appropriate fixed-point combinator: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Varid{μ}\;(\Varid{f}\;\mathbin{:}\;\Conid{Reg})\;\mathbin{:}\;\Conid{Set}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{`μ}\;\mathbin{:}\;\Varid{⟦}\;\Varid{f}\;\Varid{⟧}\;(\Varid{μ}\;\Varid{f})\;\Varid{→}\;\Varid{μ}\;\Varid{f}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\paragraph{Example} Consider the pattern functor corresponding to the definition of $List$: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{List'}\;\mathbin{:}\;\Conid{Set}\;\Varid{→}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Conid{List'}\;\Varid{a}\;\mathrel{=}\;\Varid{μ}\;(\Conid{U}\;\Varid{⊕}\;(\Conid{K}\;\Varid{a}\;\Varid{⊗}\;\Conid{I})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Notice that this pattern functor denotes a choice between a unary constructor ($[]]$), and a constructor that takes a constant of type $a$ and a recursive positions as arguments ($::$). We can define conversion functions between the standard $List$ type, and the interpretation of our pattern functor: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{fromList}\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\Varid{→}\;\Conid{List}\;\Varid{a}\;\Varid{→}\;\Conid{List'}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{fromList}\;\Varid{[]}\;\mathrel{=}\;\Varid{`μ}\;(\Varid{inj₁}\;\Varid{tt}){}\<[E]%
\\
\>[B]{}\Varid{fromList}\;(\Varid{x}\;\Varid{∷}\;\Varid{xs})\;\mathrel{=}\;\Varid{`μ}\;(\Varid{inj₂}\;(\Varid{x}\;\Varid{,}\;\Varid{fromList}\;\Varid{xs})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{toList}\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\Varid{→}\;\Conid{List'}\;\Varid{a}\;\Varid{→}\;\Conid{List}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{toList}\;(\Varid{`μ}\;(\Varid{inj₁}\;\Varid{tt}))\;\mathrel{=}\;\Varid{[]}{}\<[E]%
\\
\>[B]{}\Varid{toList}\;(\Varid{`μ}\;(\Varid{inj₂}\;(\Varid{fst}\;\Varid{,}\;\Varid{snd})))\;\mathrel{=}\;\Varid{fst}\;\Varid{∷}\;\Varid{toList}\;\Varid{snd}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Using such isomorphisms, we can automatically derive functionality for datatypes that can be captured using pattern functors. We will see an example of this in section \ref{derivegen}, where we will derive enumeration of inhabitants for arbitrary pattern functors. 

\subsubsection{Ornaments}

\textit{Ornaments} \cite{dagand2017essence} provide a type universe in which we can describe the structure of indexed datatypes in a very index-centric way. Indexed datatypes are described by \textit{Signatures}, consisting of three elements:

\begin{itemize}
\item 
A function $Op : I \rightarrow Set$, that relates indices to operations/constructors

\item 
A function $Ar : Op\ i \rightarrow Set$, that describes the arity (with respect to recursive positions) for an operation 

\item 
A typing discipline $Ty : Ar\ op \rightarrow I$, that describes indices for recursive positions. 

\end{itemize}

When combined into a single structure, we say that $\Sigma_D$ gives the signature of some indexed datatype $D : I \rightarrow Set$:  

\begin{equation*}
\Sigma_D(I)=
\begin{cases}
Op : I \rightarrow Set \\
Ar : Op\ i \rightarrow Set \\
Ty : Ar\ op \rightarrow I
\end{cases}
\end{equation*}

\paragraph{Example} Let us consider the signature for the $Vec$ type, given by $\Sigma_{Vec}(\mathbb{N})$. Recall the definition of the $Vec$ datatype in listing \ref{vecdef}. It has the following relation between index and operations: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{Op-vec}\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\Varid{→}\;\Conid{ℕ}\;\Varid{→}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Conid{Op-vec}\;\Varid{zero}\;\mathrel{=}\;\Varid{⊤}{}\<[E]%
\\
\>[B]{}\Conid{Op-vec}\;\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;(\Varid{suc}\;\Varid{n})\;\mathrel{=}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

If the index is $zero$, we have only the unary constructor $[]$ at our disposal, hence \texttt{Op-vec zero = top}. If the index is $suc\ n$, the number of possible constructions for $Vec$ corresponds to the set of inhabitants of its element type, hence we say that \texttt{Op-vec (suc n) = a}. 

The $[]$ constructor has no recursive argument, so its arity is $\bot$. Similarly, $cons\ a$ takes one recursive argument, so its arity is $\top$:  

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{Ar-vec}\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\Varid{→}\;(\Varid{n}\;\mathbin{:}\;\Conid{ℕ})\;\Varid{→}\;\Conid{Op-vec}\;\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;\Varid{n}\;\Varid{→}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Conid{Ar-vec}\;\Varid{zero}\;\Varid{tt}\;\mathrel{=}\;\Varid{⊥}{}\<[E]%
\\
\>[B]{}\Conid{Ar-vec}\;(\Varid{suc}\;\Varid{n})\;\Varid{op}\;\mathrel{=}\;\Varid{⊤}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The definition of $::$ dictates that if the index is equal to $suc\ n$, the index of the recursive argument needs to be $n$. We interpret this as follows: if a vector has length (suc n), its tail has length n. This induces the following typing discipline for $Vec$: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{Ty-vec}\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\Varid{→}\;(\Varid{n}\;\mathbin{:}\;\Conid{ℕ})\;\Varid{→}\;(\Varid{op}\;\mathbin{:}\;\Conid{Op-vec}\;\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;\Varid{n})\;\Varid{→}\;\Conid{Ar-vec}\;\Varid{n}\;\Varid{op}\;\Varid{→}\;\Conid{ℕ}{}\<[E]%
\\
\>[B]{}\Conid{Ty-vec}\;\Varid{zero}\;\Varid{a}\;(){}\<[E]%
\\
\>[B]{}\Conid{Ty-vec}\;(\Varid{suc}\;\Varid{n})\;\Varid{a}\;\Varid{tt}\;\mathrel{=}\;\Varid{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This defines the signature for $Vec$: $\Sigma_{Vec} \triangleq \texttt{Op-vec} \triangleleft^\texttt{Ty-vec} \texttt{Ar-vec}$. 

\begin{figure}[h] \hrulefill
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{Vec}\;\{\mskip1.5mu \Varid{a}\mskip1.5mu\}\;(\Conid{A}\;\mathbin{:}\;\Conid{Set}\;\Varid{a})\;\mathbin{:}\;\Conid{ℕ}\;\Varid{→}\;\Conid{Set}\;\Varid{a}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{[]}\;{}\<[7]%
\>[7]{}\mathbin{:}\;\Conid{Vec}\;\Conid{A}\;\Varid{zero}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{\char95 ∷\char95 }\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{n}\mskip1.5mu\}\;(\Varid{x}\;\mathbin{:}\;\Conid{A})\;(\Varid{xs}\;\mathbin{:}\;\Conid{Vec}\;\Conid{A}\;\Varid{n})\;\Varid{→}\;\Conid{Vec}\;\Conid{A}\;(\Varid{suc}\;\Varid{n}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\hrulefill
\caption{Definition of $Vec$}\label{vecdef}
\end{figure}

We can define signatures for non-indexed datatypes as well by choosing a trivial index, e.g. $I = \top$. This gives $\Sigma_{\mathbb{N}} \triangleq \texttt{Op-nat} \triangleleft^\texttt{Ty-nat} \texttt{Ar-nat}$ with the definitions given in listing \ref{signat-def}: 

\begin{figure} \hrulefill
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{Op-nat}\;\mathbin{:}\;\Varid{⊤}\;\Varid{→}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Conid{Op-nat}\;\Varid{tt}\;\mathrel{=}\;\Varid{⊤}\;\Varid{⊎}\;\Varid{⊤}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{Ar-nat}\;\mathbin{:}\;\Conid{Op-nat}\;\Varid{tt}\;\Varid{→}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Conid{Ar-nat}\;(\Varid{inj₁}\;\Varid{x})\;\mathrel{=}\;\Varid{⊥}{}\<[E]%
\\
\>[B]{}\Conid{Ar-nat}\;(\Varid{inj₂}\;\Varid{y})\;\mathrel{=}\;\Varid{⊤}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{Ty-nat}\;\mathbin{:}\;(\Varid{op}\;\mathbin{:}\;\Conid{Op-nat}\;\Varid{tt})\;\Varid{→}\;\Conid{Ar-nat}\;\Varid{op}\;\Varid{→}\;\Varid{⊤}{}\<[E]%
\\
\>[B]{}\Conid{Ty-nat}\;(\Varid{inj₁}\;\Varid{x})\;(){}\<[E]%
\\
\>[B]{}\Conid{Ty-nat}\;(\Varid{inj₂}\;\Varid{y})\;\Varid{tt}\;\mathrel{=}\;\Varid{tt}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\hrulefill
\caption{Signature definition for $\mathbb{N}$}\label{signat-def}
\end{figure}

\subsubsection{Functorial Species}

\subsubsection{Indexed Functors}

\subsection{Blockchain Semantics}

\subsubsection{BitML}

\subsubsection{UTXO \& Extended UTXO}

\begin{itemize}

\item
Libraries for property based testing (QuickCheck, (Lazy) SmallCheck, QuickChick, QuickSpec)

\item 
Type universes (ADT's, Ornaments) \cite{ko2016programming, dagand2017essence}

\item 
Generic programming techniques. (pattern functors, indexed functors, functorial species)

\item 
Techniques to generate complex or constrained data (Generating constrained random data with uniform distribution, Generators for inductive relations)

\item 
Techniques to speed up generation of data (Memoization, FEAT)

\item 
Formal specification of blockchain (bitml, (extended) UTxO ledger) \cite{zahnentferner2018chimeric, zahnentferner2018abstract}

\item 
Representing potentially infinite data in Agda (Colists, coinduction, sized types)

\end{itemize}

Below is a bit of Agda code: 

\begin{figure}[h] \hrulefill
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{26}{@{}>{\hspre}l<{\hspost}@{}}%
\column{39}{@{}>{\hspre}l<{\hspost}@{}}%
\column{42}{@{}>{\hspre}l<{\hspost}@{}}%
\column{45}{@{}>{\hspre}l<{\hspost}@{}}%
\column{64}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{Γ-match}\;\mathbin{:}\;(\Varid{τ}\;\mathbin{:}\;\Conid{Ty})\;\Varid{→}\;\Varid{⟪}\;\Varid{ωᵢ}\;(\Varid{λ}\;\Conid{Γ}\;\Varid{→}\;\Conid{Σ[}\;\Varid{α}\;\Varid{∈}\;\Conid{Id}\;\mskip1.5mu]\;\Conid{Γ}\;[\mskip1.5mu \;\Varid{α}\;\Varid{↦}\;\Varid{τ}\;\mskip1.5mu])\;\Varid{⟫}{}\<[E]%
\\
\>[B]{}\Conid{Γ-match}\;\Varid{τ}\;\Varid{μ}\;\Varid{∅}\;\mathrel{=}\;\Varid{uninhabited}{}\<[E]%
\\
\>[B]{}\Conid{Γ-match}\;\Varid{τ}\;\Varid{μ}\;(\Varid{α}\;\Varid{↦}\;\Varid{σ}\;\Varid{∷}\;\Conid{Γ})\;\Keyword{with}\;\Varid{τ}\;\Varid{≟}\;\Varid{σ}{}\<[E]%
\\
\>[B]{}\Conid{Γ-match}\;\Varid{τ}\;\Varid{μ}\;(\Varid{α}\;\Varid{↦}\;\Varid{τ}\;\Varid{∷}\;\Conid{Γ})\;{}\<[26]%
\>[26]{}\mid \;\Varid{yes}\;\Varid{refl}\;{}\<[39]%
\>[39]{}\mathrel{=}\;{}\<[42]%
\>[42]{}\Varid{⦇}\;{}\<[45]%
\>[45]{}(\Varid{α}\;\Varid{,}\;\Conid{TOP})\;{}\<[64]%
\>[64]{}\Varid{⦈}\;{}\<[E]%
\\
\>[39]{}\Varid{∥}\;{}\<[42]%
\>[42]{}\Varid{⦇}\;{}\<[45]%
\>[45]{}(\Conid{Σ-map}\;\Conid{POP})\;(\Varid{μ}\;\Conid{Γ})\;{}\<[64]%
\>[64]{}\Varid{⦈}{}\<[E]%
\\
\>[B]{}\Conid{Γ-match}\;\Varid{τ}\;\Varid{μ}\;(\Varid{α}\;\Varid{↦}\;\Varid{σ}\;\Varid{∷}\;\Conid{Γ})\;{}\<[26]%
\>[26]{}\mid \;\Varid{no}\;\Varid{¬p}\;{}\<[39]%
\>[39]{}\mathrel{=}\;{}\<[42]%
\>[42]{}\Varid{⦇}\;{}\<[45]%
\>[45]{}(\Conid{Σ-map}\;\Conid{POP})\;(\Varid{μ}\;\Conid{Γ})\;{}\<[64]%
\>[64]{}\Varid{⦈}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\hrulefill
\caption{Definition of \textGamma-match}
\end{figure}

\begin{figure}[h] \hrulefill
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{Env}\;\mathbin{:}\;\Conid{Set}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{∅}\;{}\<[9]%
\>[9]{}\mathbin{:}\;\Conid{Env}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{\char95 ↦\char95 ∷\char95 }\;\mathbin{:}\;\Conid{Id}\;\Varid{→}\;\Conid{Ty}\;\Varid{→}\;\Conid{Env}\;\Varid{→}\;\Conid{Env}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Varid{\char95 [\char95 ↦\char95 ]}\;\mathbin{:}\;\Conid{Env}\;\Varid{→}\;\Conid{Id}\;\Varid{→}\;\Conid{Ty}\;\Varid{→}\;\Conid{Set}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{TOP}\;{}\<[8]%
\>[8]{}\mathbin{:}\;{}\<[11]%
\>[11]{}\Varid{∀}\;{}\<[14]%
\>[14]{}\{\mskip1.5mu \Conid{Γ}\;\Varid{α}\;\Varid{τ}\mskip1.5mu\}\;{}\<[E]%
\\
\>[11]{}\Varid{→}\;{}\<[14]%
\>[14]{}(\Varid{α}\;\Varid{↦}\;\Varid{τ}\;\Varid{∷}\;\Conid{Γ})\;[\mskip1.5mu \;\Varid{α}\;\Varid{↦}\;\Varid{τ}\;\mskip1.5mu]{}\<[E]%
\\
\>[B]{}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{POP}\;{}\<[8]%
\>[8]{}\mathbin{:}\;{}\<[11]%
\>[11]{}\Varid{∀}\;{}\<[14]%
\>[14]{}\{\mskip1.5mu \Conid{Γ}\;\Varid{α}\;\Varid{β}\;\Varid{τ}\;\Varid{σ}\mskip1.5mu\}\;\Varid{→}\;\Conid{Γ}\;[\mskip1.5mu \;\Varid{α}\;\Varid{↦}\;\Varid{τ}\;\mskip1.5mu]\;{}\<[E]%
\\
\>[11]{}\Varid{→}\;{}\<[14]%
\>[14]{}(\Varid{β}\;\Varid{↦}\;\Varid{σ}\;\Varid{∷}\;\Conid{Γ})\;[\mskip1.5mu \;\Varid{α}\;\Varid{↦}\;\Varid{τ}\;\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\hrulefill
\caption{Envirionment definition and membership in \textit{Agda}}
\end{figure}

\begin{figure}[h] 
\hrulefill

\begin{equation*}
  TOP\ \frac{}{(\textalpha \mapsto \texttau : \Gamma) [\textalpha \mapsto \texttau]} 
\quad\quad\quad 
  POP\ \frac{\Gamma[\textalpha \mapsto \texttau]}{(\textbeta \mapsto \textsigma : \Gamma) [ \textalpha \mapsto \texttau ] }
\end{equation*}

\begin{equation*}
  VAR\ \frac{\Gamma[\textalpha \mapsto \tau]}{\Gamma \vdash \textalpha : \tau}
\quad\quad\quad
  ABS\ \frac{\Gamma , \textalpha \mapsto \sigma \vdash t : \tau}{\Gamma \vdash \lambda \textalpha \rightarrow t : \sigma \rightarrow \tau}
\end{equation*}

\begin{equation*}
  APP\ \frac{\Gamma \vdash f : \sigma \rightarrow \tau \quad \Gamma \vdash x : \sigma}{\Gamma \vdash f x : \tau}
\quad\quad\quad 
  LET\ \frac{\Gamma \vdash e : \sigma \quad \Gamma , \textalpha \mapsto \sigma \vdash t : \tau}
            {\Gamma \vdash \texttt{ let } \textalpha := e \texttt{ in } t : \tau }
\end{equation*}

\hrulefill
\caption{Semantics of the \textit{Simply Typed Lambda Calculus}}
\end{figure}


\section{Preliminary results}\label{preliminary}

\subsection{Enumeration of Agda Types}

We look at how to enumerate various datatypes in Agda, starting with simple examples such as $\mathbb{N}$ or $Bool$, and progressively working towards more complex data. The first question we encounter is what the result of an enumeration should be. The ovious answer is that $enumerate a$ should return something of type $List a$, containing all possible values of type $a$. This is however not possible, as $List$ in Agda can only represent a finite list, and many datatypes, such as $\mathbb{N}$ have an infinite number of inhabitants. To solve this, we may either use the $Codata$ functionality from the standard library, or index our result with some kind of metric that limits the number of solutions to a finite set. The latter approach is what is used by both \textit{SmallCheck}\cite{} and \textit{LeanCheck}\cite{}, enumerating values up to a certain depth or size. 

We admit the same approach as the SmallCheck library, defining an enumerator/generator to be a function of type $\mathbb{N} \rightarrow List\ a$, where input argument signifies the maximum depth. By working with $List$, ensuring termination becomes a lot easier, since it is by definition a finite structure. Furthermore, proving properties about generators becomes more straightforward, as we can simply prove the desired properties about the $List$ type, and lift the result to our generator type. 

\subsubsection{Basic Combinators}

We can define a few basic combinators to allow composition of generators. 

\paragraph{Constants} Generators can yield a constant value, e.g. $true$ for the $Bool$ type. Unary constructors have a recursive depth of zero, so we simply return a singleton list: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{𝔾-pure}\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{n}\;\mathbin{:}\;\Conid{ℕ}\mskip1.5mu\}\;\Varid{→}\;\Varid{a}\;\Varid{→}\;\Conid{𝔾}\;\Varid{a}\;\Varid{n}{}\<[E]%
\\
\>[B]{}\Conid{𝔾-pure}\;\Varid{x}\;\anonymous \;\mathrel{=}\;[\mskip1.5mu \;\Varid{x}\;\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\paragraph{Application} Many datatypes are constructed by applying a constructor to a value of another datatype. An example is the $just$ constructor that takes a value of type $a$ and yields a value of type $Maybe a$. We can achieve this by lifting the familiar $map$ function for lists to the generator type: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{𝔾-map}\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\Varid{b}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{n}\;\mathbin{:}\;\Conid{ℕ}\mskip1.5mu\}\;\Varid{→}\;(\Varid{a}\;\Varid{→}\;\Varid{b})\;\Varid{→}\;\Conid{𝔾}\;\Varid{a}\;\Varid{n}\;\Varid{→}\;\Conid{𝔾}\;\Varid{b}\;\Varid{n}{}\<[E]%
\\
\>[B]{}\Conid{𝔾-map}\;\Varid{f}\;\Varid{x}\;\Varid{n}\;\mathrel{=}\;\Varid{map}\;\Varid{f}\;(\Varid{x}\;\Varid{n}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\paragraph{Product} When a constructor takes two or more values (e.g. $\_,\_$), enumerating all values that can be constructed using that constructor comes down to enumerating all possible combinations of its input values, and applying the constructor. Again, we can do this by defining the canonical cartesian product on lists, and lifing it to the generator type: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{list-ap}\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{ℓ}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{a}\;\Varid{b}\;\mathbin{:}\;\Conid{Set}\;\Varid{ℓ}\mskip1.5mu\}\;\Varid{→}\;\Conid{List}\;(\Varid{a}\;\Varid{→}\;\Varid{b})\;\Varid{→}\;\Conid{List}\;\Varid{a}\;\Varid{→}\;\Conid{List}\;\Varid{b}{}\<[E]%
\\
\>[B]{}\Varid{list-ap}\;\Varid{fs}\;\Varid{xs}\;\mathrel{=}\;\Varid{concatMap}\;(\Varid{λ}\;\Varid{f}\;\Varid{→}\;\Varid{map}\;\Varid{f}\;\Varid{xs})\;\Varid{fs}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{𝔾-ap}\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\Varid{b}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\Varid{→}\;\Conid{𝔾}\;(\Varid{a}\;\Varid{→}\;\Varid{b})\;\Varid{→}\;\Conid{𝔾}\;\Varid{a}\;\Varid{→}\;\Conid{𝔾}\;\Varid{b}{}\<[E]%
\\
\>[B]{}\Conid{𝔾-ap}\;\Varid{f}\;\Varid{x}\;\Varid{n}\;\mathrel{=}\;\Varid{list-ap}\;(\Varid{f}\;\Varid{n})\;(\Varid{x}\;\Varid{n}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Note that in addition to $\mathbb{G}-ap$, one also needs $\mathbb{G}-map$ to construct values using constructors with arity greater than one. Assuming $f$ generates values of type $a$, and $g$ generates values of type $b$, we can generate values of type $a \times b$ using the following snippet:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{pair}\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\Varid{b}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\Varid{→}\;\Conid{𝔾}\;\Varid{a}\;\Varid{→}\;\Conid{𝔾}\;\Varid{b}\;\Varid{→}\;\Conid{𝔾}\;(\Varid{a}\;\Varid{×}\;\Varid{b}){}\<[E]%
\\
\>[B]{}\Varid{pair}\;\Varid{f}\;\Varid{g}\;\mathrel{=}\;\Conid{𝔾-ap}\;(\Conid{𝔾-map}\;\Varid{\char95 ,\char95 }\;\Varid{f})\;\Varid{g}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Notice that $\mathbb{G}-map$, $\mathbb{G}-pure$ and $\mathbb{G}-ap$ make $\mathbb{G}$ an instance of both $Functor$ and $Applicative$, allowing us to use Agda's \textit{idiom brackets} to define generators. This allows us to write 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{49}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{pair}\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\Varid{b}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{n}\;\mathbin{:}\;\Conid{ℕ}\mskip1.5mu\}\;\Varid{→}\;\Conid{𝔾}\;\Varid{a}\;\Varid{n}\;\Varid{→}\;\Conid{𝔾}\;\Varid{b}\;\Varid{n}\;\Varid{→}\;{}\<[49]%
\>[49]{}\Conid{𝔾}\;(\Varid{a}\;\Varid{×}\;\Varid{b})\;\Varid{n}{}\<[E]%
\\
\>[B]{}\Varid{pair}\;\Varid{f}\;\Varid{g}\;\mathrel{=}\;\Varid{⦇}\;\Varid{f}\;\Varid{,}\;\Varid{g}\;\Varid{⦈}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

instead. 

\paragraph{Choice} Choice between generators can be defined by first defining a \textit{merge} function on lists 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{merge}\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{ℓ}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{a}\;\mathbin{:}\;\Conid{Set}\;\Varid{ℓ}\mskip1.5mu\}\;\Varid{→}\;\Conid{List}\;\Varid{a}\;\Varid{→}\;\Conid{List}\;\Varid{a}\;\Varid{→}\;\Conid{List}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{merge}\;{}\<[8]%
\>[8]{}\Varid{[]}\;{}\<[18]%
\>[18]{}\Varid{ys}\;{}\<[22]%
\>[22]{}\mathrel{=}\;{}\<[25]%
\>[25]{}\Varid{ys}{}\<[E]%
\\
\>[B]{}\Varid{merge}\;{}\<[8]%
\>[8]{}(\Varid{x}\;\Varid{∷}\;\Varid{xs})\;{}\<[18]%
\>[18]{}\Varid{ys}\;{}\<[22]%
\>[22]{}\mathrel{=}\;{}\<[25]%
\>[25]{}\Varid{x}\;\Varid{∷}\;\Varid{merge}\;\Varid{ys}\;\Varid{xs}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

and lifting it to the generator type: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{\char95 ∥\char95 }\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{n}\;\mathbin{:}\;\Conid{ℕ}\mskip1.5mu\}\;\Varid{→}\;\Conid{𝔾}\;\Varid{a}\;\Varid{n}\;\Varid{→}\;\Conid{𝔾}\;\Varid{a}\;\Varid{n}\;\Varid{→}\;\Conid{𝔾}\;\Varid{a}\;\Varid{n}{}\<[E]%
\\
\>[B]{}\Varid{x}\;\Varid{∥}\;\Varid{y}\;\mathrel{=}\;\Varid{λ}\;\Varid{n}\;\Varid{→}\;\Varid{merge}\;(\Varid{x}\;\Varid{n})\;(\Varid{y}\;\Varid{n}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Allowing for choice between constructors to be denoted in a very natural way: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{bool}\;\mathbin{:}\;\Conid{𝔾}\;\Conid{Bool}{}\<[E]%
\\
\>[B]{}\Varid{bool}\;{}\<[7]%
\>[7]{}\mathrel{=}\;{}\<[10]%
\>[10]{}\Varid{⦇}\;\Varid{true}\;{}\<[18]%
\>[18]{}\Varid{⦈}\;{}\<[E]%
\\
\>[7]{}\Varid{∥}\;{}\<[10]%
\>[10]{}\Varid{⦇}\;\Varid{false}\;\Varid{⦈}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\paragraph{Recursion} Simply using implicit recursion is the most natural way for defining generators for recursive datatypes. However, the following definition that generates inhabitants of $\mathbb{N}$ gets rejected by the termination checker: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{nats}\;\mathbin{:}\;\Conid{𝔾}\;\Conid{ℕ}{}\<[E]%
\\
\>[B]{}\Varid{nats}\;{}\<[7]%
\>[7]{}\mathrel{=}\;{}\<[10]%
\>[10]{}\Varid{⦇}\;\Varid{zero}\;{}\<[22]%
\>[22]{}\Varid{⦈}\;{}\<[E]%
\\
\>[7]{}\Varid{∥}\;{}\<[10]%
\>[10]{}\Varid{⦇}\;\Varid{suc}\;\Varid{nats}\;{}\<[22]%
\>[22]{}\Varid{⦈}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Though the above code does terminate, the termination checker cannot see this. Since the input depth is threaded through the applicative combinators, it is not immediately clear that the depth parameter decreases with the recursive call. We solve this by making recursive positions explicit:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{nat}\;\mathbin{:}\;\Conid{𝔾}\;\Conid{ℕ}\;\Varid{→}\;\Conid{𝔾}\;\Conid{ℕ}{}\<[E]%
\\
\>[B]{}\Varid{nat}\;\Varid{μ}\;{}\<[8]%
\>[8]{}\mathrel{=}\;{}\<[11]%
\>[11]{}\Varid{⦇}\;\Varid{zero}\;{}\<[20]%
\>[20]{}\Varid{⦈}\;{}\<[E]%
\\
\>[8]{}\Varid{∥}\;{}\<[11]%
\>[11]{}\Varid{⦇}\;\Varid{suc}\;\Varid{μ}\;{}\<[20]%
\>[20]{}\Varid{⦈}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

and defining an appropriate fixed-point combinator: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{fix}\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\Varid{→}\;(\Conid{𝔾}\;\Varid{a}\;\Varid{→}\;\Conid{𝔾}\;\Varid{a})\;\Varid{→}\;\Conid{𝔾}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{fix}\;\Varid{f}\;\Varid{0}\;{}\<[16]%
\>[16]{}\mathrel{=}\;{}\<[19]%
\>[19]{}\Varid{[]}{}\<[E]%
\\
\>[B]{}\Varid{fix}\;\Varid{f}\;(\Varid{suc}\;\Varid{n})\;{}\<[16]%
\>[16]{}\mathrel{=}\;{}\<[19]%
\>[19]{}\Varid{f}\;(\Varid{fix}\;\Varid{f})\;\Varid{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This definition of $fix$ gets rejected by the termination checker as well. We will see later how we can fix this. However, it should be apparent that it is terminating under the assumption that $f$ is well-behaved, i.e. it applies the $n$ supplied by $fix$ to its recursive positions. 

\subsubsection{Indexed Types}

Indexed types can be generated as well. Indexed generators can simply be defined as a $\Pi$-type, where the generated type depends on some input index: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{𝔾ᵢ}\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{i}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\Varid{→}\;(\Varid{i}\;\Varid{→}\;\Conid{Set})\;\Varid{→}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Conid{𝔾ᵢ}\;\{\mskip1.5mu \Varid{i}\;\mathrel{=}\;\Varid{i}\mskip1.5mu\}\;\Varid{a}\;\mathrel{=}\;(\Varid{x}\;\mathbin{:}\;\Varid{i})\;\Varid{→}\;\Conid{𝔾}\;(\Varid{a}\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The previously defined combinators can then be easily lifted to work with indexed types: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{\char95 ∥ᵢ\char95 }\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{i}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{a}\;\mathbin{:}\;\Varid{i}\;\Varid{→}\;\Conid{Set}\mskip1.5mu\}\;\Varid{→}\;\Conid{𝔾ᵢ}\;\Varid{a}\;\Varid{→}\;\Conid{𝔾ᵢ}\;\Varid{a}\;\Varid{→}\;\Conid{𝔾ᵢ}\;\Varid{a}{}\<[E]%
\\
\>[B]{}(\Varid{f}\;\Varid{∥ᵢ}\;\Varid{g})\;\Varid{i}\;\mathrel{=}\;\Varid{f}\;\Varid{i}\;\Varid{∥}\;\Varid{g}\;\Varid{i}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Throughout the code, a subscript $i$ is used to indicate that we deal with indexed types. 

\subsubsection{Guarantueeing Termination}

We can prove termination for our fixed-point combinator if we somehow enforce that its input function is well behaved. Consider the following example of a generator that does not terminate under our fixed-point combinator: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{bad}\;\mathbin{:}\;\Conid{𝔾}\;\Conid{ℕ}\;\Varid{→}\;\Conid{𝔾}\;\Conid{ℕ}{}\<[E]%
\\
\>[B]{}\Varid{bad}\;\Varid{μ}\;\anonymous \;\mathrel{=}\;\Varid{map}\;\Varid{suc}\;(\Varid{μ}\;\Varid{1}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Clearly, the base case of $fix$ is never reached. We can solve this by indexing generators with a natural number, and requiring generators to be called with their index, yielding the following alternative definition for $\mathbb{G}$: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{𝔾}\;\mathbin{:}\;\Conid{Set}\;\Varid{→}\;\Conid{ℕ}\;\Varid{→}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Conid{𝔾}\;\Varid{a}\;\Varid{m}\;\mathrel{=}\;(\Varid{p}\;\mathbin{:}\;\Conid{Σ[}\;\Varid{n}\;\Varid{∈}\;\Conid{ℕ}\;\mskip1.5mu]\;\Varid{n}\;\Varid{≡}\;\Varid{m})\;\Varid{→}\;\Conid{List}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We then use the following type for recursive generators: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{⟪\char95 ⟫}\;\mathbin{:}\;(\Conid{ℕ}\;\Varid{→}\;\Conid{Set})\;\Varid{→}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Varid{⟪}\;\Varid{a}\;\Varid{⟫}\;\mathrel{=}\;\Varid{∀}\;\{\mskip1.5mu \Varid{n}\;\mathbin{:}\;\Conid{ℕ}\mskip1.5mu\}\;\Varid{→}\;\Varid{a}\;\Varid{n}\;\Varid{→}\;\Varid{a}\;\Varid{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Meaning that the resulting generator can only apply \textit{its own input number} to recursive positions. If we now decrease the index explicitly in the fixed-point combinator, the termination checker is able to see that $fix$ allways terminates.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{34}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{fix}\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{a}\;\mathbin{:}\;\Conid{Set}\mskip1.5mu\}\;\Varid{→}\;(\Varid{n}\;\mathbin{:}\;\Conid{ℕ})\;\Varid{→}\;\Varid{⟪}\;\Conid{𝔾}\;\Varid{a}\;\Varid{⟫}\;\Varid{→}\;\Conid{𝔾}\;\Varid{a}\;\Varid{n}{}\<[E]%
\\
\>[B]{}\Varid{fix}\;\Varid{zero}\;{}\<[14]%
\>[14]{}\Varid{f}\;{}\<[17]%
\>[17]{}(\Varid{.0}\;\Varid{,}\;\Varid{refl})\;{}\<[34]%
\>[34]{}\mathrel{=}\;\Varid{[]}{}\<[E]%
\\
\>[B]{}\Varid{fix}\;(\Varid{suc}\;\Varid{n})\;{}\<[14]%
\>[14]{}\Varid{f}\;{}\<[17]%
\>[17]{}(\Varid{.suc}\;\Varid{n}\;\Varid{,}\;\Varid{refl})\;{}\<[34]%
\>[34]{}\mathrel{=}\;\Varid{f}\;\{\mskip1.5mu \Varid{n}\mskip1.5mu\}\;(\Varid{fix}\;\Varid{n}\;\Varid{f})\;(\Varid{n}\;\Varid{,}\;\Varid{refl}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Let us reconsider the previous counterexapmle: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{bad}\;\mathbin{:}\;\Varid{⟪}\;\Conid{𝔾}\;\Conid{ℕ}\;\Varid{⟫}{}\<[E]%
\\
\>[B]{}\Varid{bad}\;\Varid{μ}\;\Varid{n}\;\mathrel{=}\;\Varid{map}\;\Varid{suc}\;(\Varid{μ}\;(\Varid{1}\;\Varid{,}\;\{\mskip1.5mu \mathbin{!!}\mskip1.5mu\})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

It is impossible to complete this definition when applying any other value than $n$ to the recursive position. 

\subsubsection{Deriving Enumeration for Regular Types}\label{derivegen}

One may have noticed that the way in which generators are defined is structurally \textit{very} similar to how one would define the corresponding datatypes in Haskell. This similarity is intentional, and serves to illustrate that the definition of many generators is completely mechanical with respect to the structure of the underlying datatype. 

If we consider the universe of regular datatypes described in section \ref{patternfunctors}, we see that there is a clear correspondence between our generator combinators, and the constructors of the $Reg$ datatype. We can utilize this correspondence to automatically derive generators for datatypes, given an isomorphism with the fixed-point of some pattern functor. 

\paragraph{Generating pattern functors} Recall that by fixing the interpretation of some value $f$ of type $Reg$, we get a type whose inhabitants correspond to the inhabitants of the type that is represented by $f$. If we thus construct a generator that produces all inhabitants of this type, we have a generator that is isomorphic to a complete generator for the type represented by $f$. Doing this generically amounts to constructing a function of the following type: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{deriveGen}\;\mathbin{:}\;(\Varid{f}\;\mathbin{:}\;\Conid{Reg})\;\Varid{→}\;\Varid{⟪}\;\Conid{𝔾}\;(\Varid{μ}\;\Varid{f})\;\Varid{⟫}{}\<[E]%
\\
\>[B]{}\Varid{deriveGen}\;\mathrel{=}\;\{\mskip1.5mu \mathbin{!!}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Intuitively, this definition is easily completed by pattern matching on $f$, and returning the appropriate combinator. However, due to the intertwined usage of two fixed-point combinators to deal with recursion, there are quite a few subtleties that need to be taken into account. 

We simplify the definition slightly by expanding the generator type: $\mu$ has one constructor, with one argument, so we replace $\mu\ f$ by its constructor's argument: $\llbracket f \rrbracket\ (\mu\ f)$. 

Let us now consider the branch of $deriveGen$ that deals with coproducts. We would like to simply write the following:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{deriveGen}\;(\Varid{f₁}\;\Varid{⊕}\;\Varid{f₂})\;\Varid{μ}\;\mathrel{=}\;\Varid{⦇}\;\Varid{inj₁}\;(\Varid{deriveGen}\;\Varid{f₁}\;\Varid{μ})\;\Varid{⦈}\;\Varid{∥}\;\Varid{⦇}\;\Varid{inj₂}\;(\Varid{deriveGen}\;\Varid{f₂}\;\Varid{μ})\;\Varid{⦈}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This definition is incorrect, however. The recursive call $deriveGen\ f_1$ yields a generator of type $\langle\langle\ \mathbb{G}\ (\llbracket\ f_1\ \rrbracket\ (\mu\ f_1))\ \rangle\rangle$, meaning that two things go wrong: The recursive argument $\mu$ we apply to the recursive call has the wrong type, and recursive positions in $f_1$ refer to values of type $\mu\ f_1$ instead of $\mu\ (f_1 \oplus f_2)$. A similar problem occurs when attempting to define a suitable definition for products. 

We solve this issue by \textit{remembering} the top-level pattern functor for which we are deriving a generator when entering recursive calls to $deriveGen$. This can be done by having the recursive argument be a generator for the interpretation of this top-level pattern functor: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{deriveGen}\;\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{n}\;\mathbin{:}\;\Conid{ℕ}\mskip1.5mu\}\;\Varid{→}\;(\Varid{f}\;\Varid{g}\;\mathbin{:}\;\Conid{Reg})\;\Varid{→}\;\Conid{𝔾}\;(\Varid{⟦}\;\Varid{g}\;\Varid{⟧}\;(\Varid{μ}\;\Varid{g}))\;\Varid{n}\;\Varid{→}\;\Conid{𝔾}\;(\Varid{⟦}\;\Varid{f}\;\Varid{⟧}\;(\Varid{μ}\;\Varid{g}))\;\Varid{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

By using the type signature defined above instead, the previously shown defintion for the coproduct branch is accepted. 

In most cases, the initial call to $deriveGen$ will have the same value for $f$ and $g$. Observe that $\forall f \in Reg\ .\ deriveGen\ f\ f : \mathbb{G}\ (\llbracket\ f\ \rrbracket\ (\mu\ f))\ n \rightarrow \mathbb{G}\ (\llbracket\ f\ \rrbracket\ (\mu\ f))\ n$, thus we can use $fix$ to obtain a genrator that generates values of type $\llbracket\ f\ \rrbracket\ (\mu\ f))$. 

\paragraph{Deriving generators from isomorphism} We use the following record to witness an isomorphism betwen type $a$ and $b$: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{record}\;\Varid{\char95 ≅\char95 }\;(\Varid{a}\;\Varid{b}\;\mathbin{:}\;\Conid{Set})\;\mathbin{:}\;\Conid{Set}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{field}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{from}\;{}\<[11]%
\>[11]{}\mathbin{:}\;\Varid{a}\;\Varid{→}\;\Varid{b}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{to}\;{}\<[11]%
\>[11]{}\mathbin{:}\;\Varid{b}\;\Varid{→}\;\Varid{a}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{iso₁}\;{}\<[11]%
\>[11]{}\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{x}\;\mathbin{:}\;\Varid{a}\mskip1.5mu\}\;\Varid{→}\;\Varid{to}\;(\Varid{from}\;\Varid{x})\;\Varid{≡}\;\Varid{x}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{iso₂}\;{}\<[11]%
\>[11]{}\mathbin{:}\;\Varid{∀}\;\{\mskip1.5mu \Varid{y}\;\mathbin{:}\;\Varid{b}\mskip1.5mu\}\;\Varid{→}\;\Varid{from}\;(\Varid{to}\;\Varid{y})\;\Varid{≡}\;\Varid{y}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The functions $from$ and $to$ allow for conversion between $a$ and $b$, while $iso_1$ and $iso_2$ assert that these conversion functions do indeed form a bijection between values of type $a$ and type $b$. Given an isomorphism $a \cong b$, a generator $\mathbb{G}\ a\ n$ can easily be converted to a generator $\mathbb{G}\ b\ n$ by using $\llparenthesis\ \texttt{\_$\cong$\_}.to\ gen\ \rrparenthesis$. 

We can say that some type $a$ is \texttt{Regular} if there exists some value $f$ of type $Reg$ such that $a$ is isomorphic to $\mu\ f$. We capture this notion using the following record: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{record}\;\Conid{Regular}\;(\Varid{a}\;\mathbin{:}\;\Conid{Set})\;\mathbin{:}\;\Conid{Set}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{field}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{W}\;\mathbin{:}\;\Conid{Σ[}\;\Varid{f}\;\Varid{∈}\;\Conid{Reg}\;\mskip1.5mu]\;(\Varid{a}\;\Varid{≅}\;\Varid{μ}\;\Varid{f}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Given a value of type $Regular\ a$, we can now derive a generator for $a$ by deriving a generator for $f$, and traveling through the isomorphism by applying the aforementioned conversion. 

\subsection{Proving Correctness of Generators}

\subsubsection{Combinator Correctness}

\subsubsection{Correctness of Derived Generators}

\subsection{Generalization to Generic Enumeration of Indexed Types}

What examples can you handle already? \cite{lampropoulos2017generating}

What prototype have I built? \cite{duregaard2013feat, claessen2010quickspec}

How can I generalize these results? What problems have I identified or
do I expect? \cite{yakushev2009generic}

\section{Timetable and planning}

What will I do with the remainder of my thesis? \cite{claessen2015generating}

Give an approximate estimation/timetable for what you will do and when you will be done.

\newpage
\bibliography{references}{}
\bibliographystyle{plain}

\end{document}paramter
