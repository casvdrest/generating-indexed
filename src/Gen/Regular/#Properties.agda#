{-# OPTIONS --type-in-type #-}

open import src.Gen.Base
open import src.Gen.Properties
open import src.Gen.Regular.Generic
open import src.Gen.Regular.Isomorphism
open import src.Data using (_âˆˆ_; here; Î )

open import Data.Unit
open import Data.Product
open import Data.Sum
open import Data.Nat
open import Data.List

open import Category.Monad

open import Relation.Binary.PropositionalEquality
open Relation.Binary.PropositionalEquality.â‰¡-Reasoning

module src.Gen.Regular.Properties where

  open RawMonad â¦ƒ...â¦„ using (_âŠ›_; pure)

  ------ U Combinator (Unit) ------

  ugen-complete : âˆ€ {n : â„•} {a : Set}  â†’ (Î» n â†’ ugen {n} {a}) â† tt
  ugen-complete {n} = (n , refl) , here
  

  ------ âŠ• combinator (Coproduct) ------

  constr-preserves-elem : âˆ€ {a b : Set} {f : a â†’ b}
                            {g : Î  â„• (ğ”¾ a)} {x : a}
                          â†’ g â† x
                          ---------------------------
                          â†’ (Î» n â†’ â¦‡ f (g n) â¦ˆ) â† f x
  constr-preserves-elem {f = f} (p , elem) =
    p , list-ap-complete {fs = f âˆ· []} here elem

  
  âŠ•gen-complete-left : âˆ€ {n : â„•} {a : Set} {f g : Reg}
                         {gâ‚ : Î  â„• (ğ”¾ (âŸ¦ f âŸ§ a))} {gâ‚‚ : Î  â„• (ğ”¾ (âŸ¦ g âŸ§ a))}
                         {x : âŸ¦ f âŸ§ a} â†’ gâ‚ â† x
                       -------------------------------------
                       â†’ (Î» n â†’ âŠ•gen {f = f} {g = g} (gâ‚ n) (gâ‚‚ n)) â† injâ‚ x
  âŠ•gen-complete-left {gâ‚ = gâ‚} {gâ‚‚ = gâ‚‚} p =
    âˆ¥-complete-left {f = Î» n â†’ â¦‡ injâ‚ (gâ‚ n) â¦ˆ} {g = Î» n â†’ â¦‡ injâ‚‚ (gâ‚‚ n) â¦ˆ}
      (constr-preserves-elem {g = gâ‚} p)

  
  âŠ•gen-complete-right : âˆ€ {a : Set} {f g : Reg}
                          {gâ‚ : Î  â„• (ğ”¾ (âŸ¦ f âŸ§ a))} {gâ‚‚ : Î  â„• (ğ”¾ (âŸ¦ g âŸ§ a))}
                        â†’ {y : âŸ¦ g âŸ§ a} â†’ gâ‚‚ â† y
                        -------------------------------------
                        â†’ (Î» n â†’ âŠ•gen {f = f} {g = g} (gâ‚ n) (gâ‚‚ n)) â† injâ‚‚ y
  âŠ•gen-complete-right {gâ‚ = gâ‚} {gâ‚‚ = gâ‚‚} p =
    âˆ¥-complete-right {f = Î» n â†’ â¦‡ injâ‚ (gâ‚ n) â¦ˆ} {g = Î» n â†’ â¦‡ injâ‚‚ (gâ‚‚ n) â¦ˆ}
      (constr-preserves-elem {g = gâ‚‚} p)
  
  
  ------ âŠ— combinator (Product) ------

  âŠ—gen-complete : âˆ€ {n : â„•} {a : Set} {f g : Reg}
                    {gâ‚ : Î  â„• (ğ”¾ (âŸ¦ f âŸ§ a))} {gâ‚‚ : Î  â„• (ğ”¾ (âŸ¦ g âŸ§ a))}
                    {x : âŸ¦ f âŸ§ a} {y : âŸ¦ g âŸ§ a}
                  â†’ (pâ‚ : gâ‚ â† x) â†’ (pâ‚‚ : gâ‚‚ â† y)
                  â†’ depth {f = gâ‚} pâ‚ â‰¡ depth {f = gâ‚‚} pâ‚‚
                  --------------------------------------
                  â†’ (Î» n â†’ âŠ—gen {f = f} {g = g} (gâ‚ n) (gâ‚‚ n)) â† (x , y)
  âŠ—gen-complete {gâ‚ = gâ‚} {gâ‚‚ = gâ‚‚}  p1 p2 = âŠ›-complete {f = gâ‚} {g = gâ‚‚} p1 p2


  ------ K combinator (constants) ------

  kgen-complete : âˆ€ {n : â„•} {a b : Set} {x : b} {f : âŸª ğ”¾ b âŸ«}
                  â†’ (Î» n â†’ âŸ¨_âŸ© {n = n} f) â† x
                  --------------------------------------------
                  â†’ (Î» n â†’ (kgen {a = a} {g = f})) â† x
  kgen-complete (p , snd) = p , snd


  ------ I combinator (constants) ------

  igen-complete : âˆ€ {n : â„•} {a : Set} {f : Reg} {x : âŸ¦ f âŸ§ a} {g : Î  â„• (ğ”¾ (âŸ¦ f âŸ§ a))} â†’ g â† x â†’ (Î» n â†’ igen {f = f} (g n)) â† x
  igen-complete p = p


  fix-lemma : âˆ€ {n : â„•} {f : Reg} â†’ âŸ¨ deriveGen {f = f} âŸ© (suc n , refl) â‰¡ deriveGen {f = f} {g = f} {n = n} âŸ¨ deriveGen {f = f} âŸ© (n , refl)
  fix-lemma {zero} = refl
  fix-lemma {suc n} {f} = refl

  -----
  
  complete : âˆ€ {n : â„•} {f g : Reg} {x : âŸ¦ f âŸ§ (Î¼ g)} â†’ (Î» n â†’ deriveGen {f = f} âŸ¨ deriveGen {f = g} âŸ©) â† x
  complete {f = U} {g} {x} = ugen-complete
  complete {f = f âŠ• fâ‚} {g} {injâ‚ x} = âŠ•gen-complete-left complete
  complete {f = f âŠ• fâ‚} {g} {injâ‚‚ y} = âŠ•gen-complete-right complete
  complete {f = f âŠ— fâ‚} {g} {x} = {!!}
  complete {f = I} {g} {x} = igen-complete complete
  complete {f = K xâ‚} {g} {x} = kgen-complete complete
