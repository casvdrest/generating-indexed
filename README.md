# Term Generation for Indexed Datatypes

Note: All code in this repository was written as part of my Master's Thesis (conducted between 12 '18 and 07 `19). Goal of this thesis is to work towards enumeration/sampling of *indexed datatypes*. 

**All code in this repository is currently under heavy development. Definitions may change and not everything will necessarily work.**

## The Generator type

This repository contains a port of a subset of the ideas on test data generation that were proposed with the introduction of [SmallCheck](https://github.com/feuerbach/smallcheck) to Agda. See the following paper for a more elaborate description:

* Runciman, C., Naylor, M., & Lindblad, F. (2008, September). Smallcheck and lazy smallcheck: automatic exhaustive testing for small values. In Acm sigplan notices (Vol. 44, No. 2, pp. 37-48). ACM.

A generator `𝔾 a` produces values of type `a` and is in its simplest form a function `ℕ -> List a`. The actual types used contain some augmentations in order to guarantee termination of recursive generators, but the core idea remains the same. Similarly, the code below serves illustrate and will not necessarily compile. 

### Generator Combinators

The `𝔾` type is an instance of both `Functor` and `Applicative`, meaning that generators can be assembled using the applicative style, shown below with Agda's *idiom brackets*: 

```
pair : 𝔾 a → 𝔾 b → 𝔾 (a × b)
pair a b = ⦇ a , b ⦈
```

Coproducts can be defined using the `∥` combinator: 

```
maybe : 𝔾 a → 𝔾 (Maybe a)
maybe a = ⦇ nothing ⦈
        ∥ ⦇ just a  ⦈
```

Recursive types can be generated by adding a recursive parameter, and taking a generator's fixed point: 

```
nat : 𝔾 ℕ → 𝔾 ℕ
nat μ = ⦇ zero  ⦈
      ∥ ⦇ suc μ ⦈ 
```

```
fix nat 5 ≡ 0 ∷ 1 ∷ 2 ∷ 3 ∷ 4 ∷ []
```

## Derived Generators for Regular Types

**TODO: write this**

## Proving completeness

**TODO: write this**


