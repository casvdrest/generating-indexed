# Term Generation for Indexed Datatypes

Note: All code in this repository was written as part of my Master's Thesis (conducted between 12 '18 and 07 `19). Goal of this thesis is to work towards enumeration/sampling of *indexed datatypes*. 

**All code in this repository is currently under heavy development. Definitions may change and not everything will necessarily work.**

## The Generator type

This repository contains a port of a subset of the ideas on test data generation that were proposed with the introduction of [SmallCheck](https://github.com/feuerbach/smallcheck) to Agda. See the following paper for a more elaborate description:

* Runciman, C., Naylor, M., & Lindblad, F. (2008, September). Smallcheck and lazy smallcheck: automatic exhaustive testing for small values. In Acm sigplan notices (Vol. 44, No. 2, pp. 37-48). ACM.

A generator `ğ”¾ a` produces values of type `a` and is in its simplest form a function `â„• -> List a`. The actual types used contain some augmentations in order to guarantee termination of recursive generators, but the core idea remains the same. Similarly, the code below serves illustrate and will not necessarily compile. 

### Generator Combinators

The `ğ”¾` type is an instance of both `Functor` and `Applicative`, meaning that generators can be assembled using the applicative style, shown below with Agda's *idiom brackets*: 

```
pair : ğ”¾ a â†’ ğ”¾ b â†’ ğ”¾ (a Ã— b)
pair a b = â¦‡ a , b â¦ˆ
```

Coproducts can be defined using the `âˆ¥` combinator: 

```
maybe : ğ”¾ a â†’ ğ”¾ (Maybe a)
maybe a = â¦‡ nothing â¦ˆ
        âˆ¥ â¦‡ just a  â¦ˆ
```

Recursive types can be generated by adding a recursive parameter, and taking a generator's fixed point: 

```
nat : ğ”¾ â„• â†’ ğ”¾ â„•
nat Î¼ = â¦‡ zero  â¦ˆ
      âˆ¥ â¦‡ suc Î¼ â¦ˆ 
```

```
fix nat 5 â‰¡ 0 âˆ· 1 âˆ· 2 âˆ· 3 âˆ· 4 âˆ· []
```

## Deriving Generators for Regular Types

For regular types, a complete generator can automatically be derived given an isomorphism to the fixed point of some pattern functor. Types can be represented using the following canonical set of combinators: 

```
data Reg : Set where
  U   : Reg 
  _âŠ•_ : Reg â†’ Reg â†’ Reg
  _âŠ—_ : Reg â†’ Reg â†’ Reg
  I   : Reg
  K   : Set â†’ Reg
```

Using these codes, we can define `â„•F = (U âŠ• I)` to be the code for `â„•`. Consequently we can show an isomorphism between `â„•` and `Fix â„•F`: 

```
  â„•â†’â„•F : â„• â†’ Fix â„•F
  â„•â†’â„•F zero = In (injâ‚ tt)
  â„•â†’â„•F (suc n) = In (injâ‚‚ (â„•â†’â„•F n))

  â„•Fâ†’â„• : Fix â„•F â†’ â„•
  â„•Fâ†’â„• (In (injâ‚ x)) = zero
  â„•Fâ†’â„• (In (injâ‚‚ y)) = suc (â„•Fâ†’â„• y)

  isoâ„• : âˆ€ {n : â„•} â†’ â„•Fâ†’â„• (â„•â†’â„•F n) â‰¡ n
  isoâ„• {zero} = refl
  isoâ„• {suc n} = cong suc isoâ„•

  isoâ„•F : âˆ€ {f : Fix â„•F} â†’ â„•â†’â„•F (â„•Fâ†’â„• f) â‰¡ f
  isoâ„•F {In (injâ‚ tt)} = refl
  isoâ„•F {In (injâ‚‚ y)}  = cong (In âˆ˜ injâ‚‚) isoâ„•F
  
  â„•â‰…â„•F : â„• â‰… Fix â„•F
  â„•â‰…â„•F = record { from = â„•â†’â„•F
                ; to   = â„•Fâ†’â„•
                ; isoâ‚ = isoâ„•
                ; isoâ‚‚ = isoâ„•F
                }
```

And use this isomorphism to show that `â„•` is a regular type: 

```
instance 
    â„•-Regular : Regular â„•
    â„•-Regular = record { W = â„•F , â„•â‰…â„•F }
```

meaning that we can automatically derive a generator for it: 

```
nat' : ğ”¾ â„•
nat' = isoGen â„• (U~ âŠ•~ I~)
```

`isoGen` takes one parameter that describes how to generate elements for the constants referred to by the code. In this case there are none. 

## Proving completeness

**TODO**


