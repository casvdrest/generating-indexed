# Term Generation for Indexed Datatypes

Note: All code in this repository was written as part of my Master's Thesis (conducted between 12 '18 and 07 `19). Goal of this thesis is to work towards enumeration/sampling of *indexed datatypes*. 

**All code in this repository is currently under heavy development. Definitions may change and not everything will necessarily work.**

## The Generator type

This repository contains a port of a subset of the ideas on test data generation that were proposed with the introduction of [SmallCheck](https://github.com/feuerbach/smallcheck) to Agda. See the following paper for a more elaborate description:

* Runciman, C., Naylor, M., & Lindblad, F. (2008, September). Smallcheck and lazy smallcheck: automatic exhaustive testing for small values. In Acm sigplan notices (Vol. 44, No. 2, pp. 37-48). ACM.

A generator `𝔾 a` produces values of type `a` and is in its simplest form a function `ℕ -> List a`. The actual types used contain some augmentations in order to guarantee termination of recursive generators, but the core idea remains the same. Similarly, the code below serves illustrate and will not necessarily compile. 

### Generator Combinators

The `𝔾` type is an instance of both `Functor` and `Applicative`, meaning that generators can be assembled using the applicative style, shown below with Agda's *idiom brackets*: 

```
pair : 𝔾 a → 𝔾 b → 𝔾 (a × b)
pair a b = ⦇ a , b ⦈
```

Coproducts can be defined using the `∥` combinator: 

```
maybe : 𝔾 a → 𝔾 (Maybe a)
maybe a = ⦇ nothing ⦈
        ∥ ⦇ just a  ⦈
```

Recursive types can be generated by adding a recursive parameter, and taking a generator's fixed point: 

```
nat : 𝔾 ℕ → 𝔾 ℕ
nat μ = ⦇ zero  ⦈
      ∥ ⦇ suc μ ⦈ 
```

```
fix nat 5 ≡ 0 ∷ 1 ∷ 2 ∷ 3 ∷ 4 ∷ []
```

## Deriving Generators for Regular Types

For regular types, a complete generator can automatically be derived given an isomorphism to the fixed point of some pattern functor. Types can be represented using the following canonical set of combinators: 

```
data Reg : Set where
  U   : Reg 
  _⊕_ : Reg → Reg → Reg
  _⊗_ : Reg → Reg → Reg
  I   : Reg
  K   : Set → Reg
```

Using these codes, we can define `ℕF = (U ⊕ I)` to be the code for `ℕ`. Consequently we can show an isomorphism between `ℕ` and `Fix ℕF`: 

```
  ℕ→ℕF : ℕ → Fix ℕF
  ℕ→ℕF zero = In (inj₁ tt)
  ℕ→ℕF (suc n) = In (inj₂ (ℕ→ℕF n))

  ℕF→ℕ : Fix ℕF → ℕ
  ℕF→ℕ (In (inj₁ x)) = zero
  ℕF→ℕ (In (inj₂ y)) = suc (ℕF→ℕ y)

  isoℕ : ∀ {n : ℕ} → ℕF→ℕ (ℕ→ℕF n) ≡ n
  isoℕ {zero} = refl
  isoℕ {suc n} = cong suc isoℕ

  isoℕF : ∀ {f : Fix ℕF} → ℕ→ℕF (ℕF→ℕ f) ≡ f
  isoℕF {In (inj₁ tt)} = refl
  isoℕF {In (inj₂ y)}  = cong (In ∘ inj₂) isoℕF
  
  ℕ≅ℕF : ℕ ≅ Fix ℕF
  ℕ≅ℕF = record { from = ℕ→ℕF
                ; to   = ℕF→ℕ
                ; iso₁ = isoℕ
                ; iso₂ = isoℕF
                }
```

And use this isomorphism to show that `ℕ` is a regular type: 

```
instance 
    ℕ-Regular : Regular ℕ
    ℕ-Regular = record { W = ℕF , ℕ≅ℕF }
```

meaning that we can automatically derive a generator for it: 

```
nat' : 𝔾 ℕ
nat' = isoGen ℕ (U~ ⊕~ I~)
```

`isoGen` takes one parameter that describes how to generate elements for the constants referred to by the code. In this case there are none. 

## Proving completeness

**TODO**


